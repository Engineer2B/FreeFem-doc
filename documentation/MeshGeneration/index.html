



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-3.1.0">
    
    
      
        <title>Mesh Generation - FreeFem++</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.11e41852.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.20ef595d.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#commands-for-mesh-generation" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="FreeFem++" class="md-header-nav__button md-logo">
          
            <img src="../../images/favicon.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                FreeFem++
              </span>
              <span class="md-header-nav__topic">
                Mesh Generation
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/FreeFem/FreeFem-doc/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      FreeFem++ on Github
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../.." title="Introduction" class="md-tabs__link">
          Introduction
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../" title="Documentation" class="md-tabs__link md-tabs__link--active">
          Documentation
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../reference/" title="Language References" class="md-tabs__link">
          Language References
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../tutorials/" title="Tutorials" class="md-tabs__link">
          Tutorials
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../examples/" title="Examples" class="md-tabs__link">
          Examples
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../../models/" title="Models" class="md-tabs__link">
          Models
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="FreeFem++" class="md-nav__button md-logo">
      
        <img src="../../images/favicon.png" width="48" height="48">
      
    </a>
    FreeFem++
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/FreeFem/FreeFem-doc/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      FreeFem++ on Github
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Introduction
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Introduction
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../.." title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/download/" title="Download" class="md-nav__link">
      Download
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/installation/" title="Installation" class="md-nav__link">
      Installation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/contributing/" title="How to contribute?" class="md-nav__link">
      How to contribute?
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/citation/" title="Citation" class="md-nav__link">
      Citation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/authors/" title="Authors" class="md-nav__link">
      Authors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/TODO/" title="TODO" class="md-nav__link">
      TODO
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      Documentation
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Documentation
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Notations/" title="Some Notations" class="md-nav__link">
      Some Notations
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Mesh Generation
      </label>
    
    <a href="./" title="Mesh Generation" class="md-nav__link md-nav__link--active">
      Mesh Generation
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#commands-for-mesh-generation" title="Commands for Mesh Generation" class="md-nav__link">
    Commands for Mesh Generation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#square" title="Square" class="md-nav__link">
    Square
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#border" title="Border" class="md-nav__link">
    Border
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multi-border" title="Multi-Border" class="md-nav__link">
    Multi-Border
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-structures-and-readwrite-statements-for-a-mesh" title="Data Structures and Read/Write Statements for a Mesh" class="md-nav__link">
    Data Structures and Read/Write Statements for a Mesh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-connectivity-and-data" title="Mesh Connectivity and data" class="md-nav__link">
    Mesh Connectivity and data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-keyword-triangulate" title="The keyword "triangulate"" class="md-nav__link">
    The keyword "triangulate"
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary-fem-spaces-built-as-empty-meshes" title="Boundary FEM Spaces Built as Empty Meshes" class="md-nav__link">
    Boundary FEM Spaces Built as Empty Meshes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remeshing" title="Remeshing" class="md-nav__link">
    Remeshing
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#movemesh" title="Movemesh" class="md-nav__link">
    Movemesh
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#regular-triangulation-htriangle" title="Regular Triangulation: hTriangle" class="md-nav__link">
    Regular Triangulation: hTriangle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adaptmesh" title="Adaptmesh" class="md-nav__link">
    Adaptmesh
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trunc" title="Trunc" class="md-nav__link">
    Trunc
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#splitmesh" title="Splitmesh" class="md-nav__link">
    Splitmesh
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#meshing-examples" title="Meshing Examples" class="md-nav__link">
    Meshing Examples
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh" title="How to change the label of elements and border elements of a mesh" class="md-nav__link">
    How to change the label of elements and border elements of a mesh
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mesh-in-three-dimensions" title="Mesh in three dimensions" class="md-nav__link">
    Mesh in three dimensions
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cube" title="Cube" class="md-nav__link">
    Cube
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#readwrite-statements-for-a-mesh-in-3d" title="Read/Write Statements for a Mesh in 3D" class="md-nav__link">
    Read/Write Statements for a Mesh in 3D
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tetgen-a-tetrahedral-mesh-generator" title="TetGen: A tetrahedral mesh generator" class="md-nav__link">
    TetGen: A tetrahedral mesh generator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reconstructrefine-a-three-dimensional-mesh-with-tetgen" title="Reconstruct/Refine a three dimensional mesh with TetGen" class="md-nav__link">
    Reconstruct/Refine a three dimensional mesh with TetGen
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#moving-mesh-in-three-dimensions" title="Moving mesh in three dimensions" class="md-nav__link">
    Moving mesh in three dimensions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#layer-mesh" title="Layer mesh" class="md-nav__link">
    Layer mesh
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#meshing-examples_1" title="Meshing examples" class="md-nav__link">
    Meshing examples
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build-a-3d-mesh-of-a-cube-with-a-balloon" title="Build a 3d mesh of a cube with a balloon" class="md-nav__link">
    Build a 3d mesh of a cube with a balloon
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#medit" title="Medit" class="md-nav__link">
    Medit
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mshmet" title="Mshmet" class="md-nav__link">
    Mshmet
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#freeyams" title="FreeYams" class="md-nav__link">
    FreeYams
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mmg3d" title="mmg3d" class="md-nav__link">
    mmg3d
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#a-first-3d-isotrope-mesh-adaptation-process" title="A first 3d isotrope mesh adaptation process" class="md-nav__link">
    A first 3d isotrope mesh adaptation process
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#build-a-2d-mesh-from-a-isoline" title="Build a 2d mesh from a isoline" class="md-nav__link">
    Build a 2d mesh from a isoline
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" title="References" class="md-nav__link">
    References
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../FiniteElement/" title="Finite Element" class="md-nav__link">
      Finite Element
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Visualization/" title="Visualization" class="md-nav__link">
      Visualization
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../AlgorithmsOptimization/" title="Algorithms & Optimization" class="md-nav__link">
      Algorithms & Optimization
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Parallelization/" title="Parallelization" class="md-nav__link">
      Parallelization
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Plugins/" title="Plugins" class="md-nav__link">
      Plugins
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Developers/" title="Developers" class="md-nav__link">
      Developers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../TODO/" title="TODO" class="md-nav__link">
      TODO
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Language References
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Language References
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/Types/" title="Types" class="md-nav__link">
      Types
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/GlobalVariables/" title="Global variables" class="md-nav__link">
      Global variables
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/QuadratureFormulae/" title="Quadrature formulae" class="md-nav__link">
      Quadrature formulae
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/Operators/" title="Operators" class="md-nav__link">
      Operators
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/Loops/" title="Loops" class="md-nav__link">
      Loops
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/IO/" title="I/O" class="md-nav__link">
      I/O
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/Functions/" title="Functions" class="md-nav__link">
      Functions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/ExternalLibraries/" title="External libraries" class="md-nav__link">
      External libraries
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../reference/TODO/" title="TODO" class="md-nav__link">
      TODO
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Tutorials
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Tutorials
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/" title="Getting started" class="md-nav__link">
      Getting started
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/Poisson/" title="Poisson's equation" class="md-nav__link">
      Poisson's equation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/EquationsClassification/" title="Classification of the equations" class="md-nav__link">
      Classification of the equations
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/Membrane/" title="Membrane" class="md-nav__link">
      Membrane
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/HeatExchanger/" title="Heat Exchanger" class="md-nav__link">
      Heat Exchanger
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/Acoustics/" title="Acoustics" class="md-nav__link">
      Acoustics
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/ThermalConduction/" title="Thermal Conduction" class="md-nav__link">
      Thermal Conduction
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/FanBlade/" title="Irrotational Fan Blade Flow and Thermal effects" class="md-nav__link">
      Irrotational Fan Blade Flow and Thermal effects
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/RotatingHill/" title="Pure convection, The rotating hill" class="md-nav__link">
      Pure convection, The rotating hill
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/Elasticity/" title="The system of elasticity" class="md-nav__link">
      The system of elasticity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/Stokes/" title="The system of Stokes for fluids" class="md-nav__link">
      The system of Stokes for fluids
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/NavierStokesProjection/" title="A projection Algorithm for the Navier-Stokes equations" class="md-nav__link">
      A projection Algorithm for the Navier-Stokes equations
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/NavierStokesNewton/" title="Newton method for the steady Navier-Stokes equations" class="md-nav__link">
      Newton method for the steady Navier-Stokes equations
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/ALargeFluidProblem/" title="A large fluid problem" class="md-nav__link">
      A large fluid problem
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/ComplexNumbers/" title="An example with complex numbers" class="md-nav__link">
      An example with complex numbers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/OptimalControl/" title="Optimal control" class="md-nav__link">
      Optimal control
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/FlowWithShocks/" title="A flow with shocks" class="md-nav__link">
      A flow with shocks
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/HeatEquationOptimization/" title="Time dependent schema optimization for heat equations" class="md-nav__link">
      Time dependent schema optimization for heat equations
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/TimeDependentStokes/" title="A transient Stokes solver in matrix form" class="md-nav__link">
      A transient Stokes solver in matrix form
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/WifiPropagation/" title="Wifi Propagation" class="md-nav__link">
      Wifi Propagation
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/MatlabOctavePlot/" title="Matlab / Octave Plots" class="md-nav__link">
      Matlab / Octave Plots
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tutorials/TODO/" title="TODO" class="md-nav__link">
      TODO
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Examples
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Examples
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../examples/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../examples/TODO/" title="TODO" class="md-nav__link">
      TODO
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      Models
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        Models
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/" title="Home" class="md-nav__link">
      Home
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/StaticProblems/" title="Static problems" class="md-nav__link">
      Static problems
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/Elasticity/" title="Elasticity" class="md-nav__link">
      Elasticity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/NonLinearStaticProblems/" title="Non-linear static problems" class="md-nav__link">
      Non-linear static problems
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/EigenValueProblems/" title="Eigenvalue problems" class="md-nav__link">
      Eigenvalue problems
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/EvolutionProblems/" title="Evolution problems" class="md-nav__link">
      Evolution problems
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/NavierStokesEquations/" title="Navier-Stokes equations" class="md-nav__link">
      Navier-Stokes equations
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/VariationalInequality/" title="Variational inequality" class="md-nav__link">
      Variational inequality
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/DomainDecomposition/" title="Domain decomposition" class="md-nav__link">
      Domain decomposition
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/FluidStructureCoupledProblem/" title="Fluid-Structure coupled problem" class="md-nav__link">
      Fluid-Structure coupled problem
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/TransmissionProblem/" title="Transmission problem" class="md-nav__link">
      Transmission problem
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/FreeBoundaryProblem/" title="Free boundary problem" class="md-nav__link">
      Free boundary problem
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/NonLinearElasticity/" title="Non-linear elasticity" class="md-nav__link">
      Non-linear elasticity
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/CompressibleNeoHookeanMaterials/" title="Compressible Neo-Hookean materials" class="md-nav__link">
      Compressible Neo-Hookean materials
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/WhisperingGalleryModes/" title="Whispering gallery modes" class="md-nav__link">
      Whispering gallery modes
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../models/TODO/" title="TODO" class="md-nav__link">
      TODO
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#commands-for-mesh-generation" title="Commands for Mesh Generation" class="md-nav__link">
    Commands for Mesh Generation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#square" title="Square" class="md-nav__link">
    Square
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#border" title="Border" class="md-nav__link">
    Border
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multi-border" title="Multi-Border" class="md-nav__link">
    Multi-Border
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-structures-and-readwrite-statements-for-a-mesh" title="Data Structures and Read/Write Statements for a Mesh" class="md-nav__link">
    Data Structures and Read/Write Statements for a Mesh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-connectivity-and-data" title="Mesh Connectivity and data" class="md-nav__link">
    Mesh Connectivity and data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-keyword-triangulate" title="The keyword "triangulate"" class="md-nav__link">
    The keyword "triangulate"
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary-fem-spaces-built-as-empty-meshes" title="Boundary FEM Spaces Built as Empty Meshes" class="md-nav__link">
    Boundary FEM Spaces Built as Empty Meshes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remeshing" title="Remeshing" class="md-nav__link">
    Remeshing
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#movemesh" title="Movemesh" class="md-nav__link">
    Movemesh
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#regular-triangulation-htriangle" title="Regular Triangulation: hTriangle" class="md-nav__link">
    Regular Triangulation: hTriangle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adaptmesh" title="Adaptmesh" class="md-nav__link">
    Adaptmesh
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#trunc" title="Trunc" class="md-nav__link">
    Trunc
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#splitmesh" title="Splitmesh" class="md-nav__link">
    Splitmesh
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#meshing-examples" title="Meshing Examples" class="md-nav__link">
    Meshing Examples
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh" title="How to change the label of elements and border elements of a mesh" class="md-nav__link">
    How to change the label of elements and border elements of a mesh
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mesh-in-three-dimensions" title="Mesh in three dimensions" class="md-nav__link">
    Mesh in three dimensions
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cube" title="Cube" class="md-nav__link">
    Cube
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#readwrite-statements-for-a-mesh-in-3d" title="Read/Write Statements for a Mesh in 3D" class="md-nav__link">
    Read/Write Statements for a Mesh in 3D
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tetgen-a-tetrahedral-mesh-generator" title="TetGen: A tetrahedral mesh generator" class="md-nav__link">
    TetGen: A tetrahedral mesh generator
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reconstructrefine-a-three-dimensional-mesh-with-tetgen" title="Reconstruct/Refine a three dimensional mesh with TetGen" class="md-nav__link">
    Reconstruct/Refine a three dimensional mesh with TetGen
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#moving-mesh-in-three-dimensions" title="Moving mesh in three dimensions" class="md-nav__link">
    Moving mesh in three dimensions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#layer-mesh" title="Layer mesh" class="md-nav__link">
    Layer mesh
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#meshing-examples_1" title="Meshing examples" class="md-nav__link">
    Meshing examples
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#build-a-3d-mesh-of-a-cube-with-a-balloon" title="Build a 3d mesh of a cube with a balloon" class="md-nav__link">
    Build a 3d mesh of a cube with a balloon
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#medit" title="Medit" class="md-nav__link">
    Medit
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mshmet" title="Mshmet" class="md-nav__link">
    Mshmet
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#freeyams" title="FreeYams" class="md-nav__link">
    FreeYams
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mmg3d" title="mmg3d" class="md-nav__link">
    mmg3d
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#a-first-3d-isotrope-mesh-adaptation-process" title="A first 3d isotrope mesh adaptation process" class="md-nav__link">
    A first 3d isotrope mesh adaptation process
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#build-a-2d-mesh-from-a-isoline" title="Build a 2d mesh from a isoline" class="md-nav__link">
    Build a 2d mesh from a isoline
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" title="References" class="md-nav__link">
    References
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/FreeFem/FreeFem-doc/edit/master/docs/documentation/MeshGeneration.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>Mesh Generation</h1>
                
                <h2 id="commands-for-mesh-generation">Commands for Mesh Generation<a class="headerlink" href="#commands-for-mesh-generation" title="Permanent link">#</a></h2>
<p>Let us begin with the two important keywords: <code class="codehilite">border</code> and <code class="codehilite">buildmesh</code>.</p>
<h3 id="square">Square<a class="headerlink" href="#square" title="Permanent link">#</a></h3>
<p>The command <code class="codehilite">square</code> triangulates the unit square.</p>
<p>The following generates a <span><span class="MathJax_Preview">4 \times 5</span><script type="math/tex">4 \times 5</script></span> grid in the unit square <span><span class="MathJax_Preview">[0,1]^2</span><script type="math/tex">[0,1]^2</script></span>. The labels of the boundaries are shown in <a href="#Fig1">Fig. 1</a>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh Th = square(4, 5);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig1">Fig 1</a>: Boundary labels of the mesh by <code class="codehilite">square(10,10)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Square" src="../images/MeshGeneration_Square.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
<p>To construct a <span><span class="MathJax_Preview">n\times m</span><script type="math/tex">n\times m</script></span> grid in the rectangle <span><span class="MathJax_Preview">[x_0,x_1]\times [y_0,y_1]</span><script type="math/tex">[x_0,x_1]\times [y_0,y_1]</script></span>, proceed as follows:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real x0 = 1.2;
real x1 = 1.8;
real y0 = 0;
real y1 = 1;
int n = 5;
real m = 20;
mesh Th = square(n, m, [x0+(x1-x0)*x, y0+(y1-y0)*y]);
</pre></div>
</td></tr></table>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Adding the named parameter <code class="codehilite">flags=icase</code> with icase:</p>
<p><ol start="0">
    <li>will produce a mesh where all quads are split with diagonal <span><span class="MathJax_Preview">x-y=constant</span><script type="math/tex">x-y=constant</script></span></li>
    <li>will produce <em>Union Jack flag</em> type of mesh</li>
    <li>will produce a mesh where all quads are split with diagonal <span><span class="MathJax_Preview">x+y=constant</span><script type="math/tex">x+y=constant</script></span></li>
    <li>same as in case 0, except two corners where the triangles are the same as case 2 to avoid having 3 vertices on the boundary</li>
    <li>same as in case 2, except two corners where the triangles are the same as case 0 to avoid having 3 vertices on the boundary</li>
</ol></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh Th = square(n, m, [x0+(x1-x0)*x, y0+(y1-y0)*y], flags=icase);
</pre></div>
</td></tr></table>

</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Adding the named parameter <code class="codehilite">label=labs</code> will change the 4 default label numbers to <code class="codehilite">labs[i-1]</code>, for example <code class="codehilite">int[int] labs=[11, 12, 13, 14]</code>, and adding the named parameter <code class="codehilite">region=10</code> will change the region number to <span><span class="MathJax_Preview">10</span><script type="math/tex">10</script></span>, for instance (v 3.8).</p>
<p>To see all of these flags at work, try the file <a href="scripts/MeshGeneration/SquareMesh.edp" download>SquareMesh.edp file</a>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>for (int i = 0; i &lt; 5; ++i){
    int[int] labs = [11, 12, 13, 14];
    mesh Th = square(3, 3, flags=i, label=labs, region=10);
    plot(Th, wait=1, cmm=&quot;square flags = &quot;+i );
}
</pre></div>
</td></tr></table>

</div>
<h3 id="border">Border<a class="headerlink" href="#border" title="Permanent link">#</a></h3>
<p>Boundaries are defined piecewise by parametrized curves. The pieces can only intersect at their endpoints, but it is possible to join more than two endpoints. This can be used to structure the mesh if an area touches a border and create new regions by dividing larger ones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>int upper = 1;
int others = 2;
int inner = 3;

border C01(t=0, 1){x=0; y=-1+t; label=upper;}
border C02(t=0, 1){x=1.5-1.5*t; y=-1; label=upper;}
border C03(t=0, 1){x=1.5; y=-t; label=upper;}
border C04(t=0, 1){x=1+0.5*t; y=0; label=others;}
border C05(t=0, 1){x=0.5+0.5*t; y=0; label=others;}
border C06(t=0, 1){x=0.5*t; y=0; label=others;}
border C11(t=0, 1){x=0.5; y=-0.5*t; label=inner;}
border C12(t=0, 1){x=0.5+0.5*t; y=-0.5; label=inner;}
border C13(t=0, 1){x=1; y=-0.5+0.5*t; label=inner;}

int n = 10;
plot(C01(-n) + C02(-n) + C03(-n) + C04(-n) + C05(-n)
    + C06(-n) + C11(n) + C12(n) + C13(n), wait=true);

mesh Th = buildmesh(C01(-n) + C02(-n) + C03(-n) + C04(-n) + C05(-n)
    + C06(-n) + C11(n) + C12(n) + C13(n));

plot(Th, wait=true);

cout &lt;&lt; &quot;Part 1 has region number &quot; &lt;&lt; Th(0.75, -0.25).region &lt;&lt; endl;
cout &lt;&lt; &quot;Part 2 has redion number &quot; &lt;&lt; Th(0.25, -0.25).region &lt;&lt; endl;
</pre></div>
</td></tr></table>

<p>Borders and mesh are respectively shown in <a href="#Fig2">Fig. 2</a> and <a href="#Fig3">Fig. 3</a>.</p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig2">Fig. 2</a>: Multiple border ends intersect</th>
<th align="center"><a name="Fig3">Fig. 3</a>: Generated mesh</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Multiple border ends intersect" src="../images/MeshGeneration_Border1.png" /></td>
<td align="center"><img alt="Generated Mesh" src="../images/MeshGeneration_Border2.png" /></td>
</tr>
</tbody>
</table>
<p>Triangulation keywords assume that the domain is defined as being on the <em>left</em> (resp <em>right</em>) of its oriented parameterized boundary</p>
<div>
<div class="MathJax_Preview">
\Gamma_j = \{(x,y)\left|\; x=\varphi_x(t),\, y=\varphi_y(t),\, a_j\le t\le b_j\right.\}
</div>
<script type="math/tex; mode=display">
\Gamma_j = \{(x,y)\left|\; x=\varphi_x(t),\, y=\varphi_y(t),\, a_j\le t\le b_j\right.\}
</script>
</div>
<p>To check the orientation plot <span><span class="MathJax_Preview">t\mapsto (\varphi_x(t),\varphi_y(t)),\, t_0\le t\le t_1</span><script type="math/tex">t\mapsto (\varphi_x(t),\varphi_y(t)),\, t_0\le t\le t_1</script></span>. If it is as in <a href="#Fig4">Fig. 4</a>, then the domain lies on the shaded area, otherwise it lies on the opposite side.</p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig4">Fig. 4</a>: Orientation of the boundary defined by <span><span class="MathJax_Preview">(\phi_x(t),\phi_y(t))</span><script type="math/tex">(\phi_x(t),\phi_y(t))</script></span></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Border" src="../images/MeshGeneration_Border3.png" /></td>
</tr>
</tbody>
</table>
<p>The general expression to define a triangulation with <code class="codehilite">buildmesh</code> is</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh Mesh_Name = buildmesh(Gamma1(m1)+...+GammaJ(mj), OptionalParameter);
</pre></div>
</td></tr></table>

<p>where <span><span class="MathJax_Preview">m_j</span><script type="math/tex">m_j</script></span> are positive or negative numbers to indicate how many vertices should be on <span><span class="MathJax_Preview">\Gamma_j,\, \Gamma=\cup_{j=1}^J \Gamma_J</span><script type="math/tex">\Gamma_j,\, \Gamma=\cup_{j=1}^J \Gamma_J</script></span>, and the optional parameter (see also <a href="../reference/Functions/#buildmesh">References</a>), separated with a comma, can be:</p>
<ul>
<li><code class="codehilite">nbvx= int</code>, to set the maximum number of vertices in the mesh.</li>
<li><code class="codehilite">fixedborder= bool</code>, to say if the mesh generator can change the boundary mesh or not (by default the boundary mesh can change; beware that with periodic boundary conditions (see. <a href="FiniteElement">Finite Element</a>), it can be dangerous.</li>
</ul>
<p>The orientation of boundaries can be changed by changing the sign of <span><span class="MathJax_Preview">m_j</span><script type="math/tex">m_j</script></span>.</p>
<p>The following example shows how to change the orientation. The example generates the unit disk with a small circular hole, and assigns "1" to the unit disk ("2" to the circle inside). The boundary label <strong>must be non-zero</strong>, but it can also be omitted.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
border b(t=0, 2*pi){x=0.3+0.3*cos(t); y=0.3*sin(t); label=2;}
plot(a(50) + b(30)); //to see a plot of the border mesh
mesh Thwithouthole = buildmesh(a(50) + b(30));
mesh Thwithhole = buildmesh(a(50) + b(-30));
plot(Thwithouthole, ps=&quot;Thwithouthole.eps&quot;);
plot(Thwithhole, ps=&quot;Thwithhole.eps&quot;);
</pre></div>
</td></tr></table>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Notice that the orientation is changed by <code class="codehilite">b(-30)</code> in the 5th line. In the 7th line, <code class="codehilite">ps=&quot;fileName&quot;</code> is used to generate a postscript file with identification shown on the figure.</p>
</div>
<table>
<thead>
<tr>
<th align="center"><a name="Fig5">Fig. 5</a>: Mesh without hole</th>
<th align="center"><a name="Fig6">Fig. 6</a>: Mesh with hole</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Mesh without hole" src="../images/MeshGeneration_Border4.png" /></td>
<td align="center"><img alt="Mesh with hole" src="../images/MeshGeneration_Border5.png" /></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Borders are evaluated only at the time <code class="codehilite">plot</code> or <code class="codehilite">buildmesh</code> is called so the global variables are defined at this time. In this case, since <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> is changed between the two border calls, the following code will not work because the first border will be computed with r=0.3:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real r=1;
border a(t=0, 2*pi){x=r*cos(t); y=r*sin(t); label=1;}
r=0.3;
border b(t=0, 2*pi){x=r*cos(t); y=r*sin(t); label=1;}
mesh Thwithhole = buildmesh(a(50) + b(-30)); // bug (a trap) because
                                             // the two circles have the same radius = $0.3$
</pre></div>
</td></tr></table>

</div>
<h3 id="multi-border">Multi-Border<a class="headerlink" href="#multi-border" title="Permanent link">#</a></h3>
<p>Sometimes it can be useful to make an array of the border, but unfortunately it is incompatible with the FreeFem++ syntax. To bypass this problem, if the number of segments of the discretization <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> is an array, we make an implicit loop on all of the values of the array, and the index variable <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> of the loop is defined after the parameter definition, like in <code class="codehilite">border a(t=0, 2*pi; i)</code> ...</p>
<p>A first very small example:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border a(t=0, 2*pi; i){x=(i+1)*cos(t); y=(i+1)*sin(t); label=1;}
int[int] nn = [10, 20, 30];
plot(a(nn)); //plot 3 circles with 10, 20, 30 points
</pre></div>
</td></tr></table>

<p>And a more complex example to define a square with small circles:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real[int] xx = [0, 1, 1, 0],
          yy = [0, 0, 1, 1];
//radius, center of the 4 circles
real[int] RC = [0.1, 0.05, 0.05, 0.1],
          XC = [0.2, 0.8, 0.2, 0.8],
          YC = [0.2, 0.8, 0.8, 0.2];
int[int] NC = [-10,-11,-12,13]; //list number of $\pm$ segments of the 4 circles borders

border bb(t=0, 1; i)
{
    // i is the index variable of the multi border loop
    int ii = (i+1)%4;
    real t1 = 1-t;
    x = xx[i]*t1 + xx[ii]*t;
    y = yy[i]*t1 + yy[ii]*t;
    label = 0;
}

border cc(t=0, 2*pi; i)
{
    x = RC[i]*cos(t) + XC[i];
    y = RC[i]*sin(t) + YC[i];
    label = i + 1;
}
int[int] nn = [4, 4, 5, 7]; //4 border, with 4, 4, 5, 7 segment respectively
plot(bb(nn), cc(NC), wait=1);
mesh th = buildmesh(bb(nn) + cc(NC));
plot(th, wait=1);
</pre></div>
</td></tr></table>

<h3 id="data-structures-and-readwrite-statements-for-a-mesh">Data Structures and Read/Write Statements for a Mesh<a class="headerlink" href="#data-structures-and-readwrite-statements-for-a-mesh" title="Permanent link">#</a></h3>
<p>Users who want to read a triangulation made elsewhere should see the structure of the file generated below:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border C(t=0, 2*pi){x=cos(t); y=sin(t);}
mesh Th = buildmesh(C(10));
savemesh(Th, &quot;mesh.msh&quot;);
</pre></div>
</td></tr></table>

<p>The mesh is shown on <a href="#Fig7">Fig. 7</a>.</p>
<p>The information about <code class="codehilite">Th</code> are saved in the file <code class="codehilite">mesh.msh</code> whose structure is shown on <a href="#Tab1">Tab. 1</a>.</p>
<p>There, <span><span class="MathJax_Preview">n_v</span><script type="math/tex">n_v</script></span> denotes the number of vertices, <span><span class="MathJax_Preview">n_t</span><script type="math/tex">n_t</script></span> the number of triangles and <span><span class="MathJax_Preview">n_s</span><script type="math/tex">n_s</script></span> the number of edges on boundary.</p>
<p>For each vertex <span><span class="MathJax_Preview">q^i,\, i=1,\cdots,n_v</span><script type="math/tex">q^i,\, i=1,\cdots,n_v</script></span>, denoted by <span><span class="MathJax_Preview">(q^i_x,q^i_y)</span><script type="math/tex">(q^i_x,q^i_y)</script></span> the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>-coordinate and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>-coordinate.</p>
<p>Each triangle <span><span class="MathJax_Preview">T_k, k=1,\cdots,n_t</span><script type="math/tex">T_k, k=1,\cdots,n_t</script></span> has three vertices <span><span class="MathJax_Preview">q^{k_1},\, q^{k_2},\,q^{k_3}</span><script type="math/tex">q^{k_1},\, q^{k_2},\,q^{k_3}</script></span> that are oriented counter-clockwise.</p>
<p>The boundary consists of 10 lines <span><span class="MathJax_Preview">L_i,\, i=1,\cdots,10</span><script type="math/tex">L_i,\, i=1,\cdots,10</script></span> whose end points are <span><span class="MathJax_Preview">q^{i_1},\, q^{i_2}</span><script type="math/tex">q^{i_1},\, q^{i_2}</script></span>.</p>
<table>
<thead>
<tr>
<th align="left"><a name="Fig7">Fig. 7</a>: Mesh by <code class="codehilite">buildmesh(C(10))</code></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="Mesh Sample" src="../images/MeshGeneration_Data.png" /></td>
<td align="left">In the left figure, we have the following.<br><span><span class="MathJax_Preview">n_v=14, n_t=16, n_s=10</span><script type="math/tex">n_v=14, n_t=16, n_s=10</script></span><br><span><span class="MathJax_Preview">q^1=(-0.309016994375, 0.951056516295)</span><script type="math/tex">q^1=(-0.309016994375, 0.951056516295)</script></span><br><span><span class="MathJax_Preview">\vdots\qquad \vdots\qquad \vdots</span><script type="math/tex">\vdots\qquad \vdots\qquad \vdots</script></span><br><span><span class="MathJax_Preview">q^{14}=(-0.309016994375, -0.951056516295)</span><script type="math/tex">q^{14}=(-0.309016994375, -0.951056516295)</script></span><br>The vertices of <span><span class="MathJax_Preview">T_1</span><script type="math/tex">T_1</script></span> are <span><span class="MathJax_Preview">q^9, q^{12},\, q^{10}</span><script type="math/tex">q^9, q^{12},\, q^{10}</script></span>.<br><span><span class="MathJax_Preview">\vdots\qquad \vdots\qquad \vdots</span><script type="math/tex">\vdots\qquad \vdots\qquad \vdots</script></span><br>The vertices of <span><span class="MathJax_Preview">T_{16}</span><script type="math/tex">T_{16}</script></span> are <span><span class="MathJax_Preview">q^9, q^{10}, q^{6}</span><script type="math/tex">q^9, q^{10}, q^{6}</script></span>.<br>The edge of the 1st side <span><span class="MathJax_Preview">L_1</span><script type="math/tex">L_1</script></span> are <span><span class="MathJax_Preview">q^6, q^5</span><script type="math/tex">q^6, q^5</script></span>.<br><span><span class="MathJax_Preview">\vdots\qquad \vdots\qquad \vdots</span><script type="math/tex">\vdots\qquad \vdots\qquad \vdots</script></span><br>The edge of the 10th side <span><span class="MathJax_Preview">L_{10}</span><script type="math/tex">L_{10}</script></span> are <span><span class="MathJax_Preview">q^{10}, q^6</span><script type="math/tex">q^{10}, q^6</script></span>.</td>
</tr>
</tbody>
</table>
<p><center></p>
<table>
<thead>
<tr>
<th align="left"><a name="Tab1">Tab. 1</a>: The structure of <code class="codehilite">mesh_sample.msh</code></th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Content of the file</td>
<td align="left">Explanation</td>
</tr>
<tr>
<td align="left">14 16 10<br>-0.309016994375 0.951056516295 1<br>0.309016994375 0.951056516295 1<br><span><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span> <span><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span> <span><span class="MathJax_Preview">\vdots</span><script type="math/tex">\vdots</script></span><br>-0.309016994375 -0.951056516295 1</td>
<td align="left"><span><span class="MathJax_Preview">n_v\qquad n_t\qquad n_e</span><script type="math/tex">n_v\qquad n_t\qquad n_e</script></span><br><span><span class="MathJax_Preview">q^1_x\qquad q^1_y\qquad</span><script type="math/tex">q^1_x\qquad q^1_y\qquad</script></span> boundary label=1<br><span><span class="MathJax_Preview">q^2_x\qquad q^2_y\qquad</span><script type="math/tex">q^2_x\qquad q^2_y\qquad</script></span> boundary label=1<br><br><span><span class="MathJax_Preview">q^{14}_x\qquad q^{14}_y\quad</span><script type="math/tex">q^{14}_x\qquad q^{14}_y\quad</script></span> boundary label=1</td>
</tr>
<tr>
<td align="left">9 12 10 0<br>5 9 6 0<br><span><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span><br>9 10 6 0</td>
<td align="left"><span><span class="MathJax_Preview">1_1\qquad 1_2\qquad 1_3\qquad</span><script type="math/tex">1_1\qquad 1_2\qquad 1_3\qquad</script></span> region label=0<br><span><span class="MathJax_Preview">2_1\qquad 2_2\qquad 2_3\qquad</span><script type="math/tex">2_1\qquad 2_2\qquad 2_3\qquad</script></span> region label=0<br><br><span><span class="MathJax_Preview">16_1\quad 16_2\qquad 16_3\qquad</span><script type="math/tex">16_1\quad 16_2\qquad 16_3\qquad</script></span> region label=0</td>
</tr>
<tr>
<td align="left">6 5 1<br>5 2 1<br><span><span class="MathJax_Preview">\cdots</span><script type="math/tex">\cdots</script></span><br>10 6 1</td>
<td align="left"><span><span class="MathJax_Preview">1_1\qquad 1_2\qquad</span><script type="math/tex">1_1\qquad 1_2\qquad</script></span> boundary label=1<br><span><span class="MathJax_Preview">2_1\qquad 2_2\qquad</span><script type="math/tex">2_1\qquad 2_2\qquad</script></span> boundary label=1<br><br><span><span class="MathJax_Preview">10_1\quad 10_2\qquad</span><script type="math/tex">10_1\quad 10_2\qquad</script></span> boundary label=1</td>
</tr>
</tbody>
</table>
<p></center></p>
<p>In FreeFem++ there are many mesh file formats available for communication with other tools such as <code>emc2</code>, <code>modulef</code>, ... (see <a href="MeshFormat">Mesh format chapter</a>). The extension of a file implies its format. More details can be found on the file format .msh in the article by F. Hecht "bamg : a bidimensional anisotropic mesh generator" <a href="#refHecht19982">Hecht1998</a>.</p>
<p>A mesh file can be read into FreeFem++ except that the names of the borders are lost and only their reference numbers are kept. So these borders have to be referenced by the number which corresponds to their order of appearance in the program, unless this number is overwritten by the keyword <code class="codehilite">label</code>. Here are some examples:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border floor(t=0, 1){x=t; y=0; label=1;}
border right(t=0, 1){x=1; y=t; label=5;}
border ceiling(t=1, 0){x=t; y=1; label=5;}
border left(t=1, 0){x=0; y=t; label=5;}

int n = 10;
mesh th = buildmesh(floor(n) + right(n) + ceiling(n) + left(n));
savemesh(th, &quot;toto.am_fmt&quot;); //&quot;formatted Marrocco&quot; format
savemesh(th, &quot;toto.Th&quot;); //&quot;bamg&quot;-type mesh
savemesh(th, &quot;toto.msh&quot;); //freefem format
savemesh(th, &quot;toto.nopo&quot;); //modulef format
mesh th2 = readmesh(&quot;toto.msh&quot;); //read the mesh
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Parameters
int n = 10;

// Mesh
border floor(t=0, 1){x=t; y=0; label=1;};
border right(t=0, 1){x=1; y=t; label=5;};
border ceiling(t=1, 0){x=t; y=1; label=5;};
border left(t=1, 0){x=0; y=t; label=5;};

mesh th = buildmesh(floor(n) + right(n) + ceiling(n) + left(n));

//save mesh in different formats
savemesh(th, &quot;toto.am_fmt&quot;); // format &quot;formated Marrocco&quot;
savemesh(th, &quot;toto.Th&quot;); // format database db mesh &quot;bamg&quot;
savemesh(th, &quot;toto.msh&quot;); // format freefem
savemesh(th, &quot;toto.nopo&quot;); // modulef format

// Fespace
fespace femp1(th, P1);
femp1 f = sin(x)*cos(y);
femp1 g;

//save the fespace function in a file
{
    ofstream file(&quot;f.txt&quot;);
    file &lt;&lt; f[] &lt;&lt; endl;
} //the file is automatically closed at the end of the block
//read a file and put it in a fespace function
{
    ifstream file(&quot;f.txt&quot;);
    file &gt;&gt; g[] ;
}//the file is equally automatically closed

// Plot
plot(g);

// Mesh 2
//read the mesh for freefem format saved mesh
mesh th2 = readmesh(&quot;toto.msh&quot;);

// Fespace 2
fespace Vh2(th2, P1);
Vh2 u, v;

// Problem
//solve:
//  $u + \Delta u = g$ in $\Omega $
//  $u=0$ on $\Gamma_1$
//  $\frac{\p u }{\p n} = g$ on $\Gamma_2$
solve Problem(u, v)
    = int2d(th2)(
          u*v
        - dx(u)*dx(v)
        - dy(u)*dy(v)
    )
    + int2d(th2)(
        - g*v
    )
    + int1d(th2, 5)(
          g*v
    )
    + on(1, u=0)
    ;

// Plot
plot(th2, u);
</pre></div>
</td></tr></table>

<h3 id="mesh-connectivity-and-data">Mesh Connectivity and data<a class="headerlink" href="#mesh-connectivity-and-data" title="Permanent link">#</a></h3>
<p>The following example explains methods to obtain mesh information.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Mesh
mesh Th = square(2, 2);

cout &lt;&lt; &quot;// Get data of the mesh&quot; &lt;&lt; endl;
{
    int NbTriangles = Th.nt;
    real MeshArea = Th.measure;
    real BorderLenght = Th.bordermeasure;

    cout &lt;&lt; &quot;Number of triangle(s) = &quot; &lt;&lt; NbTriangles &lt;&lt; endl;
    cout &lt;&lt; &quot;Mesh area = &quot; &lt;&lt; MeshArea &lt;&lt; endl;
    cout &lt;&lt; &quot;Border length = &quot; &lt;&lt; BorderLenght &lt;&lt; endl;

    // Th(i) return the vextex i of Th
    // Th[k] return the triangle k of Th
    // Th[k][i] return the vertex i of the triangle k of Th
    for (int i = 0; i &lt; NbTriangles; i++)
        for (int j = 0; j &lt; 3; j++)
            cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; - Th[i][j] = &quot; &lt;&lt; Th[i][j]
                 &lt;&lt; &quot;, x = &quot; &lt;&lt; Th[i][j].x
                 &lt;&lt; &quot;, y= &quot; &lt;&lt; Th[i][j].y
                 &lt;&lt; &quot;, label=&quot; &lt;&lt; Th[i][j].label &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Hack to get vertex coordinates&quot; &lt;&lt; endl;
{
    fespace femp1(Th, P1);
    femp1 Thx=x,Thy=y;

    int NbVertices = Th.nv;
    cout &lt;&lt; &quot;Number of vertices = &quot; &lt;&lt; NbVertices &lt;&lt; endl;

    for (int i = 0; i &lt; NbVertices; i++)
        cout &lt;&lt; &quot;Th(&quot; &lt;&lt; i &lt;&lt; &quot;) : &quot; &lt;&lt; Th(i).x &lt;&lt; &quot; &quot; &lt;&lt; Th(i).y &lt;&lt; &quot; &quot; &lt;&lt; Th(i).label
             &lt;&lt; endl &lt;&lt; &quot;\told method: &quot; &lt;&lt; Thx[][i] &lt;&lt; &quot; &quot; &lt;&lt; Thy[][i] &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Method to find information of point (0.55,0.6)&quot; &lt;&lt; endl;
{
    int TNumber = Th(0.55, 0.6).nuTriangle; //the triangle number
    int RLabel = Th(0.55, 0.6).region; //the region label

    cout &lt;&lt; &quot;Triangle number in point (0.55, 0.6): &quot; &lt;&lt; TNumber &lt;&lt; endl;
    cout &lt;&lt; &quot;Region label in point (0.55, 0.6): &quot; &lt;&lt; RLabel &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Information of triangle&quot; &lt;&lt; endl;
{
    int TNumber = Th(0.55, 0.6).nuTriangle;
    real TArea = Th[TNumber].area; //triangle area
    real TRegion = Th[TNumber].region; //triangle region
    real TLabel = Th[TNumber].label; //triangle label, same as region for triangles

    cout &lt;&lt; &quot;Area of triangle &quot; &lt;&lt; TNumber &lt;&lt; &quot;: &quot; &lt;&lt; TArea &lt;&lt; endl;
    cout &lt;&lt; &quot;Region of triangle &quot; &lt;&lt; TNumber &lt;&lt; &quot;: &quot; &lt;&lt; TRegion &lt;&lt; endl;
    cout &lt;&lt; &quot;Label of triangle &quot; &lt;&lt; TNumber &lt;&lt; &quot;: &quot; &lt;&lt; TLabel &lt;&lt; endl;
}

cout &lt;&lt; &quot;// Hack to get a triangle containing point x, y or region number (old method)&quot; &lt;&lt; endl;
{
    fespace femp0(Th, P0);
    femp0 TNumbers; //a P0 function to get triangle numbering
    for (int i = 0; i &lt; Th.nt; i++)
        TNumbers[][i] = i;
    femp0 RNumbers = region; //a P0 function to get the region number

    int TNumber = TNumbers(0.55, 0.6); // Number of the triangle containing (0.55, 0,6)
    int RNumber = RNumbers(0.55, 0.6); // Number of the region containing (0.55, 0,6)

    cout &lt;&lt; &quot;Point (0.55,0,6) :&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;\tTriangle number = &quot; &lt;&lt; TNumber &lt;&lt; endl;
    cout &lt;&lt; &quot;\tRegion number = &quot; &lt;&lt; RNumber &lt;&lt; endl;
}

cout &lt;&lt; &quot;// New method to get boundary information and mesh adjacent&quot; &lt;&lt; endl;
{
    int k = 0;
    int l=1;
    int e=1;

    // Number of boundary elements
    int NbBoundaryElements = Th.nbe;
    cout &lt;&lt; &quot;Number of boundary element = &quot; &lt;&lt; NbBoundaryElements &lt;&lt; endl;
    // Boundary element k in {0, ..., Th.nbe}
    int BoundaryElement = Th.be(k);
    cout &lt;&lt; &quot;Boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; BoundaryElement &lt;&lt; endl;
    // Vertice l in {0, 1} of boundary element k
    int Vertex = Th.be(k)[l];
    cout &lt;&lt; &quot;Vertex &quot; &lt;&lt; l &lt;&lt; &quot; of boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; Vertex &lt;&lt; endl;
    // Triangle containg the boundary element k
    int Triangle = Th.be(k).Element;
    cout &lt;&lt; &quot;Triangle containing the boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; Triangle &lt;&lt; endl;
    // Triangle egde nubmer containing the boundary element k
    int Edge = Th.be(k).whoinElement;
    cout &lt;&lt; &quot;Triangle edge number containing the boundary element &quot; &lt;&lt; k &lt;&lt; &quot; = &quot; &lt;&lt; Edge &lt;&lt; endl;
    // Adjacent triangle of the triangle k by edge e
    int Adjacent = Th[k].adj(e); //The value of e is changed to the corresponding edge in the adjacent triangle
    cout &lt;&lt; &quot;Adjacent triangle of the triangle &quot; &lt;&lt; k &lt;&lt; &quot; by edge &quot; &lt;&lt; e &lt;&lt; &quot; = &quot; &lt;&lt; Adjacent &lt;&lt; endl;
    cout &lt;&lt; &quot;\tCorresponding edge = &quot; &lt;&lt; e &lt;&lt; endl;
    // If there is no adjacent triangle by edge e, the same triangle is returned
    //Th[k] == Th[k].adj(e)
    // Else a different triangle is returned
    //Th[k] != Th[k].adj(e)
}

cout &lt;&lt; &quot;// Print mesh connectivity &quot; &lt;&lt; endl;
{
    int NbTriangles = Th.nt;
    for (int k = 0; k &lt; NbTriangles; k++)
        cout &lt;&lt; k &lt;&lt; &quot; : &quot; &lt;&lt; int(Th[k][0]) &lt;&lt; &quot; &quot; &lt;&lt; int(Th[k][1])
             &lt;&lt; &quot; &quot; &lt;&lt; int(Th[k][2])
             &lt;&lt; &quot;, label &quot; &lt;&lt; Th[k].label &lt;&lt; endl;

    for (int k = 0; k &lt; NbTriangles; k++)
        for (int e = 0, ee; e &lt; 3; e++)
            //set ee to e, and ee is change by method adj,
            cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; e &lt;&lt; &quot; &lt;=&gt; &quot; &lt;&lt; int(Th[k].adj((ee=e))) &lt;&lt; &quot; &quot; &lt;&lt; ee
                 &lt;&lt; &quot;, adj: &quot; &lt;&lt; (Th[k].adj((ee=e)) != Th[k]) &lt;&lt; endl;

    int NbBoundaryElements = Th.nbe;
    for (int k = 0; k &lt; NbBoundaryElements; k++)
        cout &lt;&lt; k &lt;&lt; &quot; : &quot; &lt;&lt; Th.be(k)[0] &lt;&lt; &quot; &quot; &lt;&lt; Th.be(k)[1]
             &lt;&lt; &quot; , label &quot; &lt;&lt; Th.be(k).label
             &lt;&lt; &quot;, triangle &quot; &lt;&lt; int(Th.be(k).Element)
             &lt;&lt; &quot; &quot; &lt;&lt; Th.be(k).whoinElement &lt;&lt; endl;

    real[int] bb(4);
    boundingbox(Th, bb);
    // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax
    cout &lt;&lt; &quot;boundingbox:&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;xmin = &quot; &lt;&lt; bb[0]
         &lt;&lt; &quot;, xmax = &quot; &lt;&lt; bb[1]
         &lt;&lt; &quot;, ymin = &quot; &lt;&lt; bb[2]
         &lt;&lt; &quot;, ymax = &quot; &lt;&lt; bb[3] &lt;&lt; endl;
}
</pre></div>
</td></tr></table>

<p>The output is:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Get data of the mesh
Number of <span class="nv">triangle</span> <span class="o">=</span> <span class="m">8</span>
Mesh <span class="nv">area</span> <span class="o">=</span> <span class="m">1</span>
Border <span class="nv">length</span> <span class="o">=</span> <span class="m">4</span>
<span class="m">0</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">0</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">1</span>
<span class="m">0</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">1</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">1</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">1</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">3</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">2</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">1</span>
<span class="m">2</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">2</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">2</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">5</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">3</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>, <span class="nv">label</span><span class="o">=</span><span class="m">1</span>
<span class="m">3</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">5</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">3</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">4</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">3</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">4</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">4</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">7</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">5</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">3</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">5</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">7</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">5</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">6</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">4</span>
<span class="m">6</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">6</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">5</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">2</span>
<span class="m">6</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">8</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">7</span> <span class="m">0</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">4</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">0</span>.5, <span class="nv">label</span><span class="o">=</span><span class="m">0</span>
<span class="m">7</span> <span class="m">1</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">8</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
<span class="m">7</span> <span class="m">2</span> - Th<span class="o">[</span>i<span class="o">][</span>j<span class="o">]</span> <span class="o">=</span> <span class="m">7</span>, <span class="nv">x</span> <span class="o">=</span> <span class="m">0</span>.5, <span class="nv">y</span><span class="o">=</span> <span class="m">1</span>, <span class="nv">label</span><span class="o">=</span><span class="m">3</span>
// Hack to get vertex coordinates
Number of <span class="nv">vertices</span> <span class="o">=</span> <span class="m">9</span>
Th<span class="o">(</span><span class="m">0</span><span class="o">)</span> : <span class="m">0</span> <span class="m">0</span> <span class="m">4</span>
   old method: <span class="m">0</span> <span class="m">0</span>
Th<span class="o">(</span><span class="m">1</span><span class="o">)</span> : <span class="m">0</span>.5 <span class="m">0</span> <span class="m">1</span>
   old method: <span class="m">0</span>.5 <span class="m">0</span>
Th<span class="o">(</span><span class="m">2</span><span class="o">)</span> : <span class="m">1</span> <span class="m">0</span> <span class="m">2</span>
   old method: <span class="m">1</span> <span class="m">0</span>
Th<span class="o">(</span><span class="m">3</span><span class="o">)</span> : <span class="m">0</span> <span class="m">0</span>.5 <span class="m">4</span>
   old method: <span class="m">0</span> <span class="m">0</span>.5
Th<span class="o">(</span><span class="m">4</span><span class="o">)</span> : <span class="m">0</span>.5 <span class="m">0</span>.5 <span class="m">0</span>
   old method: <span class="m">0</span>.5 <span class="m">0</span>.5
Th<span class="o">(</span><span class="m">5</span><span class="o">)</span> : <span class="m">1</span> <span class="m">0</span>.5 <span class="m">2</span>
   old method: <span class="m">1</span> <span class="m">0</span>.5
Th<span class="o">(</span><span class="m">6</span><span class="o">)</span> : <span class="m">0</span> <span class="m">1</span> <span class="m">4</span>
   old method: <span class="m">0</span> <span class="m">1</span>
Th<span class="o">(</span><span class="m">7</span><span class="o">)</span> : <span class="m">0</span>.5 <span class="m">1</span> <span class="m">3</span>
   old method: <span class="m">0</span>.5 <span class="m">1</span>
Th<span class="o">(</span><span class="m">8</span><span class="o">)</span> : <span class="m">1</span> <span class="m">1</span> <span class="m">3</span>
   old method: <span class="m">1</span> <span class="m">1</span>
// Method to find the information of point <span class="o">(</span><span class="m">0</span>.55,0.6<span class="o">)</span>
Triangle number in point <span class="o">(</span><span class="m">0</span>.55, <span class="m">0</span>.6<span class="o">)</span>: <span class="m">7</span>
Region label in point <span class="o">(</span><span class="m">0</span>.55, <span class="m">0</span>.6<span class="o">)</span>: <span class="m">0</span>
// Information of a triangle
Area of triangle <span class="m">7</span>: <span class="m">0</span>.125
Region of triangle <span class="m">7</span>: <span class="m">0</span>
Label of triangle <span class="m">7</span>: <span class="m">0</span>
// Hack to get a triangle containing point x, y or region number <span class="o">(</span>old method<span class="o">)</span>
Point <span class="o">(</span><span class="m">0</span>.55,0,6<span class="o">)</span> :
   Triangle <span class="nv">number</span> <span class="o">=</span> <span class="m">7</span>
   Region <span class="nv">number</span> <span class="o">=</span> <span class="m">0</span>
// New method to get boundary information and mesh adjacent
Number of boundary <span class="nv">element</span> <span class="o">=</span> <span class="m">8</span>
Boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">0</span>
Vertex <span class="m">1</span> of boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">1</span>
Triangle containing the boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">0</span>
Triangle edge number containing the boundary element <span class="nv">0</span> <span class="o">=</span> <span class="m">2</span>
Adjacent triangle of the triangle <span class="m">0</span> by edge <span class="nv">1</span> <span class="o">=</span> <span class="m">1</span>
   Corresponding <span class="nv">edge</span> <span class="o">=</span> <span class="m">2</span>
// Print mesh connectivity
<span class="m">0</span> : <span class="m">0</span> <span class="m">1</span> <span class="m">4</span>, label <span class="m">0</span>
<span class="m">1</span> : <span class="m">0</span> <span class="m">4</span> <span class="m">3</span>, label <span class="m">0</span>
<span class="m">2</span> : <span class="m">1</span> <span class="m">2</span> <span class="m">5</span>, label <span class="m">0</span>
<span class="m">3</span> : <span class="m">1</span> <span class="m">5</span> <span class="m">4</span>, label <span class="m">0</span>
<span class="m">4</span> : <span class="m">3</span> <span class="m">4</span> <span class="m">7</span>, label <span class="m">0</span>
<span class="m">5</span> : <span class="m">3</span> <span class="m">7</span> <span class="m">6</span>, label <span class="m">0</span>
<span class="m">6</span> : <span class="m">4</span> <span class="m">5</span> <span class="m">8</span>, label <span class="m">0</span>
<span class="m">7</span> : <span class="m">4</span> <span class="m">8</span> <span class="m">7</span>, label <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">3</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">0</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">1</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">0</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">0</span> <span class="m">2</span>, adj: <span class="m">0</span>
<span class="m">1</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">4</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">1</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">1</span> <span class="m">1</span>, adj: <span class="m">0</span>
<span class="m">1</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">0</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">2</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">2</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">2</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">3</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">2</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">2</span> <span class="m">2</span>, adj: <span class="m">0</span>
<span class="m">3</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">6</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">3</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">0</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">3</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">2</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">4</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">7</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">4</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">5</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">4</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">1</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">5</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">5</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">5</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">5</span> <span class="m">1</span>, adj: <span class="m">0</span>
<span class="m">5</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">4</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">6</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">6</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">6</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">7</span> <span class="m">2</span>, adj: <span class="m">1</span>
<span class="m">6</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">3</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">7</span> <span class="m">0</span> &lt;<span class="o">=</span>&gt; <span class="m">7</span> <span class="m">0</span>, adj: <span class="m">0</span>
<span class="m">7</span> <span class="m">1</span> &lt;<span class="o">=</span>&gt; <span class="m">4</span> <span class="m">0</span>, adj: <span class="m">1</span>
<span class="m">7</span> <span class="m">2</span> &lt;<span class="o">=</span>&gt; <span class="m">6</span> <span class="m">1</span>, adj: <span class="m">1</span>
<span class="m">0</span> : <span class="m">0</span> <span class="m">1</span> , label <span class="m">1</span>, triangle <span class="m">0</span> <span class="m">2</span>
<span class="m">1</span> : <span class="m">1</span> <span class="m">2</span> , label <span class="m">1</span>, triangle <span class="m">2</span> <span class="m">2</span>
<span class="m">2</span> : <span class="m">2</span> <span class="m">5</span> , label <span class="m">2</span>, triangle <span class="m">2</span> <span class="m">0</span>
<span class="m">3</span> : <span class="m">5</span> <span class="m">8</span> , label <span class="m">2</span>, triangle <span class="m">6</span> <span class="m">0</span>
<span class="m">4</span> : <span class="m">6</span> <span class="m">7</span> , label <span class="m">3</span>, triangle <span class="m">5</span> <span class="m">0</span>
<span class="m">5</span> : <span class="m">7</span> <span class="m">8</span> , label <span class="m">3</span>, triangle <span class="m">7</span> <span class="m">0</span>
<span class="m">6</span> : <span class="m">0</span> <span class="m">3</span> , label <span class="m">4</span>, triangle <span class="m">1</span> <span class="m">1</span>
<span class="m">7</span> : <span class="m">3</span> <span class="m">6</span> , label <span class="m">4</span>, triangle <span class="m">5</span> <span class="m">1</span>
boundingbox:
<span class="nv">xmin</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">xmax</span> <span class="o">=</span> <span class="m">1</span>, <span class="nv">ymin</span> <span class="o">=</span> <span class="m">0</span>, <span class="nv">ymax</span> <span class="o">=</span> <span class="m">1</span>
</pre></div>
</td></tr></table>

<p>The real characteristic function of a mesh <code class="codehilite">Th</code> is <code class="codehilite">chi(Th)</code> in 2D and 3D where:</p>
<p><code class="codehilite">chi(Th)(P)=1</code> if <span><span class="MathJax_Preview">P\in Th</span><script type="math/tex">P\in Th</script></span></p>
<p><code class="codehilite">chi(Th)(P)=0</code> if <span><span class="MathJax_Preview">P\not\in Th</span><script type="math/tex">P\not\in Th</script></span></p>
<h3 id="the-keyword-triangulate">The keyword "triangulate"<a class="headerlink" href="#the-keyword-triangulate" title="Permanent link">#</a></h3>
<p>FreeFem++ is able to build a triangulation from a set of points. This triangulation is a Delaunay mesh of the convex hull of the set of points. It can be useful to build a mesh from a table function.</p>
<p>The coordinates of the points and the value of the table function are defined separately with rows of the form: <code class="codehilite">x y f(x,y)</code> in a file such as:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>0.51387 0.175741 0.636237
0.308652 0.534534 0.746765
0.947628 0.171736 0.899823
0.702231 0.226431 0.800819
0.494773 0.12472 0.580623
0.0838988 0.389647 0.456045
...............
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="center"><a name="Fig8">Fig. 8</a>: Delaunay mesh of the convex hull of point set in file xy</th>
<th align="center"><a name="Fig9">Fig. 9</a>: Isovalue of table function</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Th xy" src="../images/MeshGeneration_Triangulate1.png" /></td>
<td align="center"><img alt="xyf" src="../images/MeshGeneration_Triangulate2.png" /></td>
</tr>
</tbody>
</table>
<p>The third column of each line is left untouched by the <code class="codehilite">triangulate</code> command. But you can use this third value to define a table function with rows of the form: <code class="codehilite">x y f(x,y)</code>.</p>
<p>The following example shows how to make a mesh from the file <code>xyf</code> with the format stated just above. The command <code class="codehilite">triangulate</code> only uses the 1st and 2nd columns.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Build the Delaunay mesh of the convex hull
mesh Thxy=triangulate(&quot;xyf&quot;); //points are defined by the first 2 columns of file `xyf`

// Plot the created mesh
plot(Thxy);

// Fespace
fespace Vhxy(Thxy, P1);
Vhxy fxy;

// Reading the 3rd column to define the function fxy
{
    ifstream file(&quot;xyf&quot;);
    real xx, yy;
    for(int i = 0; i &lt; fxy.n; i++)
        file &gt;&gt; xx &gt;&gt; yy &gt;&gt; fxy[][i]; //to read third row only.
                                      //xx and yy are just skipped
}

// Plot
plot(fxy);
</pre></div>
</td></tr></table>

<p>One new way to build a mesh is to have two arrays: one for the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> values and the other for the <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> values.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>//set two arrays for the x&#39;s and y&#39;s
Vhxy xx=x, yy=y;
//build the mesh
mesh Th = triangulate(xx[], yy[]);
</pre></div>
</td></tr></table>

<h2 id="boundary-fem-spaces-built-as-empty-meshes">Boundary FEM Spaces Built as Empty Meshes<a class="headerlink" href="#boundary-fem-spaces-built-as-empty-meshes" title="Permanent link">#</a></h2>
<p>To define a Finite Element space on a boundary, we came up with the idea of a mesh with no internal points (called empty mesh). It can be useful to handle Lagrange multipliers in mixed and mortar methods.</p>
<p>So the function <code class="codehilite">emptymesh</code> removes all the internal points of a mesh except points on internal boundaries.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>{
    border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
    mesh Th = buildmesh(a(20));
    Th = emptymesh(Th);
    plot(Th);
}
</pre></div>
</td></tr></table>

<p>It is also possible to build an empty mesh of a pseudo subregion with <code class="codehilite">emptymesh(Th, ssd)</code> using the set of edges from the mesh <code class="codehilite">Th</code>; an edge <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> is in this set when, with the two adjacent triangles <span><span class="MathJax_Preview">e =t1\cap t2</span><script type="math/tex">e =t1\cap t2</script></span> and <span><span class="MathJax_Preview">ssd[T1] \neq ssd[T2]</span><script type="math/tex">ssd[T1] \neq ssd[T2]</script></span> where <span><span class="MathJax_Preview">ssd</span><script type="math/tex">ssd</script></span> refers to the pseudo region numbering of triangles, they are stored in the <code class="codehilite">int[int]</code> array of size "the number of triangles".</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>{
    mesh Th = square(10, 10);
    int[int] ssd(Th.nt);
    //build the pseudo region numbering
    for(int i = 0; i &lt; ssd.n; i++){
        int iq = i/2; //because 2 triangles per quad
        int ix = iq%10;
        int iy = iq/10;
        ssd[i] = 1 + (ix&gt;=5) + (iy&gt;=5)*2;
    }
    //build emtpy with all edges $e=T1 \cap T2$ and $ssd[T1] \neq ssd[T2]$
    Th = emptymesh(Th, ssd);
    //plot
    plot(Th);
    savemesh(Th, &quot;emptymesh.msh&quot;);
}
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="center"><a name="Fig10">Fig. 10</a>: The empty mesh with boundary</th>
<th align="center"><a name="Fig11">Fig. 11</a>: An empty mesh defined from a pseudo region numbering of triangle</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Empty mesh 1" src="../images/MeshGeneration_EmptyMesh1.png" /></td>
<td align="center"><img alt="Empty mesh 2" src="../images/MeshGeneration_EmptyMesh2.png" /></td>
</tr>
</tbody>
</table>
<h2 id="remeshing">Remeshing<a class="headerlink" href="#remeshing" title="Permanent link">#</a></h2>
<h3 id="movemesh">Movemesh<a class="headerlink" href="#movemesh" title="Permanent link">#</a></h3>
<p>Meshes can be translated, rotated, and deformed by <code class="codehilite">movemesh</code>; this is useful for elasticity to watch the deformation due to the displacement <span><span class="MathJax_Preview">\mathbf{\Phi}(x,y)=(\Phi_1(x,y),\Phi_2(x,y))</span><script type="math/tex">\mathbf{\Phi}(x,y)=(\Phi_1(x,y),\Phi_2(x,y))</script></span> of shape.</p>
<p>It is also useful to handle free boundary problems or optimal shape problems.</p>
<p>If <span><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> is triangulated as <span><span class="MathJax_Preview">T_h(\Omega)</span><script type="math/tex">T_h(\Omega)</script></span>, and <span><span class="MathJax_Preview">\mathbf{\Phi}</span><script type="math/tex">\mathbf{\Phi}</script></span> is a displacement vector then <span><span class="MathJax_Preview">\mathbf{\Phi}(T_h)</span><script type="math/tex">\mathbf{\Phi}(T_h)</script></span> is obtained by</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh Th = movemesh(Th,[Phi1, Phi2]);
</pre></div>
</td></tr></table>

<p>Sometimes the transformed mesh is invalid because some triangles have flipped over (meaning it now has a negative area). To spot such problems, one may check the minimum triangle area in the transformed mesh with <code class="codehilite">checkmovemesh</code> before any real transformation.</p>
<p>For example:
<script type="math/tex; mode=display">\begin{eqnarray}
    \Phi_1(x,y) &=& x+k*\sin(y*\pi)/10)\\
    \Phi_2(x,y) &=& y+k*\cos(y\pi)/10)
\end{eqnarray}</script>
for a big number <span><span class="MathJax_Preview">k&gt;1</span><script type="math/tex">k>1</script></span>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>verbosity = 4;

// Parameters
real coef = 1;

// Mesh
border a(t=0, 1){x=t; y=0; label=1;};
border b(t=0, 0.5){x=1; y=t; label=1;};
border c(t=0, 0.5){x=1-t; y=0.5; label=1;};
border d(t=0.5, 1){x=0.5; y=t; label=1;};
border e(t=0.5, 1){x=1-t; y=1; label=1;};
border f(t=0, 1){x=0; y=1-t; label=1;};
mesh Th = buildmesh(a(6) + b(4) + c(4) + d(4) + e(4) + f(6));
plot(Th, wait=true, fill=true, ps=&quot;Lshape.eps&quot;);

// Function
func uu = sin(y*pi)/10;
func vv = cos(x*pi)/10;

// Checkmovemesh
real minT0 = checkmovemesh(Th, [x, y]); //return the min triangle area
while(1){ // find a correct move mesh
    real minT = checkmovemesh(Th, [x+coef*uu, y+coef*vv]);
    if (minT &gt; minT0/5) break; //if big enough
    coef /= 1.5;
}

// Movemesh
Th = movemesh(Th, [x+coef*uu, y+coef*vv]);
plot(Th, wait=true, fill=true, ps=&quot;MovedMesh.eps&quot;);
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="center"><a name="Fig12">Fig. 12</a>: L-shape</th>
<th align="center"><a name=Fig13">Fig. 13</a>: moved L-shape</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="L-shape" src="../images/MeshGeneration_MoveMesh1.png" /></td>
<td align="center"><img alt="moved L shaped" src="../images/MeshGeneration_MoveMesh2.png" /></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider a function <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> defined on a mesh <code class="codehilite">Th</code>. A statement like <code class="codehilite">Th=movemesh(Th...)</code> does not change <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> and so the old mesh still exists. It will be destroyed when no function uses it. A statement like <span><span class="MathJax_Preview">u=u</span><script type="math/tex">u=u</script></span> redefines <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> on the new mesh <code class="codehilite">Th</code> with interpolation and therefore destroys the old <code class="codehilite">Th</code>, if <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> was the only function using it.</p>
</div>
<p>Now, we give an example of moving a mesh with a Lagrangian function <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> defined on the moving mesh.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Parameters
int nn = 10;
real dt = 0.1;

// Mesh
mesh Th = square(nn, nn);

// Fespace
fespace Vh(Th, P1);
Vh u=y;

// Loop
real t=0;
for (int i = 0; i &lt; 4; i++){
    t = i*dt;
    Vh f=x*t;
    real minarea = checkmovemesh(Th, [x, y+f]);
    if (minarea &gt; 0) //movemesh will be ok
    Th = movemesh(Th, [x, y+f]);

    cout &lt;&lt; &quot; Min area = &quot; &lt;&lt; minarea &lt;&lt; endl;

    real[int] tmp(u[].n);
    tmp = u[]; //save the value
    u = 0;//to change the FEspace and mesh associated with u
    u[] = tmp;//set the value of u without any mesh update
    plot(Th, u, wait=true);
}
// In this program, since u is only defined on the last mesh, all the
// previous meshes are deleted from memory.
</pre></div>
</td></tr></table>

<h2 id="regular-triangulation-htriangle">Regular Triangulation: <code class="codehilite">hTriangle</code><a class="headerlink" href="#regular-triangulation-htriangle" title="Permanent link">#</a></h2>
<p>For a set <span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>, we define the diameter of <span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span> by</p>
<div>
<div class="MathJax_Preview">
\textrm{diam}(S)=\sup\{|\mathbf{x}-\mathbf{y}|; \; \mathbf{x},\, \mathbf{y}\in S\}
</div>
<script type="math/tex; mode=display">
\textrm{diam}(S)=\sup\{|\mathbf{x}-\mathbf{y}|; \; \mathbf{x},\, \mathbf{y}\in S\}
</script>
</div>
<p>The sequence <span><span class="MathJax_Preview">\{\mathcal{T}_h\}_{h\rightarrow 0}</span><script type="math/tex">\{\mathcal{T}_h\}_{h\rightarrow 0}</script></span> of <span><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> is called <em>regular</em> if they satisfy the following:</p>
<ol>
<li>
<p><span><span class="MathJax_Preview">\lim_{h\rightarrow 0}\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}=0</span><script type="math/tex">\lim_{h\rightarrow 0}\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}=0</script></span></p>
</li>
<li>
<p>There is a number <span><span class="MathJax_Preview">\sigma&gt;0</span><script type="math/tex">\sigma>0</script></span> independent of <span><span class="MathJax_Preview">h</span><script type="math/tex">h</script></span> such that
    <span><span class="MathJax_Preview">\frac{\rho(T_k)}{\textrm{diam}(T_k)}\ge \sigma\qquad \textrm{for all }T_k\in \mathcal{T}_h</span><script type="math/tex">\frac{\rho(T_k)}{\textrm{diam}(T_k)}\ge \sigma\qquad \textrm{for all }T_k\in \mathcal{T}_h</script></span>
    where <span><span class="MathJax_Preview">\rho(T_k)</span><script type="math/tex">\rho(T_k)</script></span> are the diameter of the inscribed circle of <span><span class="MathJax_Preview">T_k</span><script type="math/tex">T_k</script></span>.</p>
</li>
</ol>
<p>We put <span><span class="MathJax_Preview">h(\mathcal{T}_h)=\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}</span><script type="math/tex">h(\mathcal{T}_h)=\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}</script></span>,
which is obtained by</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh Th = ......;
fespace Ph(Th, P0);
Ph h = hTriangle;
cout &lt;&lt; &quot;size of mesh = &quot; &lt;&lt; h[].max &lt;&lt; endl;
</pre></div>
</td></tr></table>

<h2 id="adaptmesh">Adaptmesh<a class="headerlink" href="#adaptmesh" title="Permanent link">#</a></h2>
<p>The function
<script type="math/tex; mode=display">
f(x,y) = 10.0x^3+y^3+\tan^{-1}[\varepsilon/(\sin(5.0y)-2.0x)],\ \varepsilon = 0.0001
</script>
sharply varies in value and the initial mesh given by one of the commands in the <a href="##commands-for-mesh-generation">Mesh Generation section</a> cannot reflect its sharp variations.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Parameters
real eps = 0.0001;
real h = 1;
real hmin = 0.05;
func f = 10.0*x^3 + y^3 + h*atan2(eps, sin(5.0*y)-2.0*x);

// Mesh
mesh Th = square(5, 5, [-1+2*x, -1+2*y]);

// Fespace
fespace Vh(Th,P1);
Vh fh = f;
plot(fh);

// Adaptmesh
for (int i = 0; i &lt; 2; i++){
    Th = adaptmesh(Th, fh);
    fh = f; //old mesh is deleted
    plot(Th, fh, wait=true);
}
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="left"><a name="Fig14">Fig. 14</a>: 3D graphs for the initial mesh and 1st and 2nd mesh adaptations</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="Mesh adaptation" src="../images/MeshGeneration_AdaptMesh1.png" /></td>
</tr>
</tbody>
</table>
<p>FreeFem++ uses a variable metric/Delaunay automatic meshing algorithm.</p>
<p>The command:</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh ATh = adaptmesh(Th, f);
</pre></div>
</td></tr></table>
create the new mesh <code class="codehilite">ATh</code> adapted to the Hessian</p>
<div>
<div class="MathJax_Preview">
D^2f=(\p^2 f/\p x^2,\, \p^2 f/\p x\p y, \p^2 f/\p y^2)
</div>
<script type="math/tex; mode=display">
D^2f=(\p^2 f/\p x^2,\, \p^2 f/\p x\p y, \p^2 f/\p y^2)
</script>
</div>
<p>of a function (formula or FE-function).</p>
<p>Mesh adaptation is a very powerful tool when the solution of a problem varies locally and sharply.</p>
<p>Here we solve the <a href="../tutorials/">Poisson's problem</a>, when <span><span class="MathJax_Preview">f=1</span><script type="math/tex">f=1</script></span> and <span><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> is a L-shape domain.</p>
<table>
<thead>
<tr>
<th align="left"><a name="Fig15">Fig. 15</a>: L-shape domain and its boundary name</th>
<th align="left"><a name="Fig16">Fig. 16</a>: Final solution after 4-times adaptation</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="L-shape2" src="../images/MeshGeneration_AdaptMesh2.png" /></td>
<td align="left"><img alt="L Shape solution" src="../images/MeshGeneration_AdaptMesh3.png" /></td>
</tr>
</tbody>
</table>
<div class="admonition example">
<p class="admonition-title">Example</p>
<p>The solution has the singularity <span><span class="MathJax_Preview">r^{3/2},\, r=|x-\gamma|</span><script type="math/tex">r^{3/2},\, r=|x-\gamma|</script></span> at the point <span><span class="MathJax_Preview">\gamma</span><script type="math/tex">\gamma</script></span> of the intersection of two lines <span><span class="MathJax_Preview">bc</span><script type="math/tex">bc</script></span> and <span><span class="MathJax_Preview">bd</span><script type="math/tex">bd</script></span> (see <a href="#Fig15">Fig. 15</a>).</p>
</div>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Parameters
real error = 0.1;

// Mesh
border ba(t=0, 1){x=t; y=0; label=1;}
border bb(t=0, 0.5){x=1; y=t; label=1;}
border bc(t=0, 0.5){x=1-t; y=0.5; label=1;}
border bd(t=0.5, 1){x=0.5; y=t; label=1;}
border be(t=0.5, 1){x=1-t; y=1; label=1;}
border bf(t=0, 1){x=0; y=1-t; label=1;}
mesh Th = buildmesh(ba(6) + bb(4) + bc(4) + bd(4) + be(4) + bf(6));

// Fespace
fespace Vh(Th, P1);
Vh u, v;

// Function
func f = 1;

// Problem
problem Poisson(u, v, solver=CG, eps=1.e-6)
    = int2d(Th)(
          dx(u)*dx(v)
        + dy(u)*dy(v)
    )
    - int2d(Th)(
          f*v
    )
    + on(1, u=0);

// Adaptmesh loop
for (int i = 0; i &lt; 4; i++){
    Poisson;
    Th = adaptmesh(Th, u, err=error);
    error = error/2;
}

// Plot
plot(u);
</pre></div>
</td></tr></table>

<p>To speed up the adaptation, the default parameter <code class="codehilite">err</code> of <code class="codehilite">adaptmesh</code> is changed by hand; it specifies the required precision, so as to make the new mesh finer or coarser.</p>
<p>The problem is coercive and symmetric, so the linear system can be solved with the conjugate gradient method (parameter <code class="codehilite">solver=CG</code>) with the stopping criteria on the residual, here <code class="codehilite">eps=1.e-6</code>).</p>
<p>By <code class="codehilite">adaptmesh</code>, the slope of the final solution is correctly computed near
the point of intersection of <span><span class="MathJax_Preview">bc</span><script type="math/tex">bc</script></span> and <span><span class="MathJax_Preview">bd</span><script type="math/tex">bd</script></span> as in <a href="Fig16">Fig. 16</a>.</p>
<p>This method is described in detail in <a href="#refHecht1998">Hecht1998</a>. It has a number of default parameters which can be modified.</p>
<p>If <code class="codehilite">f1,f2</code> are functions and <code class="codehilite">thold, Thnew</code> are meshes:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    Thnew = adaptmesh(Thold, f1 ... );
    Thnew = adaptmesh(Thold, f1,f2 ... ]);
    Thnew = adaptmesh(Thold, [f1,f2] ... );
</pre></div>
</td></tr></table>

<p>The additional parameters of <code class="codehilite">adaptmesh</code> are:</p>
<p>See <a href="../reference/Functions/#adaptmesh">Reference part</a> for more inforamtions</p>
<ul>
<li>
<p><code class="codehilite">hmin=</code> Minimum edge size. Its default is related to the size of the domain to be meshed and the precision of the mesh generator.</p>
</li>
<li>
<p><code class="codehilite">hmax=</code> Maximum edge size. It defaults to the diameter of the domain to be meshed.</p>
</li>
<li>
<p><code class="codehilite">err=</code> <span><span class="MathJax_Preview">P_1</span><script type="math/tex">P_1</script></span> interpolation error level (0.01 is the default).</p>
</li>
<li>
<p><code class="codehilite">errg=</code> Relative geometrical error. By default this error is 0.01, and in any case it must be lower than <span><span class="MathJax_Preview">1/\sqrt{2}</span><script type="math/tex">1/\sqrt{2}</script></span>. Meshes created with this option may have some edges smaller than the <code class="codehilite">-hmin</code> due to geometrical constraints.</p>
</li>
<li>
<p><code class="codehilite">nbvx=</code> Maximum number of vertices generated by the mesh generator (9000 is the default).</p>
</li>
<li>
<p><code class="codehilite">nbsmooth=</code> number of iterations of the smoothing procedure (5 is the default).</p>
</li>
<li>
<p><code class="codehilite">nbjacoby=</code> number of iterations in a smoothing procedure during the metric construction, 0 means no smoothing, 6 is the default.</p>
</li>
<li>
<p><code class="codehilite">ratio=</code> ratio for a prescribed smoothing on the metric. If the value is 0 or less than 1.1 no smoothing is done on the metric. 1.8 is the default.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note: As <code class="codehilite">ratio</code> gets closer to 1, the number of generated vertices increases. This may be useful to control the thickness of refined regions near shocks or boundary layers.</p>
</div>
</li>
<li>
<p><code class="codehilite">omega=</code> relaxation parameter for the smoothing procedure. 1.0 is the default.</p>
</li>
<li>
<p><code class="codehilite">iso=</code> If true, forces the metric to be isotropic. <code class="codehilite">false</code> is the default.</p>
</li>
<li>
<p><code class="codehilite">abserror=</code> If false, the metric is evaluated using the criteria of equi-repartion of relative error. <code class="codehilite">false</code> is the default. In this case the metric is defined by
    <script type="math/tex; mode=display">\begin{equation}
        \mathcal{M} = \left({1\over\mathtt{err}\,\, \mathtt{coef}^2} \quad {
        |\mathcal{H}| \over max(\mathtt{CutOff},|\eta|)}\right)^p
        \label{eq err rel}
    \end{equation}</script>
    Otherwise, the metric is evaluated using the criteria of equi-distribution of errors. In this case the metric is defined by
    <script type="math/tex; mode=display">\begin{equation}
        \mathcal{M} = \left({1\over \mathtt{err}\,\,\mathtt{coef}^2} \quad
        {|{\mathcal{H}|} \over
        {\sup(\eta)-\inf(\eta)}}\right)^p.\label{eq err abs}
    \end{equation}</script>
</p>
</li>
<li>
<p><code class="codehilite">cutoff=</code> lower limit for the relative error evaluation. 1.0e-6 is the default.</p>
</li>
<li>
<p><code class="codehilite">verbosity=</code> informational messages level (can be chosen between 0 and <span><span class="MathJax_Preview">\infty</span><script type="math/tex">\infty</script></span>). Also changes the value of the global variable verbosity (obsolete).</p>
</li>
<li>
<p><code class="codehilite">inquire=</code> To inquire graphically about the mesh. <code class="codehilite">false</code> is the default.</p>
</li>
<li>
<p><code class="codehilite">splitpbedge=</code> If true, splits all internal edges in half with two boundary vertices. <code class="codehilite">true</code> is the
default.</p>
</li>
<li>
<p><code class="codehilite">maxsubdiv=</code> Changes the metric such that the maximum subdivision of a background edge is bound by <code class="codehilite">val</code>. Always limited by 10, and 10 is also the default.</p>
</li>
<li>
<p><code class="codehilite">rescaling=</code> if true, the function, with respect to which the mesh is adapted, is rescaled to be between 0 and 1. <code class="codehilite">true</code> is the default.</p>
</li>
<li>
<p><code class="codehilite">keepbackvertices=</code> if true, tries to keep as many vertices from the original mesh as possible. <code class="codehilite">true</code> is the default.</p>
</li>
<li>
<p><code class="codehilite">IsMetric=</code> if true, the metric is defined explicitly. <code class="codehilite">false</code> is the default. If the 3 functions <span><span class="MathJax_Preview">m_{11}, m_{12}, m_{22}</span><script type="math/tex">m_{11}, m_{12}, m_{22}</script></span> are given, they directly define a symmetric matrix field whose Hessian is computed to define a metric. If only one function is given, then it represents the isotropic mesh size at every point.</p>
<p>For example, if the partial derivatives <code class="codehilite">fxx</code> (<span><span class="MathJax_Preview">=\p^2 f/\p x^2</span><script type="math/tex">=\p^2 f/\p x^2</script></span>), <code class="codehilite">fxy</code> (<span><span class="MathJax_Preview">=\p^2 f/\p x\p y</span><script type="math/tex">=\p^2 f/\p x\p y</script></span>), <code class="codehilite">fyy</code> (<span><span class="MathJax_Preview">=\p^2 f/\p y^2</span><script type="math/tex">=\p^2 f/\p y^2</script></span>) are given, we can set <code class="codehilite">Th = adaptmesh(Th, fxx, fxy, fyy, IsMetric=1, nbvx=10000, hmin=hmin);</code></p>
</li>
<li>
<p><code class="codehilite">power=</code> exponent power of the Hessian used to compute the metric. 1 is the default.</p>
</li>
<li>
<p><code class="codehilite">thetamax=</code> minimum corner angle in degrees. Default is <span><span class="MathJax_Preview">10^\circ</span><script type="math/tex">10^\circ</script></span> where the corner is <span><span class="MathJax_Preview">ABC</span><script type="math/tex">ABC</script></span> and the angle is the angle of the two vectors <span><span class="MathJax_Preview">{AB}, {BC}</span><script type="math/tex">{AB}, {BC}</script></span>, (<span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> imply no corner, <span><span class="MathJax_Preview">90</span><script type="math/tex">90</script></span> imply perpendicular corner, ...).</p>
</li>
<li>
<p><code class="codehilite">splitin2=</code> boolean value. If true, splits all triangles of the final mesh into 4 sub-triangles.</p>
</li>
<li>
<p><code class="codehilite">metric=</code> an array of 3 real arrays to set or get metric data information. The size of these three arrays must be the number of vertices. So if <code class="codehilite">m11,m12,m22</code> are three P1 finite elements related to the mesh to adapt, you can write: <code class="codehilite">metric=[m11[],m12[],m22[]]</code> (see file <code class="codehilite">convect-apt.edp</code> for a full example)</p>
</li>
<li>
<p><code class="codehilite">nomeshgeneration=</code> If true, no adapted mesh is generated (useful to compute only a metric).</p>
</li>
<li>
<p><code class="codehilite">periodic=</code> Writing <code class="codehilite">periodic=[[4,y],[2,y],[1,x],[3,x]];</code> builds an adapted periodic mesh. The sample builds a biperiodic mesh of a square. (see <a href="FiniteElement">periodic finite element spaces</a>, and see <a href="../examples/#sphere">the Sphere example</a> for a full example)</p>
</li>
</ul>
<p>We can use the command <code class="codehilite">adaptmesh</code> to build a uniform mesh with a constant mesh size. To build a mesh with a constant mesh size equal to <span><span class="MathJax_Preview">\frac{1}{30}</span><script type="math/tex">\frac{1}{30}</script></span> try:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh Th=square(2, 2); //the initial mesh
plot(Th, wait=true, ps=&quot;square-0.eps&quot;);

Th = adaptmesh(Th, 1./30., IsMetric=1, nbvx=10000);
plot(Th, wait=true, ps=&quot;square-1.eps&quot;);

Th = adaptmesh(Th, 1./30., IsMetric=1, nbvx=10000); //More the one time du to
Th = adaptmesh(Th, 1./30., IsMetric=1, nbvx=10000); //Adaptation bound `maxsubdiv=`
plot(Th, wait=true, ps=&quot;square-2.eps&quot;);
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="left"><a name="Fig17">Fig. 17</a>: Initial mesh</th>
<th align="left"><a name="Fig18">Fig. 18</a>: First iteration</th>
<th align="left"><a name="Fig19">Fig. 19</a>: Last iteration</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="Initial mesh" src="../images/MeshGeneration_AdaptMesh4.png" /></td>
<td align="left"><img alt="First iteration" src="../images/MeshGeneration_AdaptMesh5.png" /></td>
<td align="left"><img alt="Last iteration" src="../images/MeshGeneration_AdaptMesh6.png" /></td>
</tr>
</tbody>
</table>
<h2 id="trunc">Trunc<a class="headerlink" href="#trunc" title="Permanent link">#</a></h2>
<p>Two operators have been introduced to remove triangles from a mesh or to divide them. Operator <code class="codehilite">trunc</code> has two parameters:</p>
<ul>
<li><code class="codehilite">label=</code> sets the label number of new boundary item, one by default.</li>
<li><code class="codehilite">split=</code> sets the level <span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> of triangle splitting. Each triangle is split in <span><span class="MathJax_Preview">n\times n</span><script type="math/tex">n\times n</script></span>, one by default.</li>
</ul>
<p>To create the mesh <code class="codehilite">Th3</code> where all triangles of a mesh <code class="codehilite">Th</code> are split in <span><span class="MathJax_Preview">3{\times}3</span><script type="math/tex">3{\times}3</script></span>, just write:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh Th3 = trunc(Th, 1, split=3);
</pre></div>
</td></tr></table>

<p>The following example construct all "trunced" meshes to the support of the basic function of the space <code class="codehilite">Vh</code> (cf. <code class="codehilite">abs(u)&gt;0</code>), split all the triangles in <span><span class="MathJax_Preview">5{\times} 5</span><script type="math/tex">5{\times} 5</script></span>, and put a label number to <span><span class="MathJax_Preview">2</span><script type="math/tex">2</script></span> on a new boundary.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Mesh
mesh Th = square(3, 3);

// Fespace
fespace Vh(Th, P1);
Vh u=0;

// Loop on all degrees of freedom
int n=u.n;
for (int i = 0; i &lt; n; i++){
    u[][i] = 1; // The basis function i
    plot(u, wait=true);
    mesh Sh1 = trunc(Th, abs(u)&gt;1.e-10, split=5, label=2);
    plot(Th, Sh1, wait=true, ps=&quot;trunc&quot;+i+&quot;.eps&quot;);
    u[][i] = 0; // reset
}
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="left"><a name="Fig20">Fig. 20</a>: mesh of support the function P1 number 0, split in <span><span class="MathJax_Preview">5{\times}5</span><script type="math/tex">5{\times}5</script></span></th>
<th align="left"><a name="Fig21">Fig. 21</a>: Mesh of support the function P1 number 6, split in <span><span class="MathJax_Preview">5{\times}5</span><script type="math/tex">5{\times}5</script></span></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="Trunc0" src="../images/MeshGeneration_Trunc1.png" /></td>
<td align="left"><img alt="Trunc6" src="../images/MeshGeneration_Trunc2.png" /></td>
</tr>
</tbody>
</table>
<h2 id="splitmesh">Splitmesh<a class="headerlink" href="#splitmesh" title="Permanent link">#</a></h2>
<p>Another way to split mesh triangles is to use <code class="codehilite">splitmesh</code>, for example:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Mesh
border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
mesh Th = buildmesh(a(20));
plot(Th, wait=true, ps=&quot;NotSplittedMesh.eps&quot;);

// Splitmesh
Th = splitmesh(Th, 1 + 5*(square(x-0.5) + y*y));
plot(Th, wait=true, ps=&quot;SplittedMesh.eps&quot;);
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="center"><a name="Fig22">Fig. 22</a>: Initial mesh</th>
<th align="center"><a name="Fig23">Fig. 23</a>: all left mesh triangle is split conformaly in <code class="codehilite">int(1+5*(square(x-0.5)+y*y)\^2</code> triangles</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="No split mesh" src="../images/MeshGeneration_SplitMesh1.png" /></td>
<td align="center"><img alt="split mesh" src="../images/MeshGeneration_SplitMesh2.png" /></td>
</tr>
</tbody>
</table>
<h2 id="meshing-examples">Meshing Examples<a class="headerlink" href="#meshing-examples" title="Permanent link">#</a></h2>
<div class="admonition example">
<p class="admonition-title">Two rectangles touching by a side</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border a(t=0, 1){x=t; y=0;};
border b(t=0, 1){x=1; y=t;};
border c(t=1, 0){x=t; y=1;};
border d(t=1, 0){x=0; y=t;};
border c1(t=0, 1){x=t; y=1;};
border e(t=0, 0.2){x=1; y=1+t;};
border f(t=1, 0){x=t; y=1.2;};
border g(t=0.2, 0){x=0; y=1+t;};
int n=1;
mesh th = buildmesh(a(10*n) + b(10*n) + c(10*n) + d(10*n));
mesh TH = buildmesh(c1(10*n) + e(5*n) + f(10*n) + g(5*n));
plot(th, TH, ps=&quot;TouchSide.esp&quot;);
</pre></div>
</td></tr></table>

<p><center>
<!-- Review -->
|<a name="Fig24">Fig. 24</a>: Two rectangles touching by a side|
|:----:|
|<img alt="Rectangles touching by a side" src="../images/MeshGeneration_Example_NACA0012_1.png" />|</p>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">NACA0012 Airfoil</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border upper(t=0, 1){
    x=t;
    y=0.17735*sqrt(t) - 0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4);
}
border lower(t=1, 0){
    x = t;
    y=-(0.17735*sqrt(t) -0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4));
}
border c(t=0, 2*pi){x=0.8*cos(t) + 0.5; y=0.8*sin(t);}
mesh Th = buildmesh(c(30) + upper(35) + lower(35));
plot(Th, ps=&quot;NACA0012.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig25">Fig. 25</a>: NACA0012 Airfoil</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="NACA0012 Airfoil" src="../images/MeshGeneration_Example_NACA0012_2.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Cardioid</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real b = 1, a = b;

border C(t=0, 2*pi){x=(a+b)*cos(t)-b*cos((a+b)*t/b); y=(a+b)*sin(t)-b*sin((a+b)*t/b);}
mesh Th = buildmesh(C(50));
plot(Th, ps=&quot;Cardioid.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig26">Fig. 26</a>: Domain with Cardioid curve boundary</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Cardiod" src="../images/MeshGeneration_Example_Cardioid1.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Cassini Egg</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border C(t=0, 2*pi) {x=(2*cos(2*t)+3)*cos(t); y=(2*cos(2*t)+3)*sin(t);}
mesh Th = buildmesh(C(50));
plot(Th, ps=&quot;Cassini.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig27">Fig. 27</a>: Domain with Cassini Egg curve boundary</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Cassini" src="../images/MeshGeneration_Example_Cardioid2.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">By cubic Bezier curve</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// A cubic Bezier curve connecting two points with two control points
func real bzi(real p0, real p1, real q1, real q2, real t){
    return p0*(1-t)^3 + q1*3*(1-t)^2*t + q2*3*(1-t)*t^2 + p1*t^3;
}

real[int] p00 = [0, 1], p01 = [0, -1], q00 = [-2, 0.1], q01 = [-2, -0.5];
real[int] p11 = [1,-0.9], q10 = [0.1, -0.95], q11=[0.5, -1];
real[int] p21 = [2, 0.7], q20 = [3, -0.4], q21 = [4, 0.5];
real[int] q30 = [0.5, 1.1], q31 = [1.5, 1.2];
border G1(t=0, 1){
    x=bzi(p00[0], p01[0], q00[0], q01[0], t);
    y=bzi(p00[1], p01[1], q00[1], q01[1], t);
}
border G2(t=0, 1){
    x=bzi(p01[0], p11[0], q10[0], q11[0], t);
    y=bzi(p01[1], p11[1], q10[1], q11[1], t);
}
border G3(t=0, 1){
    x=bzi(p11[0], p21[0], q20[0], q21[0], t);
    y=bzi(p11[1], p21[1], q20[1], q21[1], t);
}
border G4(t=0, 1){
    x=bzi(p21[0], p00[0], q30[0], q31[0], t);
    y=bzi(p21[1], p00[1], q30[1], q31[1], t);
}
int m = 5;
mesh Th = buildmesh(G1(2*m) + G2(m) + G3(3*m) + G4(m));
plot(Th, ps=&quot;Bezier.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig28">Fig. 28</a>: Boundary drawn by Bezier curves</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Bezier" src="../images/MeshGeneration_Example_Bezier.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Section of Engine</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real a = 6., b = 1., c = 0.5;

border L1(t=0, 1){x=-a; y=1+b-2*(1+b)*t;}
border L2(t=0, 1){x=-a+2*a*t; y=-1-b*(x/a)*(x/a)*(3-2*abs(x)/a );}
border L3(t=0, 1){x=a; y=-1-b+(1+b)*t; }
border L4(t=0, 1){x=a-a*t; y=0;}
border L5(t=0, pi){x=-c*sin(t)/2; y=c/2-c*cos(t)/2;}
border L6(t=0, 1){x=a*t; y=c;}
border L7(t=0, 1){x=a; y=c+(1+b-c)*t;}
border L8(t=0, 1){x=a-2*a*t; y=1+b*(x/a)*(x/a)*(3-2*abs(x)/a);}
mesh Th = buildmesh(L1(8) + L2(26) + L3(8) + L4(20) + L5(8) + L6(30) + L7(8) + L8(30));
plot(Th, ps=&quot;Engine.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="left"><a name="Fig29">Fig. 29</a>: Section of Engine</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="Engine" src="../images/MeshGeneration_Example_Engine.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Domain with U-shape channel</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real d = 0.1; //width of U-shape
border L1(t=0, 1-d){x=-1; y=-d-t;}
border L2(t=0, 1-d){x=-1; y=1-t;}
border B(t=0, 2){x=-1+t; y=-1;}
border C1(t=0, 1){x=t-1; y=d;}
border C2(t=0, 2*d){x=0; y=d-t;}
border C3(t=0, 1){x=-t; y=-d;}
border R(t=0, 2){x=1; y=-1+t;}
border T(t=0, 2){x=1-t; y=1;}
int n = 5;
mesh Th = buildmesh(L1(n/2) + L2(n/2) + B(n) + C1(n) + C2(3) + C3(n) + R(n) + T(n));
plot(Th, ps=&quot;U-shape.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="left"><a name="Fig30">Fig. 30</a>: Domain with U-shape channel changed by <code class="codehilite">d</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="U-Shape" src="../images/MeshGeneration_Example_UShape.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Domain with V-shape cut</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real dAg = 0.02; //angle of V-shape
border C(t=dAg, 2*pi-dAg){x=cos(t); y=sin(t);};
real[int] pa(2), pb(2), pc(2);
pa[0] = cos(dAg);
pa[1] = sin(dAg);
pb[0] = cos(2*pi-dAg);
pb[1] = sin(2*pi-dAg);
pc[0] = 0;
pc[1] = 0;
border seg1(t=0, 1){x=(1-t)*pb[0]+t*pc[0]; y=(1-t)*pb[1]+t*pc[1];};
border seg2(t=0, 1){x=(1-t)*pc[0]+t*pa[0]; y=(1-t)*pc[1]+t*pa[1];};
mesh Th = buildmesh(seg1(20) + C(40) + seg2(20));
plot(Th, ps=&quot;V-shape.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="left"><a name="Fig31">Fig. 31</a>: Domain with V-shape cut changed by <code class="codehilite">dAg</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="V-Shape" src="../images/MeshGeneration_Example_VShape.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Smiling face</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>real d=0.1;
int m = 5;
real a = 1.5, b = 2, c = 0.7, e = 0.01;

border F(t=0, 2*pi){x=a*cos(t); y=b*sin(t);}
border E1(t=0, 2*pi){x=0.2*cos(t)-0.5; y=0.2*sin(t)+0.5;}
border E2(t=0, 2*pi){x=0.2*cos(t)+0.5; y=0.2*sin(t)+0.5;}
func real st(real t){
    return sin(pi*t) - pi/2;
}
border C1(t=-0.5, 0.5){x=(1-d)*c*cos(st(t)); y=(1-d)*c*sin(st(t));}
border C2(t=0, 1){x=((1-d)+d*t)*c*cos(st(0.5)); y=((1-d)+d*t)*c*sin(st(0.5));}
border C3(t=0.5, -0.5){x=c*cos(st(t)); y=c*sin(st(t));}
border C4(t=0, 1){x=(1-d*t)*c*cos(st(-0.5)); y=(1-d*t)*c*sin(st(-0.5));}
border C0(t=0, 2*pi){x=0.1*cos(t); y=0.1*sin(t);}

mesh Th=buildmesh(F(10*m) + C1(2*m) + C2(3) + C3(2*m) + C4(3)
    + C0(m) + E1(-2*m) + E2(-2*m));
plot(Th, ps=&quot;SmileFace.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig32">Fig. 32</a>: Smiling face (Mouth is changeable)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Smiling Face" src="../images/MeshGeneration_Example_SmilingFace.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">3 points bending</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>// Square for Three-Point Bend Specimens fixed on Fix1, Fix2
// It will be loaded on Load.
real a = 1, b = 5, c = 0.1;
int n = 5, m = b*n;
border Left(t=0, 2*a){x=-b; y=a-t;}
border Bot1(t=0, b/2-c){x=-b+t; y=-a;}
border Fix1(t=0, 2*c){x=-b/2-c+t; y=-a;}
border Bot2(t=0, b-2*c){x=-b/2+c+t; y=-a;}
border Fix2(t=0, 2*c){x=b/2-c+t; y=-a;}
border Bot3(t=0, b/2-c){x=b/2+c+t; y=-a;}
border Right(t=0, 2*a){x=b; y=-a+t;}
border Top1(t=0, b-c){x=b-t; y=a;}
border Load(t=0, 2*c){x=c-t; y=a;}
border Top2(t=0, b-c){x=-c-t; y=a;}

mesh Th = buildmesh(Left(n) + Bot1(m/4) + Fix1(5) + Bot2(m/2)
    + Fix2(5) + Bot3(m/4) + Right(n) + Top1(m/2) + Load(10) + Top2(m/2));
plot(Th, ps=&quot;ThreePoint.eps&quot;, bw=true);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="left"><a name="Fig33">Fig. 33</a>: Domain for three-point bending test</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="Three-point bending test" src="../images/MeshGeneration_Example_ThreePoints.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<h2 id="how-to-change-the-label-of-elements-and-border-elements-of-a-mesh">How to change the label of elements and border elements of a mesh<a class="headerlink" href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh" title="Permanent link">#</a></h2>
<p>Changing the label of elements and border elements will be done using the keyword <code class="codehilite">change</code>. The parameters for this command line are for two dimensional and three dimensional cases:</p>
<ul>
<li>
<p><code class="codehilite">label =</code> is a vector of integer that contains successive pairs of the old label number to the new label number.</p>
</li>
<li>
<p><code class="codehilite">region =</code> is a vector of integer that contains successive pairs of the old region number to new region number.</p>
</li>
<li>
<p><code class="codehilite">flabel =</code> is an integer function given the new value of the label.</p>
</li>
<li>
<p><code class="codehilite">fregion=</code> is an integer function given the new value of the region.</p>
</li>
</ul>
<p>These vectors are composed of <span><span class="MathJax_Preview">n_{l}</span><script type="math/tex">n_{l}</script></span> successive pairs of numbers <span><span class="MathJax_Preview">O,N</span><script type="math/tex">O,N</script></span> where <span><span class="MathJax_Preview">n_{l}</span><script type="math/tex">n_{l}</script></span> is the number (label or region) that we want to change. For example, we have :</p>
<div>
<div class="MathJax_Preview">\begin{eqnarray}
\label{eq.org.vector.change.label}
\mathtt{label} &amp;= &amp;[ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &amp; =&amp; [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]
\end{eqnarray}</div>
<script type="math/tex; mode=display">\begin{eqnarray}
\label{eq.org.vector.change.label}
\mathtt{label} &= &[ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} & =& [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]
\end{eqnarray}</script>
</div>
<p>An example of using this function is given here:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>verbosity=3;

// Mesh
mesh Th1 = square(10, 10);
mesh Th2 = square(20, 10, [x+1, y]);

int[int] r1=[2,0];
plot(Th1, wait=true);

Th1 = change(Th1, label=r1); //change the label of Edges 2 in 0.
plot(Th1, wait=true);

int[int] r2=[4,0];
Th2 = change(Th2, label=r2); //change the label of Edges 4 in 0.
plot(Th2, wait=true);

mesh Th = Th1 + Th2; //&#39;gluing together&#39; of meshes Th1 and Th2
cout &lt;&lt; &quot;nb lab = &quot; &lt;&lt; int1d(Th1,1,3,4)(1./lenEdge)+int1d(Th2,1,2,3)(1./lenEdge)
     &lt;&lt; &quot; == &quot; &lt;&lt; int1d(Th,1,2,3,4)(1./lenEdge) &lt;&lt; &quot; == &quot; &lt;&lt; ((10+20)+10)*2 &lt;&lt; endl;
plot(Th, wait=true);

fespace Vh(Th, P1);
Vh u, v;

macro Grad(u) [dx(u),dy(u)] // Definition of a macro

solve P(u, v)
    = int2d(Th)(
          Grad(u)&#39;*Grad(v)
    )
    -int2d(Th)(
          v
    )
    + on(1, 3, u=0)
    ;

plot(u, wait=1);
</pre></div>
</td></tr></table>

<p><strong>"gluing" different mesh</strong>
In line 17 of the previous file, the method to "gluing" different meshes of the same dimension in FreeFem++ is using. This function is the operator "+" between meshes. The method implemented needs the point in adjacent meshes to be the same.</p>
<h2 id="mesh-in-three-dimensions">Mesh in three dimensions<a class="headerlink" href="#mesh-in-three-dimensions" title="Permanent link">#</a></h2>
<h3 id="cube">Cube<a class="headerlink" href="#cube" title="Permanent link">#</a></h3>
<p>A new function <code class="codehilite">cube</code> like the function <code class="codehilite">square</code> in 2d is the simple way to a build cubic object, in plugin <code class="codehilite">msh3</code> (need <code class="codehilite">load &quot;msh3&quot;</code>).</p>
<p>The following code generates a <span><span class="MathJax_Preview">3\times 4 \times 5</span><script type="math/tex">3\times 4 \times 5</script></span> grid in the unit cube <span><span class="MathJax_Preview">[0, 1]^3</span><script type="math/tex">[0, 1]^3</script></span>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh3 Th = cube(3, 4, 5);
</pre></div>
</td></tr></table>

<p>By default the labels are :</p>
<ol>
<li>face <span><span class="MathJax_Preview">y=0</span><script type="math/tex">y=0</script></span>,</li>
<li>face <span><span class="MathJax_Preview">x=1</span><script type="math/tex">x=1</script></span>,</li>
<li>face <span><span class="MathJax_Preview">y=1</span><script type="math/tex">y=1</script></span>,</li>
<li>face <span><span class="MathJax_Preview">x=0</span><script type="math/tex">x=0</script></span>,</li>
<li>face <span><span class="MathJax_Preview">z=0</span><script type="math/tex">z=0</script></span>,</li>
<li>face <span><span class="MathJax_Preview">z=1</span><script type="math/tex">z=1</script></span></li>
</ol>
<p>and the region number is <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>.</p>
<p>A full example of this function to build a mesh of cube <span><span class="MathJax_Preview">]-1,1[^3</span><script type="math/tex">]-1,1[^3</script></span> with face label given by <span><span class="MathJax_Preview">(ix + 4*(iy+1) + 16*(iz+1))</span><script type="math/tex">(ix + 4*(iy+1) + 16*(iz+1))</script></span> where <span><span class="MathJax_Preview">(ix, iy, iz)</span><script type="math/tex">(ix, iy, iz)</script></span> are the coordinates of the barycenter of the current face, is given below.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;

int[int] l6 = [37, 42, 45, 40, 25, 57];
int r11 = 11;
mesh3 Th = cube(4, 5, 6, [x*2-1, y*2-1, z*2-1], label=l6, flags =3, region=r11);

cout &lt;&lt; &quot;Volume = &quot; &lt;&lt; Th.measure &lt;&lt; &quot;, border area = &quot; &lt;&lt; Th.bordermeasure &lt;&lt; endl;

int err = 0;
for(int i = 0; i &lt; 100; ++i){
    real s = int2d(Th,i)(1.);
    real sx = int2d(Th,i)(x);
    real sy = int2d(Th,i)(y);
    real sz = int2d(Th,i)(z);

    if(s){
        int ix = (sx/s+1.5);
        int iy = (sy/s+1.5);
        int iz = (sz/s+1.5);
        int ii = (ix + 4*(iy+1) + 16*(iz+1) );
        //value of ix,iy,iz =&gt; face min 0, face max 2, no face 1
        cout &lt;&lt; &quot;Label = &quot; &lt;&lt; i &lt;&lt; &quot;, s = &quot; &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; ix &lt;&lt; iy &lt;&lt; iz &lt;&lt; &quot; : &quot; &lt;&lt; ii &lt;&lt; endl;
        if( i != ii ) err++;
    }
}
real volr11 = int3d(Th,r11)(1.);
cout &lt;&lt; &quot;Volume region = &quot; &lt;&lt; 11 &lt;&lt; &quot;: &quot; &lt;&lt; volr11 &lt;&lt; endl;
if((volr11 - Th.measure )&gt;1e-8) err++;
plot(Th, fill=false);
cout &lt;&lt; &quot;Nb err = &quot; &lt;&lt; err &lt;&lt; endl;
assert(err==0);
</pre></div>
</td></tr></table>

<p>The output of this script is:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>Enter: BuildCube: 3
  kind = 3 n tet Cube = 6 / n slip 6 19
Cube  nv=210 nt=720 nbe=296
Out:  BuildCube
Volume = 8, border area = 24
Label = 25, s = 4 110 : 25
Label = 37, s = 4 101 : 37
Label = 40, s = 4 011 : 40
Label = 42, s = 4 211 : 42
Label = 45, s = 4 121 : 45
Label = 57, s = 4 112 : 57
Volume region = 11: 8
Nb err = 0
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="left"><a name="Fig34">Fig. 34</a>: The mesh 3d of function <code class="codehilite">cube(4, 5, 6, flags=3)</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><img alt="Function cube mesh" src="../images/MeshGeneration_Cube.jpg" /></td>
</tr>
</tbody>
</table>
<p></center></p>
<h3 id="readwrite-statements-for-a-mesh-in-3d">Read/Write Statements for a Mesh in 3D<a class="headerlink" href="#readwrite-statements-for-a-mesh-in-3d" title="Permanent link">#</a></h3>
<p>In three dimensions, the file mesh format supported for input and output files by FreeFem++ are the extension .msh and .mesh. These formats are described in the <a href="Developers/#mesh-format">Mesh Format section</a>.</p>
<p><strong>Extension file .msh</strong>
The structure of the files with extension .msh in 3D is given in <a href="Tab2">Table 2.</a>.</p>
<p>In this structure, <span><span class="MathJax_Preview">n_v</span><script type="math/tex">n_v</script></span> denotes the number of vertices, <span><span class="MathJax_Preview">n_{tet}</span><script type="math/tex">n_{tet}</script></span> the number of tetrahedra and <span><span class="MathJax_Preview">n_{tri}</span><script type="math/tex">n_{tri}</script></span> the number of triangles.</p>
<p>For each vertex <span><span class="MathJax_Preview">q^i,\, i=1,\cdots,n_v</span><script type="math/tex">q^i,\, i=1,\cdots,n_v</script></span>, we denote by <span><span class="MathJax_Preview">(q^i_x,q^i_y,q^i_z)</span><script type="math/tex">(q^i_x,q^i_y,q^i_z)</script></span> the <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>-coordinate, the <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>-coordinate and the <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-coordinate.</p>
<p>Each tetrahedra <span><span class="MathJax_Preview">T_k, k=1,\cdots,n_{tet}</span><script type="math/tex">T_k, k=1,\cdots,n_{tet}</script></span> has four vertices <span><span class="MathJax_Preview">q^{k_1},\, q^{k_2},\,q^{k_3}, \,q^{k_4}</span><script type="math/tex">q^{k_1},\, q^{k_2},\,q^{k_3}, \,q^{k_4}</script></span>.</p>
<p>The boundary consists of a union of triangles. Each triangle <span><span class="MathJax_Preview">be_j, j=1,\cdots,n_{tri}</span><script type="math/tex">be_j, j=1,\cdots,n_{tri}</script></span> has three vertices <span><span class="MathJax_Preview">q^{j_1},\, q^{j_2},\,q^{j_3}</span><script type="math/tex">q^{j_1},\, q^{j_2},\,q^{j_3}</script></span>.</p>
<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Tab2">Table 2</a>: The structure of a mesh file format <code class="codehilite">.msh</code> in three dimensions.</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">
<script type="math/tex; mode=display">\begin{array}{htbp}n_v& n_{tet}& n_{tri} & &\\q^1_x& q^1_y& q^1_z & Vertex label &\\ q^2_x& q^2_y& q^2_z & Vertex label &\\ \vdots &\vdots &\vdots &\vdots &\\ q^{n_v}_x&q^{n_v}_y& q^{n_v}_z & Vertex label&\\ 1_1& 1_2& 1_3& 1_4 & region label \\ 2_1& 2_2& 2_3& 2_4 & region label \\ \vdots &\vdots &\vdots &\vdots &\vdots \\ (n_{tet})_1& (n_{tet})_2& (n_{tet})_3 & (n_{tet})_4 & region label \\ 1_1 & 1_2& 1_3& boundary label & \\ 2_1 & 2_2& 2_3& boundary label & \\ \vdots& \vdots &\vdots &\vdots &\\ (n_tri)_{1} & (n_{tri})_2& (n_{tri})_3 & boundary label &\\ \end{array}</script>
</td>
</tr>
</tbody>
</table>
<p></center></p>
<p><strong>extension file .mesh</strong>
The data structure for a three dimensional mesh is composed of the data structure presented in <a href="Developers/#mesh-format">Mesh Format section</a> and a data structure for the tetrahedra. The tetrahedra of a three dimensional mesh are referred using the following field:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>Tetrahedra
NbTetrahedra
Vertex1 Vertex2 Vertex3 Vertex4 Label
...
Vertex1 Vertex2 Vertex3 Vertex4 Label
</pre></div>
</td></tr></table>

<p>This field is express with the notation of <a href="Developers/#mesh-format">Mesh Format section</a>.</p>
<h3 id="tetgen-a-tetrahedral-mesh-generator">TetGen: A tetrahedral mesh generator<a class="headerlink" href="#tetgen-a-tetrahedral-mesh-generator" title="Permanent link">#</a></h3>
<p><strong>TetGen</strong></p>
<p>TetGen is a software developed by Dr. Hang Si of Weierstrass Institute for Applied Analysis and Stochastics in Berlin, Germany <a href="#refHang2006">Hang2006</a>. TetGen is free for research and non-commercial use. For any commercial license utilization, a commercial license is available upon request to Hang Si.</p>
<p>This software is a tetrahedral mesh generator of a three dimensional domain defined by its boundary. The input domain takes into account a polyhedral or a piecewise linear complex. This tetrahedralization is a constrained Delaunay tetrahedralization.</p>
<p>The method used in TetGen to control the quality of the mesh is a Delaunay refinement due to Shewchuk <a href="#refShewchuk1998">Shewchuk1998</a>. The quality measure of this algorithm is the Radius-Edge Ratio (see Section 1.3.1 <a href="#refHang2006">Hang2006</a> for more details). A theoretical bound of this ratio of the Shewchuk algorithm is obtained for a given complex of vertices, constrained segments and facets of surface mesh, with no input angle less than 90 degrees. This theoretical bound is 2.0.</p>
<p>The launch of TetGen is done with the keyword <code class="codehilite">tetg</code>. The parameters of this command line is:</p>
<ul>
<li>
<p><code class="codehilite">reftet=</code> sets the label of tetrahedra.</p>
</li>
<li>
<p><code class="codehilite">label=</code> is a vector of integers that contains the old labels number at index <span><span class="MathJax_Preview">2i</span><script type="math/tex">2i</script></span> and the new labels number at index <span><span class="MathJax_Preview">2i+1</span><script type="math/tex">2i+1</script></span> of Triangles. This parameter is initialized as a label for the keyword <a href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh">change</a>.</p>
</li>
<li>
<p><code class="codehilite">switch=</code> A string expression. This string corresponds to the command line switch of TetGen see Section 3.2 of <a href="#refHang2006">Hang2006</a>.</p>
</li>
<li>
<p><code class="codehilite">nbofholes=</code> Number of holes (default value: "size of <code class="codehilite">holelist</code> / 3").</p>
</li>
<li>
<p><code class="codehilite">holelist=</code> This array corresponds to <code class="codehilite">holelist</code> of TetGenio data structure <a href="#refHang2006">Hang2006</a>. A real vector of size <code class="codehilite">3 * nbofholes</code>. In TetGen, each hole is associated with a point inside this domain. This vector is <span><span class="MathJax_Preview">x_{1}^{h}, y_{1}^{h}, z_{1}^{h}, x_{2}^{h}, y_{2}^{h}, z_{2}^{h}, \cdots,</span><script type="math/tex">x_{1}^{h}, y_{1}^{h}, z_{1}^{h}, x_{2}^{h}, y_{2}^{h}, z_{2}^{h}, \cdots,</script></span> where <span><span class="MathJax_Preview">x_{i}^{h},y_{i}^{h},z_{i}^{h}</span><script type="math/tex">x_{i}^{h},y_{i}^{h},z_{i}^{h}</script></span> is the associated point with the <span><span class="MathJax_Preview">i^{\mathrm{th}}</span><script type="math/tex">i^{\mathrm{th}}</script></span> hole.</p>
</li>
<li>
<p><code class="codehilite">nbofregions=</code> Number of regions (default value: "size of <code class="codehilite">regionlist</code> / 5").</p>
</li>
<li>
<p><code class="codehilite">regionlist=</code> This array corresponds to <code class="codehilite">regionlist</code> of TetGenio data structure <a href="#refHang2006">Hang2006</a>.</p>
<p>The attribute and the volume constraint of region are given in this real vector of size <code class="codehilite">5 * nbofregions</code>. The <span><span class="MathJax_Preview">i^{\mathrm{th}}</span><script type="math/tex">i^{\mathrm{th}}</script></span> region is described by five elements: <span><span class="MathJax_Preview">x-</span><script type="math/tex">x-</script></span>coordinate, <span><span class="MathJax_Preview">y-</span><script type="math/tex">y-</script></span>coordinate and <span><span class="MathJax_Preview">z-</span><script type="math/tex">z-</script></span>coordinate of a point inside this domain (<span><span class="MathJax_Preview">x_{i},y_{i},z_{i}</span><script type="math/tex">x_{i},y_{i},z_{i}</script></span>); the attribute (<span><span class="MathJax_Preview">at_{i}</span><script type="math/tex">at_{i}</script></span>) and the maximum volume for tetrahedra (<span><span class="MathJax_Preview">mvol_{i}</span><script type="math/tex">mvol_{i}</script></span>) for this region.</p>
<p>The <code class="codehilite">regionlist</code> vector is: <span><span class="MathJax_Preview">x_{1}, y_{1}, z_{1}, at_{1}, mvol_{1}, x_{2}, y_{2}, z_{2}, at_{2}, mvol_{2}, \cdots</span><script type="math/tex">x_{1}, y_{1}, z_{1}, at_{1}, mvol_{1}, x_{2}, y_{2}, z_{2}, at_{2}, mvol_{2}, \cdots</script></span>.</p>
</li>
<li>
<p><code class="codehilite">nboffacetcl=</code> Number of facets constraints "size of <code class="codehilite">facetcl</code> / 2").</p>
</li>
<li>
<p><code class="codehilite">facetcl=</code> This array corresponds to <code class="codehilite">facetconstraintlist</code> of TetGenio data structure <a href="#refHang2006">Hang2006</a>.</p>
<p>The <span><span class="MathJax_Preview">i^{th}</span><script type="math/tex">i^{th}</script></span> facet constraint is defined by the facet marker <span><span class="MathJax_Preview">Ref_{i}^{fc}</span><script type="math/tex">Ref_{i}^{fc}</script></span> and the maximum area for faces <span><span class="MathJax_Preview">marea_{i}^{fc}</span><script type="math/tex">marea_{i}^{fc}</script></span>. The <code class="codehilite">facetcl</code> array is: <span><span class="MathJax_Preview">Ref_{1}^{fc}, marea_{1}^{fc}, Ref_{2}^{fc}, marea_{2}^{fc}, \cdots</span><script type="math/tex">Ref_{1}^{fc}, marea_{1}^{fc}, Ref_{2}^{fc}, marea_{2}^{fc}, \cdots</script></span>.</p>
<p>This parameters has no effect if switch <code class="codehilite">q</code> is not selected.</p>
</li>
</ul>
<p>Principal switch parameters in TetGen:</p>
<ul>
<li>
<p><code class="codehilite">p</code> Tetrahedralization of boundary.</p>
</li>
<li>
<p><code class="codehilite">q</code> Quality mesh generation. The bound of Radius-Edge Ratio will be given after the option <code class="codehilite">q</code>. By default, this value is 2.0.</p>
</li>
<li>
<p><code class="codehilite">a</code> Constructs with the volume constraints on tetrahedra. These volumes constraints are defined with the bound of the previous
switch <code class="codehilite">q</code> or in the parameter <code class="codehilite">regionlist</code>.</p>
</li>
<li>
<p><code class="codehilite">A</code> Attributes reference to region given in the <code class="codehilite">regionlist</code>. The other regions have label 0.</p>
<p>The option <code>AA</code> gives a different label at each region. This switch works with the option <code class="codehilite">p</code>. If option <code class="codehilite">r</code> is used, this switch has no effect.</p>
</li>
<li>
<p><code class="codehilite">r</code> Reconstructs and Refines a previously generated mesh. This character is only used with the command line <code class="codehilite">tetgreconstruction</code>.</p>
</li>
<li>
<p><code class="codehilite">Y</code> This switch preserves the mesh on the exterior boundary.</p>
<p>This switch must be used to ensure a conformal mesh between two adjacent meshes.</p>
</li>
<li>
<p><code class="codehilite">YY</code> This switch preserves the mesh on the exterior and interior boundary.</p>
</li>
<li>
<p><code class="codehilite">C</code> The consistency of the result's mesh is testing by TetGen.</p>
</li>
<li>
<p><code class="codehilite">CC</code> The consistency of the result's mesh is testing by TetGen and also constrained checks of Delaunay mesh (if <code class="codehilite">p</code> switch is selected) or the consistency of Conformal Delaunay (if <code class="codehilite">q</code> switch is selected).</p>
</li>
<li>
<p><code class="codehilite">V</code> Give information of the work of TetGen. More information can be obtained in specified <code class="codehilite">VV</code> or <code class="codehilite">VVV</code>.</p>
</li>
<li>
<p><code class="codehilite">Q</code> Quiet: No terminal output except errors</p>
</li>
<li>
<p><code class="codehilite">M</code> The coplanar facets are not merging.</p>
</li>
<li>
<p><code class="codehilite">T</code> Sets a tolerance for coplanar test. The default value is <span><span class="MathJax_Preview">1e-8</span><script type="math/tex">1e-8</script></span>.</p>
</li>
<li>
<p><code class="codehilite">d</code> Intersections of facets are detected.</p>
</li>
</ul>
<p>To obtain a tetrahedral mesh with TetGen, we need the surface mesh of a three dimensional domain. We now give the command line in FreeFem++ to construct these meshes.</p>
<p><strong>keyword: <code class="codehilite">movemesh23</code></strong></p>
<p>A simple method to construct a surface is to place a two dimensional domain in a three dimensional space. This corresponds to moving the domain by a displacement vector of this form <span><span class="MathJax_Preview">\mathbf{\Phi(x,y)} = (\Phi1(x,y), \Phi2(x,y), \Phi3(x,y))</span><script type="math/tex">\mathbf{\Phi(x,y)} = (\Phi1(x,y), \Phi2(x,y), \Phi3(x,y))</script></span>.</p>
<p>The result of moving a two dimensional mesh Th2 by this three dimensional displacement is obtained using:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh3 Th3 = movemesh23(Th2, transfo=[Phi(1), Phi(2), Phi(3)]);
</pre></div>
</td></tr></table>

<p>The parameters of this command line are:</p>
<ul>
<li>
<p><code class="codehilite">transfo=</code> [<span><span class="MathJax_Preview">\Phi 1</span><script type="math/tex">\Phi 1</script></span>, <span><span class="MathJax_Preview">\Phi 2</span><script type="math/tex">\Phi 2</script></span>, <span><span class="MathJax_Preview">\Phi 3</span><script type="math/tex">\Phi 3</script></span>] sets the displacement vector of transformation <span><span class="MathJax_Preview">\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]</span><script type="math/tex">\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]</script></span>.</p>
</li>
<li>
<p><code class="codehilite">label=</code> sets an integer label of triangles.</p>
</li>
<li>
<p><code class="codehilite">orientation=</code> sets an integer orientation of mesh.</p>
</li>
<li>
<p><code class="codehilite">ptmerge=</code> A real expression. When you transform a mesh, some points can be merged. This parameter is the criteria to define two merging points. By default, we use
    <script type="math/tex; mode=display">
    ptmerge \: = \: 1e-7 \: \:Vol( B ),
    </script>
    where <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is the smallest axis, parallel boxes containing the discretized domain of <span><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> and <span><span class="MathJax_Preview">Vol(B)</span><script type="math/tex">Vol(B)</script></span> is the volume of this box.</p>
</li>
</ul>
<p>We can do a "gluing" of surface meshes using the process given in <a href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh">Change section</a>. An example to obtain a three dimensional mesh using the command line <code class="codehilite">tetg</code> and <code class="codehilite">movemesh23</code> is given below.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;tetgen&quot;

// Parameters
real x10 = 1.;
real x11 = 2.;
real y10 = 0.;
real y11 = 2.*pi;

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

real x20 = 1.;
real x21 = 2.;
real y20=0.;
real y21=1.5;

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

real x30=0.;
real x31=2*pi;
real y30=0.;
real y31=1.5;

func XX3min = 1.;
func XX3max = 2.;
func YY3 = x;
func ZZ3 = y;

// Mesh
mesh Thsq1 = square(5, 35, [x10+(x11-x10)*x, y10+(y11-y10)*y]);
mesh Thsq2 = square(5, 8, [x20+(x21-x20)*x, y20+(y21-y20)*y]);
mesh Thsq3 = square(35, 8, [x30+(x31-x30)*x, y30+(y31-y30)*y]);

// Mesh 2D to 3D surface
mesh3 Th31h = movemesh23(Thsq1, transfo=[XX1, YY1, ZZ1max]);
mesh3 Th31b = movemesh23(Thsq1, transfo=[XX1, YY1, ZZ1min]);

mesh3 Th32h = movemesh23(Thsq2, transfo=[XX2, YY2max, ZZ2]);
mesh3 Th32b = movemesh23(Thsq2, transfo=[XX2, YY2min, ZZ2]);

mesh3 Th33h = movemesh23(Thsq3, transfo=[XX3max, YY3, ZZ3]);
mesh3 Th33b = movemesh23(Thsq3, transfo=[XX3min, YY3, ZZ3]);

// Gluing surfaces
mesh3 Th33 = Th31h + Th31b + Th32h + Th32b + Th33h + Th33b;
plot(Th33, cmm=&quot;Th33&quot;);

// Tetrahelize the interior of the cube with TetGen
real[int] domain =[1.5, pi, 0.75, 145, 0.0025];
mesh3 Thfinal = tetg(Th33, switch=&quot;paAAQY&quot;, regionlist=domain);
plot(Thfinal, cmm=&quot;Thfinal&quot;);

// Build a mesh of a half cylindrical shell of interior radius 1, and exterior radius 2 and a height of 1.5
func mv2x = x*cos(y);
func mv2y = x*sin(y);
func mv2z = z;
mesh3 Thmv2 = movemesh3(Thfinal, transfo=[mv2x, mv2y, mv2z]);
plot(Thmv2, cmm=&quot;Thmv2&quot;);
</pre></div>
</td></tr></table>

<p>The command <code class="codehilite">movemesh3</code> is described in the following section.</p>
<p><strong>The keyword <code class="codehilite">tetgtransfo</code></strong></p>
<p>This keyword corresponds to a composition of command line <code class="codehilite">tetg</code> and <code class="codehilite">movemesh23</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>tetgtransfo(Th2, transfo=[Phi(1), Phi(2), Phi(3)]), ...) = tetg(Th3surf, ...),
</pre></div>
</td></tr></table>

<p>where <code class="codehilite">Th3surf = movemesh23(Th2, transfo=[Phi(1), Phi(2), Phi(3)])</code> and <code class="codehilite">Th2</code> is the input two dimensional mesh of <code class="codehilite">tetgtransfo</code>.</p>
<p>The parameters of this command line are, on one hand, the parameters <code class="codehilite">label</code>, <code class="codehilite">switch</code>, <code class="codehilite">regionlist</code>, <code class="codehilite">nboffacetcl</code>, <code class="codehilite">facetcl</code> of keyword <code class="codehilite">tetg</code> and on the other hand, the parameter <code class="codehilite">ptmerge</code> of keyword <code class="codehilite">movemesh23</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To use <code class="codehilite">tetgtransfo</code>, the result's mesh of <code class="codehilite">movemesh23</code> must be a closed surface and define one region only. Therefore, the parameter <code class="codehilite">regionlist</code> is defined for one region.</p>
<p>An example of this keyword can be found in line 61 of the <a href="../examples/#example-build-layer-mesh">Build layer mesh example</a>.</p>
</div>
<p><strong>The keyword <code class="codehilite">tetgconvexhull</code></strong></p>
<p>FreeFem++, using TetGen, is able to build a tetrahedralization from a set of points. This tetrahedralization is a Delaunay mesh of the convex hull of the set of points.</p>
<p>The coordinates of the points can be initialized in two ways. The first is a file that contains the coordinate of points <span><span class="MathJax_Preview">X_{i}=(x_{i}, y_{i}, z_{i})</span><script type="math/tex">X_{i}=(x_{i}, y_{i}, z_{i})</script></span>. This file is organized as follows:</p>
<div>
<div class="MathJax_Preview">
\begin{array}{ccc}
n_{v} &amp; &amp; \\
x_{1} &amp; y_{1} &amp; z_{1} \\
x_{2} &amp; y_{2} &amp; z_{2} \\
\vdots &amp;\vdots &amp; \vdots \\
x_{n_v} &amp; y_{n_v} &amp; z_{n_v}
\end{array}
</div>
<script type="math/tex; mode=display">
\begin{array}{ccc}
n_{v} & & \\
x_{1} & y_{1} & z_{1} \\
x_{2} & y_{2} & z_{2} \\
\vdots &\vdots & \vdots \\
x_{n_v} & y_{n_v} & z_{n_v}
\end{array}
</script>
</div>
<p>The second way is to give three arrays that correspond respectively to the <span><span class="MathJax_Preview">x-</span><script type="math/tex">x-</script></span>coordinates, <span><span class="MathJax_Preview">y-</span><script type="math/tex">y-</script></span>coordinates and <span><span class="MathJax_Preview">z-</span><script type="math/tex">z-</script></span>coordinates.</p>
<p>The parameters of this command line are :</p>
<ul>
<li>
<p><code class="codehilite">switch=</code> A string expression. This string corresponds to the command line <code class="codehilite">switch</code> of TetGen see Section 3.2 of <a href="#refHang2006">Hang2006</a>.</p>
</li>
<li>
<p><code class="codehilite">reftet=</code> An integer expression. Set the label of tetrahedra.</p>
</li>
<li>
<p><code class="codehilite">label=</code> An integer expression. Set the label of triangles.</p>
</li>
</ul>
<p>In the string <code class="codehilite">switch</code>, we can't used the option <code class="codehilite">p</code> and <code class="codehilite">q</code> of TetGen.</p>
<h3 id="reconstructrefine-a-three-dimensional-mesh-with-tetgen">Reconstruct/Refine a three dimensional mesh with TetGen<a class="headerlink" href="#reconstructrefine-a-three-dimensional-mesh-with-tetgen" title="Permanent link">#</a></h3>
<p>Meshes in three dimension can be refined using TetGen with the command line <code class="codehilite">tetgreconstruction</code>.</p>
<p>The parameter of this keyword are</p>
<ul>
<li>
<p><code class="codehilite">region=</code> an integer array that changes the region number of tetrahedra. This array is defined as the parameter <code class="codehilite">reftet</code> in the keyword <code class="codehilite">change</code>.</p>
</li>
<li>
<p><code class="codehilite">label=</code> an integer array that changes the label of boundary triangles. This array is defined as the parameter <code class="codehilite">label</code> in the keyword <code class="codehilite">change</code>.</p>
</li>
<li>
<p><code class="codehilite">sizeofvolume=</code> a reel function. This function constraints the volume size of the tetrahedra in the domain. (see <a href="#a-first-3d-isotrope-mesh-adaptation-process">Isotrope mesh adaption section</a> to build a 3d adapted mesh).</p>
</li>
</ul>
<p>The parameters <code class="codehilite">switch</code>, <code class="codehilite">nbofregions</code>, <code class="codehilite">regionlist</code>, <code class="codehilite">nboffacetcl</code> and <code class="codehilite">facetcl</code> of the command line which call TetGen (<code class="codehilite">tetg</code>) is used for <code class="codehilite">tetgrefine</code>.</p>
<p>In the parameter <code class="codehilite">switch=</code>, the character <code class="codehilite">r</code> should be used without the character <code class="codehilite">p</code>.</p>
<p>For instance, see the manual of TetGen <a href="#refHang2006">Hang2006</a> for effect of <code class="codehilite">r</code> to other character.</p>
<p>The parameter <code class="codehilite">regionlist</code> defines a new volume constraint in the region. The label in the <code class="codehilite">regionlist</code> will be the previous label of region.</p>
<p>This parameter and <code class="codehilite">nbofregions</code> can't be used with the parameter <code class="codehilite">sizeofvolume</code>.</p>
<p><strong>Example <code class="codehilite">refinesphere.edp</code></strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;medit&quot;

mesh Th = square(10, 20, [x*pi-pi/2, 2*y*pi]); // $]-pi/2, pi/2[X]0, 2pi[ $

// A parametrization of a sphere
func f1 = cos(x)*cos(y);
func f2 = cos(x)*sin(y);
func f3 = sin(x);
// Partial derivative of the parametrization DF
func f1x = sin(x)*cos(y);
func f1y = -cos(x)*sin(y);
func f2x = -sin(x)*sin(y);
func f2y = cos(x)*cos(y);
func f3x = cos(x);
func f3y = 0;
// M = DF^t DF
func m11 = f1x^2 + f2x^2 + f3x^2;
func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
func m22 = f1y^2 + f2y^2 + f3y^2;

// Mesh adaptation
func perio = [[4, y], [2, y], [1, x], [3, x]];
real hh = 0.1;
real vv = 1/square(hh);
verbosity = 2;
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
plot(Th, wait=true);

// Construction of the surface of spheres
real Rmin = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

mesh3 Th3 = movemesh23(Th, transfo=[f1min, f2min, f3min]);

// Contruct the volume
real[int] domain = [0., 0., 0., 145, 0.01];
mesh3 Th3sph = tetg(Th3, switch=&quot;paAAQYY&quot;, nbofregions=1, regionlist=domain);

// Refine
int[int] newlabel = [145, 18];
real[int] domainrefine = [0., 0., 0., 145, 0.0001];
mesh3 Th3sphrefine = tetgreconstruction(Th3sph, switch=&quot;raAQ&quot;, reftet=newlabel,
    nbofregions=1, regionlist=domain, sizeofvolume=0.0001);

// Re-Refine
int[int] newlabel2 = [145, 53];
func fsize = 0.01/((1 + 5*sqrt((x-0.5)^2+(y-0.5)^2+(z-0.5)^2))^3);
mesh3 Th3sphrefine2 = tetgreconstruction(Th3sph, switch=&quot;raAQ&quot;, reftet=newlabel2,
    sizeofvolume=fsize);

// Medit
medit(&quot;sphere&quot;, Th3sph);
medit(&quot;isotroperefine&quot;, Th3sphrefine);
medit(&quot;anisotroperefine&quot;, Th3sphrefine2);
</pre></div>
</td></tr></table>

<h3 id="moving-mesh-in-three-dimensions">Moving mesh in three dimensions<a class="headerlink" href="#moving-mesh-in-three-dimensions" title="Permanent link">#</a></h3>
<p>Meshes in three dimensions can be translated, rotated, and deformed using the command line <code class="codehilite">movemesh</code> as in the 2D case (see <a href="#movemesh">section <code class="codehilite">movemesh</code></a>). If <span><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> is tetrahedrized as <span><span class="MathJax_Preview">T_{h}(\Omega)</span><script type="math/tex">T_{h}(\Omega)</script></span>, and <span><span class="MathJax_Preview">\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))</span><script type="math/tex">\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))</script></span> is a displacement vector then <span><span class="MathJax_Preview">\Phi(T_{h})</span><script type="math/tex">\Phi(T_{h})</script></span> is obtained by</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>mesh3 Th = movemesh(Th, [$\Phi$1, $\Phi$2, $\Phi$3], ...);
</pre></div>
</td></tr></table>

<p>The parameters of movemesh in three dimensions are:</p>
<ul>
<li>
<p><code class="codehilite">region=</code> sets the integer labels of the tetrahedra. 0 by default.</p>
</li>
<li>
<p><code class="codehilite">label=</code> sets the labels of the border faces. This parameter is initialized as the label for the keyword <a href="http://127.0.0.1:8000/documentation/MeshGeneration/#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh"><code class="codehilite">change</code></a>.</p>
</li>
<li>
<p><code class="codehilite">facemerge=</code> An integer expression. When you transform a mesh, some faces can be merged. This parameter equals to one if the merges' faces is considered. Otherwise it equals to zero. By default, this parameter is equal to 1.</p>
</li>
<li>
<p><code class="codehilite">ptmerge =</code> A real expression. When you transform a mesh, some points can be merged. This parameter is the criteria to define two merging points.
    By default, we use
    <script type="math/tex; mode=display">
    ptmerge \: = \: 1e-7 \: \:Vol( B ),
    </script>
    where <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is the smallest axis parallel boxes containing the discretion domain of <span><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> and <span><span class="MathJax_Preview">Vol(B)</span><script type="math/tex">Vol(B)</script></span> is the volume of this box.</p>
</li>
<li>
<p><code class="codehilite">orientation =</code> An integer expression (1 by default), to reverse or not to reverse the orientation of the tetrahedra if it is not positive.</p>
</li>
</ul>
<p>An example of this command can be found in the <a href="../examples/#poissons-equation-3d">Poisson's equation 3D example</a>.</p>
<h3 id="layer-mesh">Layer mesh<a class="headerlink" href="#layer-mesh" title="Permanent link">#</a></h3>
<p>In this section, we present the command line to obtain a Layer mesh: <code class="codehilite">buildlayers</code>. This mesh is obtained by extending a two dimensional mesh in the <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-axis.</p>
<p>The domain <span><span class="MathJax_Preview">\Omega_{3d}</span><script type="math/tex">\Omega_{3d}</script></span> defined by the layer mesh is equal to <span><span class="MathJax_Preview">\Omega_{3d} = \Omega_{2d} \times [zmin, zmax]</span><script type="math/tex">\Omega_{3d} = \Omega_{2d} \times [zmin, zmax]</script></span> where <span><span class="MathJax_Preview">\Omega_{2d}</span><script type="math/tex">\Omega_{2d}</script></span> is the domain defined by the two dimensional meshes. <span><span class="MathJax_Preview">zmin</span><script type="math/tex">zmin</script></span> and <span><span class="MathJax_Preview">zmax</span><script type="math/tex">zmax</script></span> are functions of <span><span class="MathJax_Preview">\Omega_{2d}</span><script type="math/tex">\Omega_{2d}</script></span> in <span><span class="MathJax_Preview">\R</span><script type="math/tex">\R</script></span> that defines respectively the lower surface and upper surface of <span><span class="MathJax_Preview">\Omega_{3d}</span><script type="math/tex">\Omega_{3d}</script></span>.</p>
<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig35">Fig. 35</a>: Example of Layer mesh in three dimensions.</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Layer Mesh 3D" src="../images/MeshGeneration_LayerMesh.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
<p>For a vertex of a two dimensional mesh <span><span class="MathJax_Preview">V_{i}^{2d} = (x_{i},y_{i})</span><script type="math/tex">V_{i}^{2d} = (x_{i},y_{i})</script></span>, we introduce the number of associated vertices in the <span><span class="MathJax_Preview">z-</span><script type="math/tex">z-</script></span>axis <span><span class="MathJax_Preview">M_{i}+1</span><script type="math/tex">M_{i}+1</script></span>.</p>
<p>We denote by <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> the maximum of <span><span class="MathJax_Preview">M_{i}</span><script type="math/tex">M_{i}</script></span> over the vertices of the two dimensional mesh. This value is called the number of layers (if <span><span class="MathJax_Preview">\forall i, \; M_{i}=M</span><script type="math/tex">\forall i, \; M_{i}=M</script></span> then there are <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> layers in the mesh of <span><span class="MathJax_Preview">\Omega_{3d}</span><script type="math/tex">\Omega_{3d}</script></span>). <span><span class="MathJax_Preview">V_{i}^{2d}</span><script type="math/tex">V_{i}^{2d}</script></span> generated <span><span class="MathJax_Preview">M+1</span><script type="math/tex">M+1</script></span> vertices which are defined by :</p>
<div>
<div class="MathJax_Preview">
\forall j=0, \ldots, M, \qquad V_{i,j}^{3d} = ( x_{i}, y_{i}, \theta_{i}(z_{i,j}) ),
</div>
<script type="math/tex; mode=display">
\forall j=0, \ldots, M, \qquad V_{i,j}^{3d} = ( x_{i}, y_{i}, \theta_{i}(z_{i,j}) ),
</script>
</div>
<p>where <span><span class="MathJax_Preview">(z_{i,j})_{j=0,\ldots,M}</span><script type="math/tex">(z_{i,j})_{j=0,\ldots,M}</script></span> are the <span><span class="MathJax_Preview">M+1</span><script type="math/tex">M+1</script></span> equidistant points on the interval <span><span class="MathJax_Preview">[zmin( V_{i}^{2d} ), zmax( V_{i}^{2d})]</span><script type="math/tex">[zmin( V_{i}^{2d} ), zmax( V_{i}^{2d})]</script></span>:</p>
<div>
<div class="MathJax_Preview">\begin{eqnarray*}
z_{i,j} = j \: \delta \alpha + zmin(V_{i}^{2d}), \qquad \delta \alpha= \frac{ zmax( V_{i}^{2d} ) - zmin( V_{i}^{2d}) }{M}.
\end{eqnarray*}</div>
<script type="math/tex; mode=display">\begin{eqnarray*}
z_{i,j} = j \: \delta \alpha + zmin(V_{i}^{2d}), \qquad \delta \alpha= \frac{ zmax( V_{i}^{2d} ) - zmin( V_{i}^{2d}) }{M}.
\end{eqnarray*}</script>
</div>
<p>The function <span><span class="MathJax_Preview">\theta_{i}</span><script type="math/tex">\theta_{i}</script></span>, defined on <span><span class="MathJax_Preview">[zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]</span><script type="math/tex">[zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]</script></span>, is given by :</p>
<div>
<div class="MathJax_Preview">
\theta_{i}(z) = \left \{
\begin{array}{cl}
\theta_{i,0} &amp; \mbox{if} \: z=zmin(V_{i}^{2d}), \\
\theta_{i,j} &amp; \mbox{if} \: z \in ] \theta_{i,j-1}, \theta_{i,j}],\\
\end{array}
\right.
</div>
<script type="math/tex; mode=display">
\theta_{i}(z) = \left \{
\begin{array}{cl}
\theta_{i,0} & \mbox{if} \: z=zmin(V_{i}^{2d}), \\
\theta_{i,j} & \mbox{if} \: z \in ] \theta_{i,j-1}, \theta_{i,j}],\\
\end{array}
\right.
</script>
</div>
<p>with <span><span class="MathJax_Preview">(\theta_{i,j})_{j=0,\ldots,M_{i}}</span><script type="math/tex">(\theta_{i,j})_{j=0,\ldots,M_{i}}</script></span> are the <span><span class="MathJax_Preview">M_{i}+1</span><script type="math/tex">M_{i}+1</script></span> equidistant points on the interval <span><span class="MathJax_Preview">[zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]</span><script type="math/tex">[zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]</script></span>.</p>
<p>Set a triangle <span><span class="MathJax_Preview">K=(V_{i1}^{2d}</span><script type="math/tex">K=(V_{i1}^{2d}</script></span>, <span><span class="MathJax_Preview">V_{i2}^{2d}</span><script type="math/tex">V_{i2}^{2d}</script></span>, <span><span class="MathJax_Preview">V_{i3}^{2d})</span><script type="math/tex">V_{i3}^{2d})</script></span> of the two dimensional mesh. <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> is associated with a triangle on the upper surface (resp. on the lower surface) of layer mesh:</p>
<p><span><span class="MathJax_Preview">( V_{i1,M}^{3d}, V_{i2,M}^{3d}, V_{i3,M}^{3d} )</span><script type="math/tex">( V_{i1,M}^{3d}, V_{i2,M}^{3d}, V_{i3,M}^{3d} )</script></span> (resp. <span><span class="MathJax_Preview">( V_{i1,0}^{3d}, V_{i2,0}^{3d}, V_{i3,0}^{3d})</span><script type="math/tex">( V_{i1,0}^{3d}, V_{i2,0}^{3d}, V_{i3,0}^{3d})</script></span>).</p>
<p>Also <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> is associated with <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> volume prismatic elements which are defined by :</p>
<div>
<div class="MathJax_Preview">
\forall j=0,\ldots,M, \quad H_{j} = ( V_{i1,j}^{3d}, V_{i2,j}^{3d}, V_{i3,j}^{3d}, V_{i1,j+1}^{3d}, V_{i2,j+1}^{3d}, V_{i3,j+1}^{3d} ).
</div>
<script type="math/tex; mode=display">
\forall j=0,\ldots,M, \quad H_{j} = ( V_{i1,j}^{3d}, V_{i2,j}^{3d}, V_{i3,j}^{3d}, V_{i1,j+1}^{3d}, V_{i2,j+1}^{3d}, V_{i3,j+1}^{3d} ).
</script>
</div>
<p>Theses volume elements can have some merged point:</p>
<ul>
<li>0 merged point : prism</li>
<li>1 merged points : pyramid</li>
<li>2 merged points : tetrahedra</li>
<li>3 merged points : no elements</li>
</ul>
<p>The elements with merged points are called degenerate elements. To obtain a mesh with tetrahedra, we decompose the pyramid into two tetrahedra and the prism into three tetrahedra. These tetrahedra are obtained by cutting the quadrilateral face of pyramid and prism with the diagonal which have the vertex with the maximum index (see <a href="#refHecht1992">Hecht1992</a>} for the reason of this choice).</p>
<p>The triangles on the middle surface obtained with the decomposition of the volume prismatic elements are the triangles generated by the edges on the border of the two dimensional mesh. The label of triangles on the border elements and tetrahedra are defined with the label of these associated elements.</p>
<p>The arguments of <code class="codehilite">buildlayers</code> is a two dimensional mesh and the number of layers <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span>.</p>
<p>The parameters of this command are:</p>
<ul>
<li>
<p><code class="codehilite">zbound=</code> <span><span class="MathJax_Preview">[zmin,zmax]</span><script type="math/tex">[zmin,zmax]</script></span> where <span><span class="MathJax_Preview">zmin</span><script type="math/tex">zmin</script></span> and <span><span class="MathJax_Preview">zmax</span><script type="math/tex">zmax</script></span> are functions expression. Theses functions define the lower surface mesh and upper mesh of surface mesh.</p>
</li>
<li>
<p><code class="codehilite">coef=</code> A function expression between [0,1]. This parameter is used to introduce degenerate element in mesh.</p>
<p>The number of associated points or vertex <span><span class="MathJax_Preview">V_{i}^{2d}</span><script type="math/tex">V_{i}^{2d}</script></span> is the integer part of <span><span class="MathJax_Preview">coef(V_{i}^{2d}) M</span><script type="math/tex">coef(V_{i}^{2d}) M</script></span>.</p>
</li>
<li>
<p><code class="codehilite">region=</code> This vector is used to initialize the region of tetrahedra.</p>
<p>This vector contains successive pairs of the 2d region number at index <span><span class="MathJax_Preview">2i</span><script type="math/tex">2i</script></span> and the corresponding 3d region number at index <span><span class="MathJax_Preview">2i+1</span><script type="math/tex">2i+1</script></span>, like <a href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh"><code class="codehilite">change</code></a>.</p>
</li>
<li>
<p><code class="codehilite">labelmid=</code> This vector is used to initialize the 3d labels number of the vertical face or mid face from the 2d label number.</p>
<p>This vector contains successive pairs of the 2d label number at index <span><span class="MathJax_Preview">2i</span><script type="math/tex">2i</script></span> and the corresponding 3d label number at index <span><span class="MathJax_Preview">2i+1</span><script type="math/tex">2i+1</script></span>, like <a href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh"><code class="codehilite">change</code></a>.</p>
</li>
<li>
<p><code class="codehilite">labelup=</code> This vector is used to initialize the 3d label numbers of the upper/top face from the 2d region number.</p>
<p>This vector contains successive pairs of the 2d region number at index <span><span class="MathJax_Preview">2i</span><script type="math/tex">2i</script></span> and the corresponding 3d label number at index <span><span class="MathJax_Preview">2i+1</span><script type="math/tex">2i+1</script></span>, like <a href="#how-to-change-the-label-of-elements-and-border-elements-of-a-mesh"><code class="codehilite">change</code></a>.</p>
</li>
<li>
<p><code class="codehilite">labeldown=</code> Same as the previous case but for the lower/down face label.</p>
</li>
</ul>
<p>Moreover, we also add post processing parameters that allow to moving the mesh. These parameters correspond to parameters <code class="codehilite">transfo</code>, <code class="codehilite">facemerge</code> and <code class="codehilite">ptmerge</code> of the command line <code class="codehilite">movemesh</code>.</p>
<p>The vector <code class="codehilite">region</code>, <code class="codehilite">labelmid</code>, <code class="codehilite">labelup</code> and <code class="codehilite">labeldown</code> These vectors are composed of <span><span class="MathJax_Preview">n_{l}</span><script type="math/tex">n_{l}</script></span> successive pairs of number <span><span class="MathJax_Preview">O_i,N_l</span><script type="math/tex">O_i,N_l</script></span> where <span><span class="MathJax_Preview">n_{l}</span><script type="math/tex">n_{l}</script></span> is the number (label or region) that we want to get.</p>
<p>An example of this command is given in the <a href="../examples/#example-build-layer-mesh">Build layer mesh example</a>.</p>
<div class="admonition example">
<p class="admonition-title">Cube</p>
<p><code>Cube.idp</code>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;medit&quot;
load &quot;msh3&quot;

func mesh3 Cube (int[int] &amp;NN, real[int, int] &amp;BB, int[int, int] &amp;L){
    real x0 = BB(0,0), x1 = BB(0,1);
    real y0 = BB(1,0), y1 = BB(1,1);
    real z0 = BB(2,0), z1 = BB(2,1);

    int nx = NN[0], ny = NN[1], nz = NN[2];

    // 2D mesh
    mesh Thx = square(nx, ny, [x0+(x1-x0)*x, y0+(y1-y0)*y]);

    // 3D mesh
    int[int] rup = [0, L(2,1)], rdown=[0, L(2,0)];
    int[int] rmid=[1, L(1,0), 2, L(0,1), 3, L(1,1), 4, L(0,0)];
    mesh3 Th = buildlayers(Thx, nz, zbound=[z0,z1],
        labelmid=rmid, labelup = rup, labeldown = rdown);

    return Th;
}
</pre></div>
</td></tr></table></p>
</div>
<div class="admonition example">
<p class="admonition-title">Unit cube</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>include &quot;Cube.idp&quot;

int[int] NN = [10,10,10]; //the number of step in each direction
real [int, int] BB = [[0,1],[0,1],[0,1]]; //the bounding box
int [int, int] L = [[1,2],[3,4],[5,6]]; //the label of the 6 face left,right, front, back, down, right
mesh3 Th = Cube(NN, BB, L);
medit(&quot;Th&quot;, Th);
</pre></div>
</td></tr></table>

<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig36">Fig. 36</a>: The mesh of a cube made with <code class="codehilite">cube.edp</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Cube" src="../images/MeshGeneration_LayerMesh_Example1.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Cone</p>
<p>An axisymtric mesh on a triangle with degenerateness
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;medit&quot;

// Parameters
real RR = 1;
real HH = 1;

int nn=10;

// 2D mesh
border Taxe(t=0, HH){x=t; y=0; label=0;}
border Hypo(t=1, 0){x=HH*t; y=RR*t; label=1;}
border Vert(t=0, RR){x=HH; y=t; label=2;}
mesh Th2 = buildmesh(Taxe(HH*nn) + Hypo(sqrt(HH*HH+RR*RR)*nn) + Vert(RR*nn));
plot(Th2, wait=true);

// 3D mesh
real h = 1./nn;
int MaxLayersT = (int(2*pi*RR/h)/4)*4;//number of layers
real zminT = 0;
real zmaxT = 2*pi; //height 2*pi
func fx = y*cos(z);
func fy = y*sin(z);
func fz = x;
int[int] r1T = [0,0], r2T = [0,0,2,2], r4T = [0,2];
//trick function:
//The function defined the proportion
//of number layer close to axis with reference MaxLayersT
func deg = max(.01, y/max(x/HH, 0.4)/RR);
mesh3 Th3T = buildlayers(Th2, coef=deg, MaxLayersT,
    zbound=[zminT, zmaxT], transfo=[fx, fy, fz],
    facemerge=0, region=r1T, labelmid=r2T);
medit(&quot;cone&quot;, Th3T);
</pre></div>
</td></tr></table></p>
<p><center></p>
<table>
<thead>
<tr>
<th align="center"><a name="Fig37">Fig. 37</a>: the mesh of a cone made with <code class="codehilite">cone.edp</code></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Cone" src="../images/MeshGeneration_LayerMesh_Example2.png" /></td>
</tr>
</tbody>
</table>
<p></center></p>
</div>
<div class="admonition example">
<p class="admonition-title">Buildlayer mesh</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;medit&quot;

// Parameters
int C1 = 99;
int C2 = 98;

// 2D mesh
border C01(t=0, pi){x=t; y=0; label=1;}
border C02(t=0, 2*pi){ x=pi; y=t; label=1;}
border C03(t=0, pi){ x=pi-t; y=2*pi; label=1;}
border C04(t=0, 2*pi){ x=0; y=2*pi-t; label=1;}

border C11(t=0, 0.7){x=0.5+t; y=2.5; label=C1;}
border C12(t=0, 2){x=1.2; y=2.5+t; label=C1;}
border C13(t=0, 0.7){x=1.2-t; y=4.5; label=C1;}
border C14(t=0, 2){x=0.5; y=4.5-t; label=C1;}

border C21(t=0, 0.7){x=2.3+t; y=2.5; label=C2;}
border C22(t=0, 2){x=3; y=2.5+t; label=C2;}
border C23(t=0, 0.7){x=3-t; y=4.5; label=C2;}
border C24(t=0, 2){x=2.3; y=4.5-t; label=C2;}

mesh Th = buildmesh(C01(10) + C02(10) + C03(10) + C04(10)
    + C11(5) + C12(5) + C13(5) + C14(5)
    + C21(-5) + C22(-5) + C23(-5) + C24(-5));

mesh Ths = buildmesh(C01(10) + C02(10) + C03(10) + C04(10)
    + C11(5) + C12(5) + C13(5) + C14(5));

// Construction of a box with one hole and two regions
func zmin = 0.;
func zmax = 1.;
int MaxLayer = 10;

func XX = x*cos(y);
func YY = x*sin(y);
func ZZ = z;

int[int] r1 = [0, 41], r2 = [98, 98, 99, 99, 1, 56];
int[int] r3 = [4, 12];//the triangles of uppper surface mesh
                      //generated by the triangle in the 2D region
                      //of mesh Th of label 4 as label 12
int[int] r4 = [4, 45];//the triangles of lower surface mesh
                      //generated by the triangle in the 2D region
                      //of mesh Th of label 4 as label 45.

mesh3 Th3 = buildlayers(Th, MaxLayer, zbound=[zmin, zmax], region=r1,
    labelmid=r2, labelup=r3, labeldown=r4);
medit(&quot;box 2 regions 1 hole&quot;, Th3);

// Construction of a sphere with TetGen
func XX1 = cos(y)*sin(x);
func YY1 = sin(y)*sin(x);
func ZZ1 = cos(x);

real[int] domain = [0., 0., 0., 0, 0.001];
string test = &quot;paACQ&quot;;
cout &lt;&lt; &quot;test = &quot; &lt;&lt; test &lt;&lt; endl;
mesh3 Th3sph = tetgtransfo(Ths, transfo=[XX1, YY1, ZZ1],
    switch=test, nbofregions=1, regionlist=domain);
medit(&quot;sphere 2 regions&quot;, Th3sph);
</pre></div>
</td></tr></table>

</div>
<h2 id="meshing-examples_1">Meshing examples<a class="headerlink" href="#meshing-examples_1" title="Permanent link">#</a></h2>
<div class="admonition example">
<p class="admonition-title">lake</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;medit&quot;

// Parameters
int nn = 5;

// 2D mesh
border cc(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
mesh Th2 = buildmesh(cc(100));

// 3D mesh
int[int] rup = [0, 2], rlow = [0, 1];
int[int] rmid = [1, 1, 2, 1, 3, 1, 4, 1];
func zmin = 2-sqrt(4-(x*x+y*y));
func zmax = 2-sqrt(3.);

mesh3 Th = buildlayers(Th2, nn,
    coef=max((zmax-zmin)/zmax, 1./nn),
    zbound=[zmin,zmax],
    labelmid=rmid,
    labelup=rup,
    labeldown=rlow);

medit(&quot;Th&quot;, Th);
</pre></div>
</td></tr></table>

</div>
<div class="admonition example">
<p class="admonition-title">Hole region</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;medit&quot;

// 2D mesh
mesh Th = square(10, 20, [x*pi-pi/2, 2*y*pi]); // ]-pi/2, pi/2[X]0,2pi[

// 3D mesh
//parametrization of a sphere
func f1 = cos(x)*cos(y);
func f2 = cos(x)*sin(y);
func f3 = sin(x);
//partial derivative of the parametrization
func f1x = sin(x)*cos(y);
func f1y = -cos(x)*sin(y);
func f2x = -sin(x)*sin(y);
func f2y = cos(x)*cos(y);
func f3x = cos(x);
func f3y = 0;
//M = DF^t DF
func m11 = f1x^2 + f2x^2 + f3x^2;
func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
func m22 = f1y^2 + f2y^2 + f3y^2;

func perio = [[4, y], [2, y], [1, x], [3, x]];
real hh = 0.1;
real vv = 1/square(hh);
verbosity = 2;
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
plot(Th, wait=true);

//construction of the surface of spheres
real Rmin = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

mesh3 Th3sph = movemesh23(Th, transfo=[f1min, f2min, f3min]);

real Rmax = 2.;
func f1max = Rmax*f1;
func f2max = Rmax*f2;
func f3max = Rmax*f3;

mesh3 Th3sph2 = movemesh23(Th, transfo=[f1max, f2max, f3max]);

//gluing meshse
mesh3 Th3 = Th3sph + Th3sph2;

cout &lt;&lt; &quot; TetGen call without hole &quot; &lt;&lt; endl;
real[int] domain2 = [1.5, 0., 0., 145, 0.001, 0.5, 0., 0., 18, 0.001];
mesh3 Th3fin = tetg(Th3, switch=&quot;paAAQYY&quot;, nbofregions=2, regionlist=domain2);
medit(&quot;Sphere with two regions&quot;, Th3fin);

cout &lt;&lt; &quot; TetGen call with hole &quot; &lt;&lt; endl;
real[int] hole = [0.,0.,0.];
real[int] domain = [1.5, 0., 0., 53, 0.001];
mesh3 Th3finhole = tetg(Th3, switch=&quot;paAAQYY&quot;,
    nbofholes=1, holelist=hole, nbofregions=1, regionlist=domain);
medit(&quot;Sphere with a hole&quot;, Th3finhole);
</pre></div>
</td></tr></table>

</div>
<h3 id="build-a-3d-mesh-of-a-cube-with-a-balloon">Build a 3d mesh of a cube with a balloon<a class="headerlink" href="#build-a-3d-mesh-of-a-cube-with-a-balloon" title="Permanent link">#</a></h3>
<p>First the <code>MeshSurface.idp</code> file to build boundary mesh of a Hexaedra and of a Sphere:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>func mesh3 SurfaceHex (int[int] &amp;N, real[int, int] &amp;B, int[int, int] &amp;L, int orientation){
    real x0 = B(0, 0), x1 = B(0, 1);
    real y0 = B(1, 0), y1 = B(1, 1);
    real z0 = B(2, 0), z1 = B(2, 1);

    int nx = N[0], ny = N[1], nz = N[2];

    mesh Thx = square(ny, nz, [y0+(y1-y0)*x, z0+(z1-z0)*y]);
    mesh Thy = square(nx, nz, [x0+(x1-x0)*x, z0+(z1-z0)*y]);
    mesh Thz = square(nx, ny, [x0+(x1-x0)*x, y0+(y1-y0)*y]);

    int[int] refx = [0, L(0,0)], refX = [0, L(0,1)]; //Xmin, Ymax faces labels renumbering
    int[int] refy = [0, L(1,0)], refY = [0, L(1,1)]; //Ymin, Ymax faces labesl renumbering
    int[int] refz = [0, L(2,0)], refZ = [0, L(2,1)]; //Zmin, Zmax faces labels renumbering

    mesh3 Thx0 = movemesh23(Thx, transfo=[x0, x, y], orientation=-orientation, label=refx);
    mesh3 Thx1 = movemesh23(Thx, transfo=[x1, x, y], orientation=+orientation, label=refX);
    mesh3 Thy0 = movemesh23(Thy, transfo=[x, y0, y], orientation=+orientation, label=refy);
    mesh3 Thy1 = movemesh23(Thy, transfo=[x, y1, y], orientation=-orientation, label=refY);
    mesh3 Thz0 = movemesh23(Thz, transfo=[x, y, z0], orientation=-orientation, label=refz);
    mesh3 Thz1 = movemesh23(Thz, transfo=[x, y, z1], orientation=+orientation, label=refZ);
    mesh3 Th = Thx0 + Thx1 + Thy0 + Thy1 + Thz0 + Thz1;

    return Th;
}

func mesh3 Sphere (real R, real h, int L, int orientation){
    mesh Th=square(10, 20, [x*pi-pi/2, 2*y*pi]); //]-pi/2, pi/2[X]0,2pi[

    func f1 = cos(x)*cos(y);
    func f2 = cos(x)*sin(y);
    func f3 = sin(x);

    func f1x = sin(x)*cos(y);
    func f1y = -cos(x)*sin(y);
    func f2x = -sin(x)*sin(y);
    func f2y = cos(x)*cos(y);
    func f3x = cos(x);
    func f3y = 0;

    func m11 = f1x^2 + f2x^2 + f3x^2;
    func m21 = f1x*f1y + f2x*f2y + f3x*f3y;
    func m22 = f1y^2 + f2y^2 + f3y^2;

    func perio = [[4, y], [2, y], [1, x], [3, x]]; //to store the periodic condition

    real hh = h/R; //hh mesh size on unite sphere
    real vv = 1/square(hh);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    Th = adaptmesh(Th, m11*vv, m21*vv, m22*vv, IsMetric=1, periodic=perio);
    int[int] ref = [0, L];

    mesh3 ThS = movemesh23(Th, transfo=[f1*R, f2*R, f3*R], orientation=orientation, refface=ref);

    return ThS;
}
</pre></div>
</td></tr></table>

<p>The test of the two functions and the call to <code class="codehilite">TetGen</code> mesh generator:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;medit&quot;
include &quot;MeshSurface.idp&quot;

// Parameters
real hs = 0.1; //mesh size on sphere
int[int] N = [20, 20, 20];
real [int,int] B = [[-1, 1], [-1, 1], [-1, 1]];
int [int,int] L = [[1, 2], [3, 4], [5, 6]];

// Mesh
mesh3 ThH = SurfaceHex(N, B, L, 1);
mesh3 ThS = Sphere(0.5, hs, 7, 1);

mesh3 ThHS = ThH + ThS;
medit(&quot;Hex-Sphere&quot;, ThHS);

real voltet = (hs^3)/6.;
cout &lt;&lt; &quot;voltet = &quot; &lt;&lt; voltet &lt;&lt; endl;
real[int] domain = [0, 0, 0, 1, voltet, 0, 0, 0.7, 2, voltet];
mesh3 Th = tetg(ThHS, switch=&quot;pqaAAYYQ&quot;, nbofregions=2, regionlist=domain);
medit(&quot;Cube with ball&quot;, Th);
</pre></div>
</td></tr></table>

<table>
<thead>
<tr>
<th align="center"><a name="Fig38">Fig. 38</a>: The surface mesh of the Hex with internal Sphere</th>
<th align="center"><a name="Fig39">Fig. 39</a>: The tetrahedral mesh of the cube with internal ball</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="Hex Sphere" src="../images/MeshGeneration_CubeSphere1.png" /></td>
<td align="center"><img alt="Cube with ball" src="../images/MeshGeneration_CubeSphere2.png" /></td>
</tr>
</tbody>
</table>
<h2 id="medit">Medit<a class="headerlink" href="#medit" title="Permanent link">#</a></h2>
<p>The keyword <code class="codehilite">medit</code> allows to display a mesh alone or a mesh and one or several functions defined on the mesh using the Pascal Frey's freeware <code>medit</code>. <code>medit</code> opens its own window and uses OpenGL extensively. Naturally to use this command <code>medit</code> must be installed.</p>
<p>A vizualisation with <code class="codehilite">medit</code> of scalar solutions <span><span class="MathJax_Preview">f1</span><script type="math/tex">f1</script></span> and <span><span class="MathJax_Preview">f2</span><script type="math/tex">f2</script></span> continuous, piecewise linear and known at the vertices of the mesh Th is obtained using :</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>medit(&quot;sol1 sol2&quot;, Th, f1, f2, order=1);
</pre></div>
</td></tr></table>

<p>The first plot named <code class="codehilite">sol1</code> display f1. The second plot names <code class="codehilite">sol2</code> display f2.</p>
<p>The arguments of the function <code class="codehilite">medit</code> are the name of the differents scenes (separated by a space) of <code class="codehilite">medit</code>, a mesh and solutions.</p>
<p>Each solution is associated with one scene. The scalar, vector and symmetric tensor solutions are specified in the format described in the section dealing with the keyword <code class="codehilite">savesol</code>.</p>
<p>The parameters of this command line are :</p>
<ul>
<li>
<p><code class="codehilite">order=</code> 0 if the solution is given at the center of gravity of elements. 1 is the solution is given at the vertices of elements.</p>
</li>
<li>
<p><code class="codehilite">meditff=</code> set the name of execute command of medit. By default, this string is medit.</p>
</li>
<li>
<p><code class="codehilite">save=</code> set the name of a file <code class="codehilite">.sol</code> or <code class="codehilite">.solb</code> to save solutions.</p>
</li>
</ul>
<p>This command line allows also to represent two differents meshes and solutions on them in the same windows. The nature of solutions must be the same. Hence, we can vizualize in the same window the different domains in a domain decomposition method for instance. A vizualisation with medit of scalar solutions <span><span class="MathJax_Preview">h1</span><script type="math/tex">h1</script></span> and <span><span class="MathJax_Preview">h2</span><script type="math/tex">h2</script></span> at vertices of the mesh Th1 and Th2 respectively are obtained using :</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>medit(&quot;sol2domain&quot;, Th1, h1, Th2, h2, order=1);
</pre></div>
</td></tr></table>

<div class="admonition example">
<p class="admonition-title"><code class="codehilite">medit</code></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;medit&quot;

// Initial Problem:
// Resolution of the following EDP:
// -Delta u_s = f on \Omega = { (x,y) | 1 &lt;= sqrt(x^2+y^2) &lt;= 2 }
// -Delta u_1 = f1 on \Omega_1 = { (x,y) | 0.5 &lt;= sqrt(x^2+y^2) &lt;= 1. }
// u = 1 on Gamma
// Null Neumman condition on Gamma_1 and on Gamma_2
// We find the solution u by solving two EDP defined on domain Omega and Omega_1
// This solution is visualize with medit

verbosity=3;

// Mesh
border Gamma(t=0, 2*pi){x=cos(t); y=sin(t); label=1;};
border Gamma1(t=0, 2*pi){x=2*cos(t); y=2*sin(t); label=2;};
border Gamma2(t=0, 2*pi){x=0.5*cos(t); y=0.5*sin(t); label=3;};

mesh Th = buildmesh(Gamma1(40) + Gamma(-40)); //Omega
mesh Th1 = buildmesh(Gamma(40) + Gamma2(-40)); //Omega_1

// Fespace
fespace Vh(Th, P2);
func f = sqrt(x*x + y*y);
Vh us, v;

fespace Vh1(Th1, P2);
func f1 = 10*sqrt(x*x+y*y);
Vh1 u1, v1;

// Macro
macro Grad2(us) [dx(us), dy(us)] // EOM

// Problem
problem Lap2dOmega (us, v, init=false)
    = int2d(Th)(
          Grad2(v)&#39; * Grad2(us)
    )
    - int2d(Th)(
          f*v
    )
    +on(1, us=1)
    ;

problem Lap2dOmega1 (u1, v1, init=false)
    = int2d(Th1)(
          Grad2(v1)&#39; * Grad2(u1)
    )
    - int2d(Th1)(
          f1*v1
    )
    + on(1, u1=1)
    ;

// Solve
Lap2dOmega;
Lap2dOmega1;

// Plot with medit
medit(&quot;solution&quot;, Th, us, Th1, u1, order=1, save=&quot;testsavemedit.solb&quot;);
</pre></div>
</td></tr></table>

</div>
<h2 id="mshmet">Mshmet<a class="headerlink" href="#mshmet" title="Permanent link">#</a></h2>
<p>Mshmet is a software developed by P. Frey that allows to compute an anisotropic metric based on solutions (i.e. Hessian-based). This software can return also an isotropic metric. Moreover, <code>mshmet</code> can also construct a metric suitable for levelset interface capturing. The solution can be defined on 2D or 3D structured/unstructured meshes. For example, the solution can be an error estimate of a FE solution.</p>
<p>Solutions for <code class="codehilite">mshmet</code> are given as an argument. The solution can be a <code class="codehilite">func</code>, a vector <code class="codehilite">func</code>, a symmetric tensor, a <code class="codehilite">fespace</code> function, a <code class="codehilite">fespace</code> vector function and a <code class="codehilite">fespace</code> symmetric tensor. The symmetric tensor argument is defined as this type of data for datasol argument. This software accepts more than one solution.</p>
<p>For example, the metric <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> computed with <code class="codehilite">mshmet</code> for the solution <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> defined on the mesh <span><span class="MathJax_Preview">Th</span><script type="math/tex">Th</script></span> is obtained by writing :</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>fespace Vh(Th, P1);
Vh u; //a scalar fespace function
real[int] M = mshmet(Th, u);
</pre></div>
</td></tr></table>

<p>The parameters of the keyword <code class="codehilite">mshmet</code> are :</p>
<ul>
<li><code class="codehilite">normalization =</code> (b) do a normalization of all solution in <span><span class="MathJax_Preview">[0,1]</span><script type="math/tex">[0,1]</script></span>.</li>
<li><code class="codehilite">aniso =</code> (b) build anisotropic metric if 1 (default 0: isotropic)</li>
<li><code class="codehilite">levelset =</code> (b) build metric for levelset method (default: <code class="codehilite">false</code>)</li>
<li><code class="codehilite">verbosity =</code> (l) level of verbosity</li>
<li><code class="codehilite">nbregul =</code> (l) number of regularization's iteration of solutions given (default 0).</li>
<li><code class="codehilite">hmin =</code> (d)</li>
<li><code class="codehilite">hmax =</code> (d)</li>
<li><code class="codehilite">err =</code> (d) level of error.</li>
<li><code class="codehilite">width =</code> (d) the width</li>
<li><code class="codehilite">metric =</code> a vector of double. This vector contains an initial metric given to <code class="codehilite">mshmet</code>. The structure of the metric vector is described in the next paragraph.</li>
<li>
<p><code class="codehilite">loptions =</code> a vector of integer of size 7. This vector contains the integer parameters of <code class="codehilite">mshmet</code> (for expert only).</p>
<ul>
<li>loptions(0): normalization (default 1).</li>
<li>loptions(1): isotropic parameters (default 0). 1 for isotropic metric results otherwise 0.</li>
<li>loptions(2): level set parameters (default 0). 1 for building level set metric otherwise 0.</li>
<li>loptions(3): debug parameters (default 0). 1 for turning on debug mode otherwise 0.</li>
<li>loptions(4): level of verbosity (default 10).</li>
<li>loptions(5): number of regularization's iteration of solutions given (default 0).</li>
<li>loptions(6): previously metric parameter (default 0). 1 for using previous metric otherwise 0.</li>
</ul>
</li>
<li>
<p><code class="codehilite">doptions=</code> a vector of double of size 4. This vector contains the real parameters of <code class="codehilite">mshmet</code> (for expert only).</p>
<ul>
<li>doptions(0): hmin : min size parameters (default 0.01).</li>
<li>doptions(1): hmax : max size parameters (default 1.0).</li>
<li>doptions(2): eps : tolerance parameters (default 0.01).</li>
<li>doptions(2): width : relative width for Level Set (<span><span class="MathJax_Preview">0&lt;w&lt;1</span><script type="math/tex">0<w<1</script></span>) (default 0.05).</li>
</ul>
</li>
</ul>
<p>The result of the keyword <code class="codehilite">mshmet</code> is a <code class="codehilite">real[int]</code> which contains the metric computed by <code class="codehilite">mshmet</code> at the different vertices <span><span class="MathJax_Preview">V_{i}</span><script type="math/tex">V_{i}</script></span> of the mesh.</p>
<p>With <span><span class="MathJax_Preview">nv</span><script type="math/tex">nv</script></span> is the number of vertices, the structure of this vector is
<script type="math/tex; mode=display"> M_{iso}= (m(V_0), m(V_1), \ldots, m(V_{nv}))^t</script>
for a isotropic metric <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>. For a symmetric tensor metric
<span><span class="MathJax_Preview">h=\left(\begin{array}{ccc}
m_{1 1} &amp; m_{1 2} &amp; m_{1 3}\\
m_{2 1} &amp; m_{2 2} &amp; m_{2 3} \\
m_{3 1} &amp; m_{3 2} &amp; m_{3 3}
\end{array}\right)</span><script type="math/tex">h=\left(\begin{array}{ccc}
m_{1 1} & m_{1 2} & m_{1 3}\\
m_{2 1} & m_{2 2} & m_{2 3} \\
m_{3 1} & m_{3 2} & m_{3 3}
\end{array}\right)</script></span>
, the parameters <code class="codehilite">metric</code> is : <script type="math/tex; mode=display">M_{aniso}= (H(V_{0}), \ldots, H(V_{nv}) )^t </script> where <span><span class="MathJax_Preview">H(V_{i})</span><script type="math/tex">H(V_{i})</script></span> is the vector of size 6 defined by <span><span class="MathJax_Preview">[m11,m21,m22,m31,m32,m33]</span><script type="math/tex">[m11,m21,m22,m31,m32,m33]</script></span></p>
<div class="admonition example">
<p class="admonition-title"><code class="codehilite">mshmet</code></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;mshmet&quot;
load &quot;medit&quot;
load &quot;msh3&quot;

// Parameters
real error = 0.01;
func zmin = 0;
func zmax = 1;
int MaxLayer = 10;

// Mesh
border a(t=0, 1.0){x=t; y=0; label=1;};
border b(t=0, 0.5){x=1; y=t; label=2;};
border c(t=0, 0.5){x=1-t; y=0.5; label=3;};
border d(t=0.5, 1){x=0.5; y=t; label=4;};
border e(t=0.5, 1){x=1-t; y=1; label=5;};
border f(t=0.0, 1){x=0; y=1-t; label=6;};
mesh Th = buildmesh(a(6) + b(4) + c(4) + d(4) + e(4) + f(6));
mesh3 Th3 = buildlayers(Th, MaxLayer, zbound=[zmin, zmax]);

// Fespace
fespace Vh3(Th3, P2);
Vh3 u3, v3;

fespace Vh3P1(Th3, P1);
Vh3P1 usol;

// Problem
problem Problem2(u3, v3, solver=sparsesolver)
    = int3d(Th3)(
          u3*v3*1.0e-10
        + dx(u3)*dx(v3)
        + dy(u3)*dy(v3)
        + dz(u3)*dz(v3)
    )
    - int3d(Th3)(
          v3
    )
    +on(0, 1, 2, 3, 4, 5, 6, u3=0)
    ;

// Solve
Problem2;
cout &lt;&lt; u3[].min &lt;&lt; &quot; &quot; &lt;&lt; u3[].max &lt;&lt; endl;

medit(&quot;Sol&quot;, Th3, u3);

real[int] bb = mshmet(Th3,u3);
cout &lt;&lt; &quot;Metric:&quot; &lt;&lt; bb &lt;&lt; endl;
for (int ii = 0; ii &lt; Th3.nv; ii++)
    usol[][ii] = bb[ii];

medit(&quot;Metric&quot;, Th3, usol);
</pre></div>
</td></tr></table>

</div>
<h2 id="freeyams">FreeYams<a class="headerlink" href="#freeyams" title="Permanent link">#</a></h2>
<p>FreeYams is a surface mesh adaptation software which is developed by P. Frey. This software is a new version of yams. The adapted surface mesh is constructed with a geometric metric tensor field. This field is based on the intrinsic properties of the discrete surface.</p>
<p>Also, this software allows to construct a simplification of a mesh. This decimation is based on the Hausdorff distance between the initial and the current triangulation. Compared to the software yams, FreeYams can be used also to produce anisotropic triangulations adapted to levelset simulations. A technical report on freeYams documentation is available <a href="https://www.ljll.math.upmc.fr/frey/publications/RT-0252.pdf">here</a>.</p>
<p>To call FreeYams in FreeFem++, we used the keyword <code class="codehilite">freeyams</code>. The arguments of this function are the initial mesh and/or metric. The metric with <code class="codehilite">freeyams</code> are a <code class="codehilite">func</code>, a <code class="codehilite">fespace</code> function, a symmetric tensor function, a symmetric tensor <code class="codehilite">fespace</code> function or a vector of double (<code class="codehilite">real[int]</code>). If the metric is a vector of double, this data must be given in <code class="codehilite">metric</code> parameter. Otherwise, the metric is given in the argument.</p>
<p>For example, the adapted mesh of <code>Thinit</code> defined by the metric <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> defined as <code class="codehilite">fespace</code> function is obtained by writing:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>fespace Vh(Thinit, P1);
Vh u;
mesh3 Th = freeyams(Thinit, u);
</pre></div>
</td></tr></table>

<p>The symmetric tensor argument for <code class="codehilite">freeyams</code> keyword is defined as this type of data for datasol argument.</p>
<ul>
<li><code class="codehilite">aniso=</code> (b) aniso or iso metric (default 0, iso)</li>
<li><code class="codehilite">mem=</code> (l) memory of for freeyams in Mb (default -1, freeyams choose)</li>
<li><code class="codehilite">hmin=</code> (d)</li>
<li><code class="codehilite">hmax=</code> (d)</li>
<li><code class="codehilite">gradation=</code> (d)</li>
<li><code class="codehilite">option=</code> (l)<ul>
<li>0 : mesh optimization (smoothing+swapping)</li>
<li>1 : decimation+enrichment adaptated to a metric map. (default)</li>
<li>-1 : decimation adaptated to a metric map.</li>
<li>2 : decimation+enrichment with a Hausdorff-like method</li>
<li>-2 : decimation with a Hausdorff-like method</li>
<li>4 : split triangles recursively.</li>
<li>9 : No-Shrinkage Vertex Smoothing</li>
</ul>
</li>
<li><code class="codehilite">ridgeangle=</code> (d)</li>
<li><code class="codehilite">absolute=</code> (b)</li>
<li><code class="codehilite">verbosity=</code> (i)</li>
<li>
<p><code class="codehilite">metric=</code> vector expression. This parameters contains the metric at the different vertices on the initial mesh. With <span><span class="MathJax_Preview">nv</span><script type="math/tex">nv</script></span> is the number of vertices, this vector is <script type="math/tex; mode=display"> M_{iso}= ( m(V_0), m(V_1), \ldots, m(V_{nv}) )^t</script> for a scalar metric <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>. For a symmetric tensor metric
<span><span class="MathJax_Preview">h=\left(\begin{array}{ccc}
m_{1 1} &amp; m_{1 2} &amp; m_{1 3}\\
m_{2 1} &amp; m_{2 2} &amp; m_{2 3} \\
m_{3 1} &amp; m_{3 2} &amp; m_{3 3}
\end{array}\right)</span><script type="math/tex">h=\left(\begin{array}{ccc}
m_{1 1} & m_{1 2} & m_{1 3}\\
m_{2 1} & m_{2 2} & m_{2 3} \\
m_{3 1} & m_{3 2} & m_{3 3}
\end{array}\right)</script></span>
, the parameters <code class="codehilite">metric</code> is
<script type="math/tex; mode=display">M_{aniso}= ( H(V_{0}), \ldots, H(V_{nv}) )^t </script>
where <span><span class="MathJax_Preview">H(V_{i})</span><script type="math/tex">H(V_{i})</script></span> is the vector of size 6 defined by <span><span class="MathJax_Preview">[m11,m21,m22,m31,m32,m33]</span><script type="math/tex">[m11,m21,m22,m31,m32,m33]</script></span></p>
</li>
<li>
<p><code class="codehilite">loptions=</code> a vector of integer of size 13. This vectors contains the integer options of FreeYams. (just for the expert)</p>
<ul>
<li>loptions(0): anisotropic parameter (default 0). If you give an anisotropic metric 1 otherwise 0.</li>
<li>loptions(1): Finite Element correction parameter (default 0). 1 for <em>no</em> Finite Element correction otherwise 0.</li>
<li>loptions(2): Split multiple connected points parameter (default 1). 1 for splitting multiple connected points otherwise 0.</li>
<li>loptions(3): maximum value of memory size in Mbytes (default -1: the size is given by freeyams).</li>
<li>loptions(4): set the value of the connected component which we want to obtain. (Remark: freeyams give an automatic value at each connected component).</li>
<li>loptions(5): level of verbosity</li>
<li>loptions(6): Create point on straight edge (no mapping) parameter (default 0). 1 for creating point on straight edge otherwise 0.</li>
<li>loptions(7): validity check during smoothing parameter. This parameter is only used with No-Shrinkage Vertex Smoothing optimization (optimization option parameter 9). 1 for No validity checking during smoothing otherwise 0.</li>
<li>loptions(8): number of desired's vertices (default -1).</li>
<li>loptions(9): number of iteration of optimizations (default 30).</li>
<li>loptions(10): no detection parameter (default 0) . 1 for detecting the ridge on the mesh otherwise 0. The ridge definition is given in the parameter doptions(12).</li>
<li>loptions(11): no vertex smoothing parameter (default 0). 1 for smoothing the vertices otherwise 0.</li>
<li>loptions(12): Optimization level parameter (default 0).<ul>
<li>0 : mesh optimization (smoothing+swapping)</li>
<li>1 : decimation+enrichment adaptated to a metric map.</li>
<li>-1: decimation adaptated to a metric map.</li>
<li>2 : decimation+enrichment with a Hausdorff-like method</li>
<li>-2: decimation with a Hausdorff-like method</li>
<li>4 : split triangles recursively.</li>
<li>9 : No-Shrinkage Vertex Smoothing</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code class="codehilite">doptions=</code> a vector of double of size 11. This vectors contains the real options of freeyams.</p>
<ul>
<li>doptions(0): Set the geometric approximation (Tangent plane deviation) (default 0.01).</li>
<li>doptions(1): Set the lamda parameter (default -1).</li>
<li>doptions(2): Set the mu parmeter (default -1).</li>
<li>doptions(3): Set the gradation value (Mesh density control) (default 1.3).</li>
<li>doptions(4): Set the minimal size(hmin) (default -2.0: the size is automatically computed).</li>
<li>doptions(5): Set the maximal size(hmax) (default -2.0: the size is automatically computed).</li>
<li>doptions(6): Set the tolerance of the control of Chordal deviation (default -2.0).</li>
<li>doptions(7): Set the quality of degradation (default 0.599).</li>
<li>doptions(8): Set the declic parameter (default 2.0).</li>
<li>doptions(9): Set the angular walton limitation parameter (default 45 degree).</li>
<li>doptions(10): Set the angular ridge detection (default 45 degree).</li>
</ul>
</li>
</ul>
<div class="admonition example">
<p class="admonition-title"><code class="codehilite">freeyams</code></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;medit&quot;
load &quot;freeyams&quot;

// Parameters
int nn = 20;
real zmin = 0;
real zmax = 1;

// Mesh
mesh Th2 = square(nn, nn);
int[int] rup = [0, 2], rdown = [0, 1];
int[int] rmid = [1, 1, 2, 1, 3, 1, 4, 1];
mesh3 Th = buildlayers(Th2, nn, zbound=[zmin, zmax], reffacemid=rmid, reffaceup=rup, reffacelow=rdown);
mesh3 Th3 = freeyams(Th);

medit(&quot;SurfaceMesh&quot;, Th3);
</pre></div>
</td></tr></table>

</div>
<h2 id="mmg3d">mmg3d<a class="headerlink" href="#mmg3d" title="Permanent link">#</a></h2>
<p><span><span class="MathJax_Preview">\codered</span><script type="math/tex">\codered</script></span> mmg3d-v4.0</p>
<p><a href="http://www.mmgtools.org">Mmg3d</a> is a 3D remeshing software developed by C. Dobrzynski and P. Frey.</p>
<p>This software allows to remesh an initial mesh made of tetrahedra. This initial mesh is adapted to a geometric metric tensor field or to a displacement vector (moving rigid body). The metric can be obtained with <a href="#mshmet"><code class="codehilite">mshmet</code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>If no metric is given, an isotropic metric is computed by analyzing the size of the edges in the initial mesh.</li>
<li>if a displacement is given, the vertices of the surface triangles are moved without verifying the geometrical structure of the new surface mesh.</li>
</ul>
</div>
<p>The parameters of <code class="codehilite">mmg3d</code> are :</p>
<ul>
<li>
<p><code class="codehilite">options=</code> vector expression. This vector contains the option parameters of <code class="codehilite">mmg3d</code>. It is a vector of 6 values, with the following meaning:</p>
<ul>
<li>
<p>Optimization parameters : (default 1)</p>
<p>0 : mesh optimization.</p>
<p>1 : adaptation with metric (deletion and insertion vertices) and optimization.</p>
<p>-1 : adaptation with metric (deletion and insertion vertices) without optimization.</p>
<p>4 : split tetrahedra (be careful modify the surface).</p>
<p>9 : moving mesh with optimization.</p>
<p>-9 : moving mesh without optimization.</p>
</li>
<li>
<p>Debug mode : (default 0)</p>
<p>1 : turn on debug mode.</p>
<p>0 : otherwise.</p>
</li>
<li>
<p>Specify the size of bucket per dimension (default 64)</p>
</li>
<li>
<p>Swapping mode : (default 0)</p>
<p>1 : no edge or face flipping.</p>
<p>0 : otherwise.</p>
</li>
<li>
<p>Insert points mode : (default 0)</p>
<p>1 : no edge splitting or collapsing and no insert points.</p>
<p>0 : otherwise.</p>
</li>
<li>
<p>Verbosity level (default 3)</p>
</li>
</ul>
</li>
<li>
<p><code class="codehilite">memory=</code> integer expression. Set the maximum memory size of new mesh in Mbytes. By default the number of maximum vertices, tetrahedra and triangles are respectively 500 000, 3000 000, 100000 which represent approximately a memory of 100 Mo.</p>
</li>
<li>
<p><code class="codehilite">metric=</code> vector expression. This vector contains the metric given at <code class="codehilite">mmg3d</code>. It is a vector of size <span><span class="MathJax_Preview">nv</span><script type="math/tex">nv</script></span> or 6 <span><span class="MathJax_Preview">nv</span><script type="math/tex">nv</script></span> respectively for an isotropic and anisotropic metric where <span><span class="MathJax_Preview">nv</span><script type="math/tex">nv</script></span> is the number of vertices in the initial mesh. The structure of <code class="codehilite">metric</code> vector is described in the <a href="#mshmet"><code class="codehilite">mshmet</code></a>.</p>
</li>
<li>
<p><code class="codehilite">displacement=</code> <span><span class="MathJax_Preview">[\Phi1, \Phi2, \Phi3]</span><script type="math/tex">[\Phi1, \Phi2, \Phi3]</script></span> set the displacement vector of the initial mesh <span><span class="MathJax_Preview">\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]</span><script type="math/tex">\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]</script></span>.</p>
</li>
<li>
<p><code class="codehilite">displVect=</code> sets the vector displacement in a vector expression. This vector contains the displacement at each point of the initial mesh. It is a vector of size 3 <span><span class="MathJax_Preview">nv</span><script type="math/tex">nv</script></span>.</p>
</li>
</ul>
<div class="admonition example">
<p class="admonition-title"><code class="codehilite">mmg3d</code></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;medit&quot;
load &quot;mmg3d&quot;
include &quot;Cube.idp&quot;

// Parameters
int n = 6;
int[int] Nxyz = [12, 12, 12];
real [int, int] Bxyz = [[0., 1.], [0., 1.], [0., 1.]];
int [int, int] Lxyz = [[1, 1], [2, 2], [2, 2]];

// Mesh
mesh3 Th = Cube(Nxyz, Bxyz, Lxyz);

real[int] isometric(Th.nv);
for (int ii = 0; ii &lt; Th.nv; ii++)
    isometric[ii] = 0.17;

mesh3 Th3 = mmg3d(Th, memory=100, metric=isometric);

// Plot
medit(&quot;Initial&quot;, Th);
medit(&quot;Isometric&quot;, Th3);
</pre></div>
</td></tr></table>

</div>
<div class="admonition example">
<p class="admonition-title">Falling spheres</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;medit&quot;
load &quot;mmg3d&quot;
include &quot;MeshSurface.idp&quot;

// Parameters
real hs = 0.8;
int[int] N = [4/hs, 8/hs, 11.5/hs];
real [int, int] B = [[-2, 2], [-2, 6], [-10, 1.5]];
int [int, int] L = [[311, 311], [311, 311], [311, 311]];

int[int] opt = [9, 0, 64, 0, 0, 3];
real[int] vit=[0, 0, -0.3];
func zero = 0.;
func dep = vit[2];

// Mesh
mesh3 ThH = SurfaceHex(N, B, L, 1);
mesh3 ThSg = Sphere(1, hs, 300, -1);
mesh3 ThSd = Sphere(1, hs, 310, -1);
ThSd = movemesh3(ThSd, transfo=[x, 4+y, z]);
mesh3 ThHS = ThH + ThSg + ThSd;//gluing surface meshes
medit(&quot;ThHS&quot;, ThHS);

real voltet = (hs^3)/6.;
real[int] domain = [0, 0, -4, 1, voltet];
real [int] holes = [0, 0, 0, 0, 4, 0];
mesh3 Th = tetg(ThHS, switch=&quot;pqaAAYYQ&quot;, nbofregions=1, regionlist=domaine, nbofholes=2, holelist=holes);
medit(&quot;Box-With-two-Ball&quot;, Th);

// Fespace
fespace Vh(Th, P1);
Vh uh,vh;

// Macro
macro Grad(u) [dx(u),dy(u),dz(u)]

// Problem
problem Lap (uh, vh, solver=CG)
    = int3d(Th)(
          Grad(uh)&#39; * Grad(vh)
    )
    + on(310, 300, uh=dep)
    + on(311, uh=0.)
    ;

// Falling loop
for(int it = 0; it &lt; 29; it++){
    cout &lt;&lt; &quot; ITERATION &quot; &lt;&lt; it &lt;&lt; endl;

    // Solve
    Lap;

    // Plot
    plot(Th, uh);

    // Sphere falling
    Th = mmg3d(Th, options=opt, displacement=[zero, zero, uh], memory=1000);
}
</pre></div>
</td></tr></table>

</div>
<h2 id="a-first-3d-isotrope-mesh-adaptation-process">A first 3d isotrope mesh adaptation process<a class="headerlink" href="#a-first-3d-isotrope-mesh-adaptation-process" title="Permanent link">#</a></h2>
<div class="admonition example">
<p class="admonition-title">Adaptation 3D</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;msh3&quot;
load &quot;TetGen&quot;
load &quot;mshmet&quot;
load &quot;medit&quot;

// Parameters
int nn = 6;
int[int] l1111 = [1, 1, 1, 1]; //labels
int[int] l01 = [0, 1];
int[int] l11 = [1, 1];

real errm = 1e-2; //level of error

// Mesh
mesh3 Th3 = buildlayers(square(nn, nn, region=0, label=l1111),
    nn, zbound=[0, 1], labelmid=l11, labelup=l01, labeldown=l01);

Th3 = trunc(Th3, (x&lt;0.5) | (y &lt; 0.5) | (z &lt; 0.5), label=1); //remove the ]0.5,1[^3 cube

// Fespace
fespace Vh(Th3, P1);
Vh u, v, usol, h;

// Macro
macro Grad(u) [dx(u), dy(u), dz(u)] // EOM

// Problem
problem Poisson (u, v, solver=CG)
    = int3d(Th3)(
          Grad(u)&#39; * Grad(v)
    )
    - int3d(Th3)(
          1*v
    )
    + on(1, u=0)
    ;

// Loop
for (int ii = 0; ii &lt; 5; ii++){
    // Solve
    Poisson;
    cout &lt;&lt; &quot;u min, max = &quot; &lt;&lt; u[].min &lt;&lt; &quot; &quot;&lt;&lt; u[].max &lt;&lt; endl;

    h=0.; //for resizing h[] because the mesh change
    h[] = mshmet(Th3, u, normalization=1, aniso=0, nbregul=1, hmin=1e-3, hmax=0.3, err=errm);
    cout &lt;&lt; &quot;h min, max = &quot; &lt;&lt; h[].min &lt;&lt; &quot; &quot;&lt;&lt; h[].max &lt;&lt; &quot; &quot; &lt;&lt; h[].n &lt;&lt; &quot; &quot; &lt;&lt; Th3.nv &lt;&lt; endl;
    plot(u, wait=true);

    errm *= 0.8; //change the level of error
    cout &lt;&lt; &quot;Th3 &quot; &lt;&lt; Th3.nv &lt; &quot; &quot; &lt;&lt; Th3.nt &lt;&lt; endl;
    Th3 = tetgreconstruction(Th3, switch=&quot;raAQ&quot;, sizeofvolume=h*h*h/6.); //rebuild mesh
    medit(&quot;U-adap-iso-&quot;+ii, Th3, u, wait=true);
}
</pre></div>
</td></tr></table>

</div>
<h2 id="build-a-2d-mesh-from-a-isoline">Build a 2d mesh from a isoline<a class="headerlink" href="#build-a-2d-mesh-from-a-isoline" title="Permanent link">#</a></h2>
<p>The idea is to get the discretization of an isoline of fluid meshes, this tool can be useful to construct meshes from image. First, we give an example of the isovalue meshes <span><span class="MathJax_Preview">0.2</span><script type="math/tex">0.2</script></span> of analytical function <span><span class="MathJax_Preview">\sqrt{(x-1/2)^2 +(y-1/2)^2}</span><script type="math/tex">\sqrt{(x-1/2)^2 +(y-1/2)^2}</script></span>, on unit square.</p>
<div class="admonition example">
<p class="admonition-title">iosline</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;isoline&quot;

real[int,int] xy(3, 1); //to store the isoline points
int[int] be(1); //to store the begin, end couple of lines
{
    mesh Th = square(10, 10);
    fespace Vh(Th, P1);
    Vh u = sqrt(square(x-0.5) + square(y-0.5));
    real iso = 0.2 ;
    real[int] viso = [iso];
    plot(u, viso=viso,Th);//to see the iso line

    int nbc = isoline(Th, u, xy, close=1, iso=iso, beginend=be, smoothing=0.1);
</pre></div>
</td></tr></table>

</div>
<p>The <code class="codehilite">isoline</code> parameters are <code class="codehilite">Th</code> the mesh, the expression <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, the bidimentionnal array <code class="codehilite">xy</code> to store the list coordinate of the points. The list of named parameter are :</p>
<ul>
<li>
<p><code class="codehilite">iso=</code> value of the isoline to compute (0 is the default value)</p>
</li>
<li>
<p><code class="codehilite">close=</code> close the isoline with the border (default <code class="codehilite">true</code>), we add the part of the mesh border such the value is less than the isovalue</p>
</li>
<li>
<p><code class="codehilite">smoothing=</code> number of smoothing process is the <span><span class="MathJax_Preview">{l} ^{r} {s}</span><script type="math/tex">{l} ^{r} {s}</script></span> where <span><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span> is the length of the current line component, <span><span class="MathJax_Preview">r</span><script type="math/tex">r</script></span> the ratio, <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> is smoothing value. The smoothing default value is 0.</p>
</li>
<li>
<p><code class="codehilite">ratio=</code> the ratio (1 by default).</p>
</li>
<li>
<p><code class="codehilite">eps=</code> relative <span><span class="MathJax_Preview">\varepsilon</span><script type="math/tex">\varepsilon</script></span> (default 1e-10)</p>
</li>
<li>
<p><code class="codehilite">beginend=</code> array to get begin, end couple of each of sub line (resize automatically)</p>
</li>
<li>
<p><code class="codehilite">file=</code> to save the data curve in data file for gnu plot</p>
</li>
</ul>
<p>In the array <code class="codehilite">xy</code> you get the list of vertices of the isoline, each connex line go from <span><span class="MathJax_Preview">i= i_0^c ,\dots, i_1^c-1</span><script type="math/tex">i= i_0^c ,\dots, i_1^c-1</script></span> with <span><span class="MathJax_Preview">i_0^c =be(2*c)</span><script type="math/tex">i_0^c =be(2*c)</script></span> <span><span class="MathJax_Preview">i_1^c =be(2*c+1)</span><script type="math/tex">i_1^c =be(2*c+1)</script></span>, and where <span><span class="MathJax_Preview">x_i= xy(0,i), y_i=yx( 1,i), l_i=xy(2,i)</span><script type="math/tex">x_i= xy(0,i), y_i=yx( 1,i), l_i=xy(2,i)</script></span>.</p>
<p>Here <span><span class="MathJax_Preview">l_i</span><script type="math/tex">l_i</script></span> is the length of the line (the origin of the line is point <span><span class="MathJax_Preview">i_0^c</span><script type="math/tex">i_0^c</script></span>).</p>
<p>The sense of the isoline is such that the upper part is at the left size of the isoline. So here : the minimum is a point <span><span class="MathJax_Preview">0.5,05</span><script type="math/tex">0.5,05</script></span> so the curve 1 turn in the clockwise sense, the order of each component are sort such that the number of point by component is decreasing.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>    cout &lt;&lt; &quot;Number of the line component = &quot; &lt;&lt; nbc &lt;&lt; endl;
    cout &lt;&lt; &quot;Number of points = &quot; &lt;&lt; xy.m &lt;&lt; endl;
    cout &lt;&lt; &quot;be = &quot; &lt;&lt; be &lt;&lt; endl;

    // shows the lines component
    for (int c = 0; c &lt; nbc; ++c){
        int i0 = be[2*c], i1 = be[2*c+1]-1;
        cout &lt;&lt; &quot;Curve &quot; &lt;&lt; c &lt;&lt; endl;
        for(int i = i0; i &lt;= i1; ++i)
            cout &lt;&lt; &quot;x= &quot; &lt;&lt; xy(0,i) &lt;&lt; &quot; y= &quot; &lt;&lt; xy(1,i) &lt;&lt; &quot; s= &quot; &lt;&lt; xy(2, i) &lt;&lt; endl;
        plot([xy(0, i0:i1), xy(1, i0:i1)], wait=true, viso=viso, cmm=&quot; curve &quot;+c);
    }
}

cout &lt;&lt; &quot;length of last curve = &quot; &lt;&lt; xy(2, xy.m-1) &lt;&lt; endl;
</pre></div>
</td></tr></table>

<p>We also have a new function to easily parametrize a discrete curve defined by the couple <span><span class="MathJax_Preview">be, xy</span><script type="math/tex">be, xy</script></span>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>border Curve0(t=0, 1){
    int c=0; //component 0
    int i0=be[2*c], i1=be[2*c+1]-1;
    P=Curve(xy, i0, i1, t); //Curve 0
    label=1;
}

border Curve1(t=0, 1){
    int c=1; //component 1
    int i0=be[2*c], i1=be[2*c+1]-1;
    P=Curve(xy, i0, i1, t); //Curve 1
    label=1;
}

plot(Curve1(100)); //show curve
mesh Th = buildmesh(Curve1(-100));
plot(Th, wait=true);
</pre></div>
</td></tr></table>

<p>Secondly, we use this idea to build meshes from an image, we use the plugins <code class="codehilite">ppm2rnm</code> to read <code class="codehilite">pgm</code> a gray scale image and then we extract the gray contour at level 0.25.</p>
<div class="admonition example">
<p class="admonition-title">Leman lake</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>load &quot;ppm2rnm&quot;
load &quot;isoline&quot;

// Parameters
string leman = &quot;LemanLake.pgm&quot;;
real AreaLac = 580.03; //in km^2
real hsize = 5;
real[int, int] Curves(3, 1);
int[int] be(1);
int nc; //nb of curve
{
    real[int, int] ff1(leman); //read image
    //and set it in a rect. array
    int nx = ff1.n, ny = ff1.m;
    //build a Cartesian mesh such that the origin is in the right place.
    mesh Th = square(nx-1, ny-1, [(nx-1)*(x), (ny-1)*(1-y)]);
    //warning the numbering of the vertices (x,y) is
    //given by $i = x/nx + nx* y/ny $
    fespace Vh(Th, P1);
    Vh f1;
    f1[] = ff1; //transform array in finite element functions.
    nc = isoline(Th, f1, iso=0.25, close=1, Curves, beginend=be, smoothing=.1, ratio=0.5);
}

//The longest isoline: the lake
int ic0 = be(0), ic1 = be(1)-1;
plot([Curves(0, ic0:ic1), Curves(1, ic0:ic1)], wait=true);

int NC = Curves(2, ic1)/hsize;
real xl = Curves(0, ic0:ic1).max - 5;
real yl = Curves(1, ic0:ic1).min + 5;
border G(t=0, 1){P=Curve(Curves, ic0, ic1, t); label=1+(x&gt;xl)*2+(y&lt;yl);}
plot(G(-NC), wait=true);

mesh Th = buildmesh(G(-NC));
plot(Th, wait=true);

real scale = sqrt(AreaLac/Th.area);
Th = movemesh(Th, [x*scale, y*scale]);
cout &lt;&lt; &quot;Th.area = &quot; &lt;&lt; Th.area &lt;&lt; &quot; Km^2 &quot; &lt;&lt; &quot; == &quot; &lt;&lt; AreaLac &lt;&lt; &quot; Km^2 &quot; &lt;&lt; endl;
plot(Th, wait=true, ps=&quot;leman.eps&quot;);
</pre></div>
</td></tr></table>

</div>
<table>
<thead>
<tr>
<th align="center"><a name="Fig40">Fig. 40</a>: The image of the Leman lake meshes</th>
<th align="center"><a name="Fig41">Fig. 41</a>: the mesh of the lake</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img alt="lake" src="../images/MeshGeneration_Isoline1.jpg" /></td>
<td align="center"><img alt="leman mesh" src="../images/MeshGeneration_Isoline2.png" /></td>
</tr>
</tbody>
</table>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">#</a></h2>
<p><a name="refHecht1998">HECHT, F. The mesh adapting software: bamg. INRIA report, 1998, vol. 250, p. 252.</a></p>
<p><a name="refHang2006">SI, Hang. TetGen Users’ guide: A quality tetrahedral mesh generator and three-dimensional delaunay triangulator. 2006</a></p>
<p><a name="refShewchuk1998">SHEWCHUK, Jonathan Richard. Tetrahedral mesh generation by Delaunay refinement. In : Proceedings of the fourteenth annual symposium on Computational geometry. ACM, 1998. p. 86-95.</a></p>
<p><a name="refHecht1992">HECHT, F. Outils et algorithmes pour la méthode des éléments finis. HdR, Université Pierre et Marie Curie, France, 1992.</a></p>
<p><a name="refHecht19982">HECHT, Frédéric. BAMG: bidimensional anisotropic mesh generator. User Guide. INRIA, Rocquencourt, 1998.</a></p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../Notations/" title="Some Notations" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Some Notations
              </span>
            </div>
          </a>
        
        
          <a href="../FiniteElement/" title="Finite Element" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Finite Element
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/FreeFem/FreeFem-doc" class="md-footer-social__link fa fa-github"></a>
    
  </div>

      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.9e1f3b71.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
        <script src="../../mathjax-config.js"></script>
      
    
    
      
    
  </body>
</html>