%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}




\usepackage[margin=8pt]{subcaption}
\captionsetup{labelfont=bf}
\def\R{{\mathbb{R}}}
\def\C{{\mathbb{C}}}
\def\P{{\mathbb{P}}}
\def\p{{\partial}}
\def\n{{\nabla}}
\def\boldx{{\mathbf{x}}}
\def\boldxi{{\boldsymbol{\xi}}}
\def\arccosh{{\text{arccosh}}}
\def\arcsinh{{\text{arcsinh}}}
\def\arctanh{{\text{arctanh}}}
\def\vecttwo#1#2{\left|\begin{smallmatrix} #1 \\ #2 \end{smallmatrix}\right.}
\def\vectthree#1#2#3{\left|\begin{smallmatrix} #1 \\ #2 \\ #3\end{smallmatrix}\right.}
\def\bR{{\bf R}}
\def\bP{{\bf P}}
\def\bZ{{\bf Z}}
\def\bC{{\bf C}}
\def\VS{\bR^2}
\def\SVS{\underline V}
\def\SO{{\bf SO}}
\def\Sym{{\bf Sym}}
\def\qi{{\bf i}}
\def\qj{{\bf j}}
\def\qk{{\bf k}}
\def\ec{\hat{\bf e}}
\def\xc{\hat{\bf x}}
\def\bdr{\partial}
\def\PD{\partial_}
\def\strain{\underline \epsilon}
\def\stress{\underline \sigma}
\def\strainrate{\underline \epsilon^.}
\def\stressrate{\underline \sigma^.}
\def\stiff{\; \underline{\underline C}\;}
\def\comply{\underline{\underline \kappa}\;}
\def\Id{{\bf I}}
\def\Div{\nabla \cdot}
\def\Grad{\mathbf{\nabla}}
\def\rot{\nabla \times}
\def\lap{\triangle}
\def\tr{{\bf tr}\;}
\def\udH{\underline H}
\def\refX{\mathbf X}
\def\Jac{\overline{J}}
\def\spatx{\mathbf x}
\def\ani{\overline a}
\def\mat{\left[\begin{array}}
\def\tam{\end{array}\right]}
\def\arr{\left.\begin{array}}
\def\rra{\end{array}\right\}}
\def\arl{\left\{\begin{array}}
\def\lra{\end{array}\right.}
\def\ar{\begin{array}}
\def\ra{\end{array}}
\def\const{\mbox{ const.}}
\def\eps{\; \epsilon}
\def\sig{\; \sigma}
\def\th{\theta}
\def\sgn{\mbox{sgn}}
\def\qed{\; Q.E.D.\\}
\def\ranqe{\end{eqnarray}}
\def\ol{\overline}
\def\ul{\underline}
\def\bB{{\bf B}}
\def\bC{{\bf C}}
\def\bD{{\bf D}}
\def\bE{{\bf E}}
\def\bF{{\bf F}}
\def\bK{{\bf K}}
\def\bP{{\bf P}}
\def\bS{{\bf S}}
\def\bT{{\bf T}}
\def\bsig{{\bf \sigma}}
\def\T{{\mathbb{T}}}
\def\d{{text{d}}}
    

\title{FreeFEM Documentation}
\date{Mar 25, 2019}
\release{4.0}
\author{Frederic Hecht}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{introduction/index:introduction}}\label{\detokenize{introduction/index::doc}}
\sphinxstylestrong{FreeFEM} is a partial differential equation solver for non-linear multi-physics systems in 2D and 3D.

Problems involving partial differential equations from several branches of physics, such as fluid-structure interactions, require interpolations of data on several meshes and their manipulation within one program.
\sphinxstylestrong{FreeFEM} includes a fast interpolation algorithm and a language for the manipulation of data on multiple meshes.

\sphinxstylestrong{FreeFEM} is written in C++ and its language is a C++ idiom.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.650\linewidth]{{Logo}.png}\hspace*{\fill}}


\section{Download FreeFEM}
\label{\detokenize{introduction/download:download-freefem}}\label{\detokenize{introduction/download:download}}\label{\detokenize{introduction/download::doc}}

\subsection{Latest binary packages}
\label{\detokenize{introduction/download:latest-binary-packages}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
Operating System
&\sphinxstyletheadfamily 
FreeFEM Version
&\sphinxstyletheadfamily 
Size
&\sphinxstyletheadfamily 
Date
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.61/FreeFem++-3.61-1-MacOS\_10.13.pkg}{MacOS 10.13}
&
\sphinxcode{\sphinxupquote{3.61}}
&
445.3 Mb
&
May 09, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/FreeFem++-3.59-MacOS\_10.12.pkg}{MacOS 10.12}
&
\sphinxcode{\sphinxupquote{3.59}}
&
507.1 Mb
&
Mar 16, 2018
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.61/FreeFem++-3.61-1-MacOS\_10.11.pkg}{MacOS 10.11}
&
\sphinxcode{\sphinxupquote{3.61}}
&
376.5 Mb
&
Jul 12, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/FreeFem++-3.59-MacOS\_10.10.pkg}{MacOS 10.10}
&
\sphinxcode{\sphinxupquote{3.59}}
&
507.1 Mb
&
Mar 16, 2018
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.62/freefem\_1-3.62\_amd64.deb}{Ubuntu}
&
\sphinxcode{\sphinxupquote{3.62}}
&
27.6 Mb
&
Jan 14, 2019
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/3.61/FreeFem++-3.61-1-win64.exe}{Windows 64bits}
&
\sphinxcode{\sphinxupquote{3.61}}
&
87.6 Mb
&
Jul 12, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/FreeFem++-3.46-win32.exe}{Windows 32bits}
&
\sphinxcode{\sphinxupquote{3.46}}
&
66.4 Mb
&
May 09, 2017
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/freefem++-4.0-beta.tar.gz}{Source\_4.0}
&
\sphinxcode{\sphinxupquote{4.0-beta}}
&
3.2 Mb
&
Jan 18, 2019
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/latest}{Source}
&
\sphinxcode{\sphinxupquote{latest}}
&
\sphinxcode{\sphinxupquote{-}}
&
Feb 22, 2018
\\
\hline
\sphinxhref{http://www3.freefem.org/ff++/ftp/}{Older versions}
&
\sphinxcode{\sphinxupquote{-}}
&
\sphinxcode{\sphinxupquote{-}}
&
\sphinxcode{\sphinxupquote{-}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The source code is available on the \sphinxhref{https://github.com/FreeFem/FreeFem-sources}{FreeFEM GitHub Repository}.


\subsection{Syntax highlighters}
\label{\detokenize{introduction/download:syntax-highlighters}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Lexer type
&\sphinxstyletheadfamily 
Version
&\sphinxstyletheadfamily 
Description
\\
\hline
Emacs
&
\sphinxcode{\sphinxupquote{0.3}}
&
\sphinxhref{https://github.com/FreeFem/freefem-parser-emacs}{freefem-mode.el}
\\
\hline
Textmate 2
&
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-textmate}{FreeFem.tmbundle}
\\
\hline
Gedit
&
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxhref{https://github.com/FreeFem/Freefem-parser-gedit}{ffpp.lang}
\\
\hline
Atom
&
\sphinxcode{\sphinxupquote{0.3}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-atom}{language-freefem} or via the Atom package manager
\\
\hline
Pygments
&
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-pygments}{freefem.py}
\\
\hline
Vim
&
\sphinxcode{\sphinxupquote{0.1}}
&
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-vim}{edp.vim}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Installation guide}
\label{\detokenize{introduction/installation:installation-guide}}\label{\detokenize{introduction/installation::doc}}

\subsection{Easy installation}
\label{\detokenize{introduction/installation:easy-installation}}
First, go to the {\hyperref[\detokenize{introduction/download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{download page}}}} and choose your platform: Linux, MacOS or Windows.

\begin{sphinxadmonition}{note}{Note:}
Binary packages are available for Microsoft Windows, MacOS and some Linux distributions.
\end{sphinxadmonition}

Install \sphinxstylestrong{FreeFEM} by double-clicking on the appropriate file. Under Linux and MacOS the install directory is one of the following \sphinxcode{\sphinxupquote{/usr/local/bin}}, \sphinxcode{\sphinxupquote{/usr/local/share/freefem++}}, \sphinxcode{\sphinxupquote{/usr/local/lib/ff++}}


\subsubsection{Windows binary installation}
\label{\detokenize{introduction/installation:windows-binary-installation}}
First download the windows installation executable, then double click to install \sphinxstylestrong{FreeFEM}.

In most cases just answer yes (or type return) to all questions.

Otherwise in the Additional Task windows, check the box “Add application directory to your system path.” This is required otherwise the program \sphinxcode{\sphinxupquote{ffglut.exe}} will not be found.

By now you should have two new icons on your desktop:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FreeFem++ (VERSION).exe}}, the \sphinxcode{\sphinxupquote{freefem++}} application.

\item {} 
\sphinxcode{\sphinxupquote{FreeFem++ (VERSION) Examples}}, a link to the \sphinxcode{\sphinxupquote{freefem++}} examples folder.

\end{itemize}

where \sphinxcode{\sphinxupquote{(VERSION)}} is the version of the files (for example 3.59).

By default, the installed files are in \sphinxcode{\sphinxupquote{C:\textbackslash{}Programs Files\textbackslash{}FreeFem++}}. In this directory, you have all the \sphinxcode{\sphinxupquote{.dll}} files and other applications: \sphinxcode{\sphinxupquote{FreeFem++-nw.exe}}, \sphinxcode{\sphinxupquote{ffglut.exe}}, … The syntax for the command-line tools are the same as those of \sphinxcode{\sphinxupquote{FreeFem.exe}}.


\subsubsection{MacOS X binary installation}
\label{\detokenize{introduction/installation:macos-x-binary-installation}}
Download the MacOS X binary version file, extract all the files by double clicking on the icon of the file, go the the directory and put the \sphinxcode{\sphinxupquote{FreeFem+.app}} application in the \sphinxcode{\sphinxupquote{/Applications}} directory.

If you want terminal access to \sphinxstylestrong{FreeFEM} just copy the file \sphinxcode{\sphinxupquote{FreeFem++}} in a directory of your \sphinxcode{\sphinxupquote{\$PATH}} shell environment variable.


\subsubsection{Arch AUR package}
\label{\detokenize{introduction/installation:arch-aur-package}}
An up-to-date package of \sphinxstylestrong{FreeFEM} for Arch is available on the \sphinxhref{https://aur.archlinux.org/packages/freefem\%2B\%2B-git/}{Archlinux user repository}.

To install it:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://aur.archlinux.org/freefem++\PYGZhy{}git.git
\PYG{n+nb}{cd} freefem++\PYGZhy{}git
makepkg \PYGZhy{}si
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Thanks to \sphinxhref{https://github.com/stefanhusmann}{Stephan Husmann}
\end{sphinxadmonition}


\subsection{Text-editor}
\label{\detokenize{introduction/installation:text-editor}}

\subsubsection{Atom}
\label{\detokenize{introduction/installation:atom}}
In order to get the syntax highlighting in \sphinxhref{https://atom.io/}{Atom}, you have to install the \sphinxhref{https://atom.io/packages/language-freefem-official}{FreeFEM language support}.

You can do it directly in Atom: Edit -\textgreater{} Preferences -\textgreater{} Install, and search for \sphinxcode{\sphinxupquote{language-freefem-offical}}.

To launch scripts directly from Atom, you have to install the \sphinxcode{\sphinxupquote{atom-runner}} package. Once installed, modify the Atom configuration file (Edit -\textgreater{} Config…) to have something like that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+s+s2}{\PYGZdq{}*\PYGZdq{}}:
   ...

   runner:
      extensions:
         edp: \PYG{l+s+s2}{\PYGZdq{}FreeFem++\PYGZdq{}}
      scopes:
         \PYG{l+s+s2}{\PYGZdq{}Freefem++\PYGZdq{}}: \PYG{l+s+s2}{\PYGZdq{}FreeFem++\PYGZdq{}}
\end{sphinxVerbatim}

Reboot Atom, and use Alt+R to run a FreeFem++ script.


\subsubsection{Gedit}
\label{\detokenize{introduction/installation:gedit}}
In order to get the syntax highlighting in Gedit, you have to downlaod the \sphinxhref{https://github.com/FreeFem/FreeFem-parser-gedit}{Gedit parser} and copy it in \sphinxcode{\sphinxupquote{/usr/share/gtksourceview-3.0/language-specs/}}.


\subsection{Compilation}
\label{\detokenize{introduction/installation:compilation}}

\subsubsection{Compilation on OSX (\textgreater{}=10.13)}
\label{\detokenize{introduction/installation:compilation-on-osx-10-13}}
Remark: Blocks of code are shell commands in terminal.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install Xcode, Xcode Command Line tools and Xcode Additional Tools from the \sphinxhref{https://developer.apple.com/download/more/}{Apple website}

\item {} 
Install gcc from \sphinxhref{http://hpc.sourceforge.net/}{http://hpc.sourceforge.net}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
curl \PYGZhy{}O http://prdownloads.sourceforge.net/hpc/gfortran\PYGZhy{}8.1\PYGZhy{}bin.tar.gz?download
sudo tar zxvf gfortran\PYGZhy{}8.1\PYGZhy{}bin.tar.gz \PYGZhy{}C /
\end{sphinxVerbatim}

\item {} 
Install autoconf and automake from \sphinxhref{https://www.macports.org}{macport} or with \sphinxhref{https://brew.sh}{Homebrew}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo port install autoconf
sudo port install automake
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
brew install autoconf
brew install automake
\end{sphinxVerbatim}

\item {} 
Install mactex from \sphinxhref{http://mirrors.ctan.org/systems/mac/mactex/MacTeX.pkg}{ctan}

\item {} 
Install the \sphinxhref{https://www.open-mpi.org/software/ompi/v4.0/}{openmpi} source code

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYG{n+nv}{CC}\PYG{o}{=}/usr/local/bin/gcc \PYG{n+nv}{CXX}\PYG{o}{=}/usr/local/bin/g++ \PYG{n+nv}{F77}\PYG{o}{=}/usr/local/bin/gfortran \PYG{n+nv}{FC}\PYG{o}{=}/usr/local/bin/gfortran
make
sudo make install
\end{sphinxVerbatim}

\item {} 
Install \sphinxhref{https://www.gnu.org/software/gsl}{gsl}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
curl \PYGZhy{}O https://fr.mirror.babylon.network/gnu/gsl/gsl\PYGZhy{}2.4.tar.gz
tar zxvf gsl\PYGZhy{}2.4.tar.gz
\PYG{n+nb}{cd} gsl\PYGZhy{}2.4
./configure \PYG{n+nv}{CC}\PYG{o}{=}/usr/local/bin/gcc
make
sudo make install
\end{sphinxVerbatim}

\item {} 
Install \sphinxhref{https://git-scm.com/download/mac}{git}

\item {} 
Download the \sphinxstylestrong{FreeFEM} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\end{enumerate}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\setcounter{enumi}{8}
\item {} 
Compile \sphinxstylestrong{FreeFEM}. Don’t forget to update the MacOS SDK version with your own in the command below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
./configure \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}with\PYGZhy{}suffix=macos\PYGZhy{}10.13\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}without\PYGZhy{}fltk\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}download\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPIRUN=/usr/local/bin/mpirun\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}m64\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}without\PYGZhy{}x\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CC=clang \PYGZhy{}isysroot /Applications/Xcode.app//Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CFLAGS=\PYGZhy{}mmacosx\PYGZhy{}version\PYGZhy{}min=10.13\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CXXFLAGS=\PYGZhy{}mmacosx\PYGZhy{}version\PYGZhy{}min=10.13 \PYGZhy{}std=c++11\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}CXX=clang++ \PYGZhy{}isysroot /Applications/Xcode.app//Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}F77=/usr/local/bin/gfortran\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}FC=/usr/local/bin/gfortran\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPICXX=/usr/local/bin/mpic++\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPICC=/usr/local/bin/mpicc\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPIFC=/usr/local/bin/mpif90\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}MPIF77=/usr/local/bin/mpif90\PYGZsq{}} \PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}\PYGZhy{}enable\PYGZhy{}maintainer\PYGZhy{}mode\PYGZsq{}}
make
make check
sudo make install
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Compilation on Ubuntu}
\label{\detokenize{introduction/installation:compilation-on-ubuntu}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install the following dependencies

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo apt\PYGZhy{}get update \PYG{o}{\PYGZam{}\PYGZam{}} sudo apt\PYGZhy{}get upgrade
sudo apt\PYGZhy{}get install cpp freeglut3\PYGZhy{}dev g++ gcc gfortran \PYG{l+s+se}{\PYGZbs{}}
    ghostscript m4 make patch pkg\PYGZhy{}config wget python unzip \PYG{l+s+se}{\PYGZbs{}}
    libopenblas\PYGZhy{}dev liblapack\PYGZhy{}dev libhdf5\PYGZhy{}dev libgsl\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
    libscotch\PYGZhy{}dev libfftw3\PYGZhy{}dev libarpack2\PYGZhy{}dev libsuitesparse\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
    libmumps\PYGZhy{}seq\PYGZhy{}dev libnlopt\PYGZhy{}dev coinor\PYGZhy{}libipopt\PYGZhy{}dev libgmm++\PYGZhy{}dev libtet1.5\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
    gnuplot\PYGZhy{}qt autoconf automake autotools\PYGZhy{}dev bison flex gdb valgrind git cmake

\PYG{c+c1}{\PYGZsh{} mpich is required for the FreeFem parallel computing version}
sudo apt\PYGZhy{}get install mpich
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
In the oldest distribution of Ubuntu, \sphinxcode{\sphinxupquote{libgsl-dev}} does not exists, use \sphinxcode{\sphinxupquote{libgsl2-dev}} instead
\end{sphinxadmonition}

\item {} 
Download \sphinxstylestrong{FreeFEM} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
Autoconf

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
if your autoreconf version is too old, do \sphinxcode{\sphinxupquote{tar zxvf AutoGeneratedFile.tar.gz}}
\end{sphinxadmonition}

\item {} 
Configure

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim \PYGZhy{}\PYGZhy{}disable\PYGZhy{}pastix
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
To see all the options, type \sphinxcode{\sphinxupquote{./configure -{-}help}}
\end{sphinxadmonition}

\item {} 
Download the packages

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./download/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
All the third party packages have their own licence
\end{sphinxadmonition}

\item {} 
Download and compile petsc \& slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} download/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc \PYG{n+nv}{SUDO}\PYG{o}{=}sudo
\PYG{n+nb}{cd} \PYGZhy{}
\end{sphinxVerbatim}

\item {} 
Reconfigure with petsc and slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./reconfigure
\end{sphinxVerbatim}

\item {} 
Build

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If your computer has many threads, you can run \sphinxcode{\sphinxupquote{make}} in parallel using \sphinxcode{\sphinxupquote{make -j16}} for 16 threads, for example.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Optionnally, check the compilation with \sphinxcode{\sphinxupquote{make check}}
\end{sphinxadmonition}

\item {} 
Install

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo make install
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Compilation on Arch Linux}
\label{\detokenize{introduction/installation:compilation-on-arch-linux}}
\begin{sphinxadmonition}{warning}{Warning:}
As Arch is in rolling release, the following information can be quickly outdated !
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{FreeFEM} fails to compile using the newest version of gcc 8.1.0, use an older one instead.
\end{sphinxadmonition}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install the following dependencies:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syu
pacman \PYGZhy{}S git openmpi gcc\PYGZhy{}fortran wget python
    freeglut ghostscript m4 make patch gmm
    blas lapack hdf5 gsl fftw arpack suitesparse
    gnuplot autoconf automake bison flex gdb
    valgrind cmake texlive\PYGZhy{}most
\end{sphinxVerbatim}

\item {} 
Download the \sphinxstylestrong{FreeFEM} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
Autoconf

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\item {} 
Configure

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim \PYGZhy{}\PYGZhy{}disable\PYGZhy{}pastix
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
To see all the options, type \sphinxcode{\sphinxupquote{./configure -{-}help}}
\end{sphinxadmonition}

\item {} 
Download the packages

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./download/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
All the third party packages have their own licence
\end{sphinxadmonition}

\item {} 
Download and compile petsc \& slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} download/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc \PYG{n+nv}{SUDO}\PYG{o}{=}sudo
\PYG{n+nb}{cd} \PYGZhy{}
\end{sphinxVerbatim}

\item {} 
Reconfigure with petsc and slepc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./reconfigure
\end{sphinxVerbatim}

\item {} 
Build

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If your computer has many threads, you can run \sphinxcode{\sphinxupquote{make}} in parallel using \sphinxcode{\sphinxupquote{make -j16}} for 16 threads, for example.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Optionnally, check the compilation with \sphinxcode{\sphinxupquote{make check}}
\end{sphinxadmonition}

\item {} 
Install

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo make install
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Compilation on Linux with Intel software tools}
\label{\detokenize{introduction/installation:compilation-on-linux-with-intel-software-tools}}
Follow the \sphinxhref{https://software.intel.com/en-us/articles/building-freefem-with-intel-software-tools-for-developers}{guide}


\subsubsection{Compilation on Windows}
\label{\detokenize{introduction/installation:compilation-on-windows}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Install \sphinxhref{https://www.microsoft.com/en-us/download/details.aspx?id=49926}{MS MPI v7} (msmpisdk.msi and MSMpiSetup.exe)

\item {} 
Install \sphinxhref{https://www.msys2.org/}{Msys2} (x86\_64 version)

\item {} 
Start MSYS2 MSYS

\item {} 
Open \sphinxcode{\sphinxupquote{MSYS2 MSYS terminal}} to install dependancies
\begin{itemize}
\item {} 
for 64bits system:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syu
pacman \PYGZhy{}S autoconf automake\PYGZhy{}wrapper bash bash\PYGZhy{}completion \PYG{l+s+se}{\PYGZbs{}}
    bison bsdcpio bsdtar bzip2 coreutils curl dash file filesystem \PYG{l+s+se}{\PYGZbs{}}
    findutils flex gawk gcc gcc\PYGZhy{}fortran gcc\PYGZhy{}libs grep gzip inetutils info less lndir \PYG{l+s+se}{\PYGZbs{}}
    make man\PYGZhy{}db git mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}freeglut mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gcc \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gcc\PYGZhy{}fortran mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gsl mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}hdf5 \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}openblas mintty msys2\PYGZhy{}keyring msys2\PYGZhy{}launcher\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
    msys2\PYGZhy{}runtime ncurses pacman pacman\PYGZhy{}mirrors pactoys\PYGZhy{}git patch pax\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
    perl pkg\PYGZhy{}config pkgfile rebase sed tar tftp\PYGZhy{}hpa \PYG{n+nb}{time} tzcode unzip util\PYGZhy{}linux which
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
for 32bits system:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syu
pacman \PYGZhy{}S autoconf automake\PYGZhy{}wrapper bash bash\PYGZhy{}completion \PYG{l+s+se}{\PYGZbs{}}
    bison bsdcpio bsdtar bzip2 coreutils curl dash file filesystem \PYG{l+s+se}{\PYGZbs{}}
    findutils flex gawk gcc gcc\PYGZhy{}fortran gcc\PYGZhy{}libs grep gzip inetutils info less lndir \PYG{l+s+se}{\PYGZbs{}}
    make man\PYGZhy{}db git mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}freeglut mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}gcc \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}gcc\PYGZhy{}fortran mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}gsl mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}hdf5 \PYG{l+s+se}{\PYGZbs{}}
    mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}openblas mintty msys2\PYGZhy{}keyring msys2\PYGZhy{}launcher\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
    msys2\PYGZhy{}runtime ncurses pacman pacman\PYGZhy{}mirrors pactoys\PYGZhy{}git patch pax\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
perl pkg\PYGZhy{}config pkgfile rebase sed tar tftp\PYGZhy{}hpa \PYG{n+nb}{time} tzcode unzip util\PYGZhy{}linux which
\end{sphinxVerbatim}

\item {} 
Open \sphinxcode{\sphinxupquote{MingW64 terminal}} (or \sphinxcode{\sphinxupquote{MingW32}}) to compile \sphinxstylestrong{FreeFEM}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}disable\PYGZhy{}pastix \PYGZhy{}\PYGZhy{}disable\PYGZhy{}hips
./download/getall \PYGZhy{}a
make \PYGZhy{}j4
make check
make install
\end{sphinxVerbatim}

The \sphinxstylestrong{FreeFEM} executable (and some other like \sphinxcode{\sphinxupquote{ffmedit}}, …)
are in \sphinxcode{\sphinxupquote{C:\textbackslash{}msys64\textbackslash{}mingw64\textbackslash{}bin}} (or \sphinxcode{\sphinxupquote{C:\textbackslash{}msys32\textbackslash{}mingw32\textbackslash{}bin}}).

\end{enumerate}


\subsection{Environment variables and init file}
\label{\detokenize{introduction/installation:environment-variables-and-init-file}}
\sphinxstylestrong{FreeFEM} reads a user’s init file named \sphinxcode{\sphinxupquote{freefem++.pref}} to initialize global variables: \sphinxcode{\sphinxupquote{verbosity}}, \sphinxcode{\sphinxupquote{includepath}}, \sphinxcode{\sphinxupquote{loadpath}}.

\begin{sphinxadmonition}{note}{Note:}
The variable \sphinxcode{\sphinxupquote{verbosity}} changes the level of internal printing (0: nothing unless there are syntax errors, 1: few, 10: lots, etc. …), the default value is 2.

The included files are found in the \sphinxcode{\sphinxupquote{includepath}} list and the load files are found in the \sphinxcode{\sphinxupquote{loadpath}} list.
\end{sphinxadmonition}

The syntax of the file is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{verbosity} \PYG{o}{=} \PYG{l+m}{5}
\PYG{n+nv}{loadpath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Library/FreeFem++/lib\PYGZdq{}}
\PYG{n+nv}{loadpath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Users/hecht/Library/FreeFem++/lib\PYGZdq{}}
\PYG{n+nv}{includepath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Library/FreeFem++/edp\PYGZdq{}}
\PYG{n+nv}{includepath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Users/hecht/Library/FreeFem++/edp\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} This is a comment}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}funcTemplate\PYGZdq{}}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}myfunction\PYGZdq{}}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}MUMPS\PYGZus{}seq\PYGZdq{}}
\end{sphinxVerbatim}

The possible paths for this file are
\begin{itemize}
\item {} 
under Unix and MacOs

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
/etc/freefem++.pref
\PYG{k}{\PYGZdl{}(}HOME\PYG{k}{)}/.freefem++.pref
freefem++.pref
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
under windows

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
freefem++.pref
\end{sphinxVerbatim}

We can also use shell environment variables to change verbosity and the search rule before the init files.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}VERBOSITY}\PYG{o}{=}\PYG{l+m}{50}
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}INCLUDEPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}dir;;dir2\PYGZdq{}}
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}LOADPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}dir;;dir3\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The separator between directories must be “;” and not “:” because “:” is used under Windows.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
To show the list of init of \sphinxstylestrong{FreeFEM} , do

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}VERBOSITY}\PYG{o}{=}\PYG{l+m}{100}\PYG{p}{;}
./FreeFem++\PYGZhy{}nw
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Contributing}
\label{\detokenize{introduction/contributing:contributing}}\label{\detokenize{introduction/contributing::doc}}

\subsection{Bug report}
\label{\detokenize{introduction/contributing:bug-report}}

\subsubsection{Concerning the \sphinxstylestrong{FreeFEM} documentation}
\label{\detokenize{introduction/contributing:concerning-the-freefem-documentation}}
Open an \sphinxhref{https://github.com/FreeFem/FreeFem-doc/issues}{Issue} on \sphinxstylestrong{FreeFem-doc} repository.


\subsubsection{Concerning the \sphinxstylestrong{FreeFEM} compilation or usage}
\label{\detokenize{introduction/contributing:concerning-the-freefem-compilation-or-usage}}
Open an \sphinxhref{https://github.com/FreeFem/FreeFem-sources/issues}{Issue} on \sphinxstylestrong{FreeFem-sources} repository.


\subsection{Improve content}
\label{\detokenize{introduction/contributing:improve-content}}
Ask one of the contributors for Collaborator Access or make a \sphinxhref{https://github.com/FreeFem/FreeFem-doc/pulls}{Pull Request}.


\section{Citation}
\label{\detokenize{introduction/citation:citation}}\label{\detokenize{introduction/citation::doc}}

\subsection{If you use \sphinxstylestrong{FreeFEM}, please cite the following reference in your work:}
\label{\detokenize{introduction/citation:if-you-use-freefem-please-cite-the-following-reference-in-your-work}}

\subsubsection{APA}
\label{\detokenize{introduction/citation:apa}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Hecht, F. (2012). New development in FreeFem++. Journal of numerical mathematics, 20(3\PYGZhy{}4), 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{ISO690}
\label{\detokenize{introduction/citation:iso690}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
HECHT, Frédéric. New development in FreeFem++. Journal of numerical mathematics, 2012, vol. 20, no 3\PYGZhy{}4, p. 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{MLA}
\label{\detokenize{introduction/citation:mla}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Hecht, Frédéric. \PYGZdq{}New development in FreeFem++.\PYGZdq{} Journal of numerical mathematics 20.3\PYGZhy{}4 (2012): 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{BibTeX}
\label{\detokenize{introduction/citation:bibtex}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nc}{@article}\PYG{p}{\PYGZob{}}\PYG{n+nl}{MR3043640}\PYG{p}{,}
  \PYG{n+na}{AUTHOR} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{Hecht, F.}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{TITLE} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{New development in FreeFem++}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{JOURNAL} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{J. Numer. Math.}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{FJOURNAL} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{Journal of Numerical Mathematics}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{VOLUME} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{20}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,} \PYG{n+na}{YEAR} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{2012}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{NUMBER} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{3\PYGZhy{}4}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,} \PYG{n+na}{PAGES} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{251\PYGZhy{}\PYGZhy{}265}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{ISSN} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{1570\PYGZhy{}2820}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{MRCLASS} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{65Y15}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{MRNUMBER} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{3043640}\PYG{l+s}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Authors}
\label{\detokenize{introduction/authors:authors}}\label{\detokenize{introduction/authors::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Frédéric Hecht
\\
\hline
Professor at \sphinxhref{https://www.ljll.math.upmc.fr/}{Laboratoire Jacques Louis
Lions} (LJLL), Pierre and Marie
Curie University, Paris
\\
\hline
\sphinxhref{mailto:frederic.hecht@sorbonne-universite.fr}{frederic.hecht@sorbonne-universite.fr}
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/hecht/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Sylvain Auliac
\\
\hline
Former PhD student at LJLL, optimization interface with
\sphinxhref{https://nlopt.readthedocs.io/en/latest/}{nlopt},
\sphinxhref{https://projects.coin-or.org/Ipopt}{ipopt},
\sphinxhref{https://en.wikipedia.org/wiki/CMA-ES}{cmaes}, …
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/auliac/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Olivier Pironneau
\\
\hline
Professor of numerical analysis at the Paris VI university and at
LJLL, numerical methods in fluid
\\
\hline
Member of the \sphinxhref{http://www.iufrance.fr/}{Institut Universitaire de
France} and \sphinxhref{http://www.academie-sciences.fr/fr/}{Academie des
Sciences}
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/pironneau/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Jacques Morice
\\
\hline
Former Post-Doc at LJLL, three dimensions mesh generation and
coupling with
\sphinxhref{https://www.ljll.math.upmc.fr/frey/logiciels/Docmedit.dir/index.html}{medit}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Antoine Le Hyaric
\\
\hline
Research engineer from \sphinxhref{http://www.cnrs.fr}{CNRS}, expert in
software engineering for scientific applications, electromagnetics
simulations, parallel computing and three-dimensionsal visualization
\\
\hline
\sphinxurl{https://www.ljll.math.upmc.fr/lehyaric/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Kohji Ohtsuka
\\
\hline
Professor at \sphinxhref{http://www.hkg.ac.jp/html/}{Hiroshima Kokusai Gakuin
University}, Japan and chairman of the
\sphinxhref{http://www.wseas.org}{World Scientific and Engineering Academy and
Society}, Japan. Fracture dynamic, modeling
and computing
\\
\hline
\sphinxurl{https://sites.google.com/a/comfos.org/comfos/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
Pierre Jolivet
\\
\hline
\sphinxhref{http://www.cnrs.fr}{CNRS} researcher, MPI interface with \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc}, \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM}, …
\\
\hline
\sphinxurl{http://jolivet.perso.enseeiht.fr/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

And all the dedicated \sphinxhref{https://github.com/FreeFem/FreeFem-doc/graphs/contributors}{Github contributors}


\chapter{Documentation}
\label{\detokenize{documentation/index:documentation}}\label{\detokenize{documentation/index::doc}}
The fruit of a long maturing process, \sphinxstylestrong{freefem}, in its last avatar, \sphinxstylestrong{FreeFEM} , is a high level integrated development environment (IDE) for numerically solving partial differential equations (PDE) in dimension 2 and 3.
It is the ideal tool for teaching the finite element method but it is also perfect for research to quickly test new ideas or multi-physics and complex applications.

\sphinxstylestrong{FreeFEM} has an advanced automatic mesh generator, capable of a posteriori mesh adaptation; it has a general purpose elliptic solver interfaced with fast algorithms, such as the multi-frontal method UMFPACK, SuperLU, MUMPS.
Hyperbolic and parabolic problems are solved by iterative algorithms prescribed by the user with the high level language of \sphinxstylestrong{FreeFEM}.
It has several triangular finite elements, including discontinuous elements.
Everything is there in \sphinxstylestrong{FreeFEM} to prepare research quality reports with online color display, zooming and other features as well as postscript printouts.

This manual is meant for students at a Masters level, for researchers at any level, and for engineers (including financial engineering) with some understanding of variational methods for partial differential equations.

Introduction

A partial differential equation is a relation between a function of several variables and its (partial) derivatives.
Many problems in physics, engineering, mathematics and even banking are modeled by one or several partial differential equations.

\sphinxstylestrong{FreeFEM} is a software to solve these equations numerically.
As its name implies, it is a free software (see the copyrights for full detail) based on the Finite Element Method; it is not a package, it is an integrated product with its own high level programming language.
This software runs on all UNIX OS (with g++ 3.3 or later, and OpenGL), on Window XP, Vista and 7, 8, 10 and on MacOS 10 intel.

Moreover \sphinxstylestrong{FreeFEM} is highly adaptive.
Many phenomena involve several coupled systems.
Fluid-structure interactions, Lorentz forces for aluminum casting and ocean-atmosphere problems are three such systems.
These require different finite element approximations and polynomial degrees, possibly on different meshes.
Some algorithms like the Schwarz’ domain decomposition method also requires data interpolation on multiple meshes within one program.
\sphinxstylestrong{FreeFEM} can handle these difficulties, i.e. arbitrary finite element spaces on arbitrary unstructured and adapted bi-dimensional meshes.

The characteristics of \sphinxstylestrong{FreeFEM} are:
\begin{itemize}
\item {} 
Problem description (real or complex valued) by their variational formulations, with access to the internal vectors and matrices if needed.

\item {} 
Multi-variables, multi-equations, bi-dimensional and three-dimensional static or time dependent, linear or nonlinear coupled systems; however the user is required to describe the iterative procedures which reduce the problem to a set of linear problems.

\item {} 
Easy geometric input by analytic description of boundaries by pieces; however this part is not a CAD system; for instance when two boundaries intersect, the user must specify the intersection points.

\item {} 
Automatic mesh generator, based on the Delaunay-Voronoi algorithm; the inner point density is proportional to the density of points on the boundaries \sphinxcite{references:george1996}.

\item {} 
Metric-based anisotropic mesh adaptation.
The metric can be computed automatically from the Hessian of any \sphinxstylestrong{FreeFEM} function \sphinxcite{references:hecht1998}.

\item {} 
High level user friendly typed input language with an algebra of analytic and finite element functions.

\item {} 
Multiple finite element meshes within one application with automatic interpolation of data on different meshes and possible storage of the interpolation matrices.

\item {} 
A large variety of triangular finite elements: linear, quadratic Lagrangian elements and more, discontinuous P1 and Raviart-Thomas elements, elements of a non-scalar type, the mini-element,… (but no quadrangles).

\item {} 
Tools to define discontinuous Galerkin finite element formulations P0, P1dc, P2dc and keywords: jump, mean, intalledges.

\item {} 
A large variety of linear direct and iterative solvers (LU, Cholesky, Crout, CG, GMRES, UMFPACK, MUMPS, SuperLU, …) and eigenvalue and eigenvector solvers (ARPARK) .

\item {} 
Near optimal execution speed (compared with compiled \sphinxcode{\sphinxupquote{C++}} implementations programmed directly).

\item {} 
Online graphics, generation of ,.txt,.eps,.gnu, mesh files for further manipulations of input and output data.

\item {} 
Many examples and tutorials: elliptic, parabolic and hyperbolic problems, Navier-Stokes flows, elasticity, fluid structure interactions, Schwarz’s domain decomposition method, eigenvalue problem, residual error indicator, …

\item {} 
A parallel version using MPI

\end{itemize}

History

The project has evolved from MacFem, PCfem, written in Pascal.
The first C version lead to \sphinxcode{\sphinxupquote{freefem 3.4}}; it offered mesh adaptivity on a single mesh only.

A thorough rewriting in \sphinxcode{\sphinxupquote{C++}} led to \sphinxcode{\sphinxupquote{freefem+}} (\sphinxcode{\sphinxupquote{freefem+}} 1.2.10 was its last release), which included interpolation over multiple meshes (functions defined on one mesh can be used on any other mesh); this software is no longer maintained but is still in use because it handles a problem description using the strong form of the PDEs.
Implementing the interpolation from one unstructured mesh to another was not easy because it had to be fast and non-diffusive; for each point, one had to find the containing triangle.
This is one of the basic problems of computational geometry (see \sphinxcite{references:preparata1985} for example).
Doing it in a minimum number of operations was the challenge.
Our implementation is \(\mathcal{O}(n log n)\) and based on a quadtree.
This version also grew out of hand because of the evolution of the template syntax in \sphinxcode{\sphinxupquote{C++}}.

We have been working for a few years now on \sphinxstylestrong{FreeFEM} , entirely re-written again in \sphinxcode{\sphinxupquote{C++}} with a thorough usage of template and generic programming for coupled systems of unknown size at compile time.
Like all versions of \sphinxcode{\sphinxupquote{freefem}}, it has a high level user friendly input language which is not too far from the mathematical writing of the problems.

The \sphinxcode{\sphinxupquote{freefem}} language allows for a quick specification of any partial differential system of equations.
The language syntax of \sphinxstylestrong{FreeFEM} is the result of a new design which makes use of the STL \sphinxcite{references:stroustrup2000}, templates, and bison for its implementation; more details can be found in \sphinxcite{references:hecht2002}.
The outcome is a versatile software in which any new finite elements can be included in a few hours; but a recompilation is then necessary.
Therefore the library of finite elements available in \sphinxstylestrong{FreeFEM} will grow with the version number and with the number of users who program more new elements.
So far we have discontinuous \(P_0\) elements,linear \(P_1\) and quadratic \(P_2\) Lagrangian elements, discontinuous \(P_1\) and Raviart-Thomas elements and a few others like bubble elements.


\section{Notations}
\label{\detokenize{documentation/notations:notations}}\label{\detokenize{documentation/notations::doc}}
Here mathematical expressions and corresponding \sphinxstylestrong{FreeFEM} commands are explained.


\subsection{Generalities}
\label{\detokenize{documentation/notations:generalities}}\begin{itemize}
\item {} 
{[}\(\delta_{ij}\){]} Kronecker delta (\(0\) if \(i\neq j\), 1 if \(i=j\) for integers \(i,j\))

\item {} 
{[}\(\forall\){]} for all

\item {} 
{[}\(\exists\){]} there exists

\item {} 
{[}i.e.{]} that is

\item {} 
{[}PDE{]} partial differential equation (with boundary conditions)

\item {} 
{[}\(\emptyset\){]} the empty set

\item {} 
{[}\(\mathbb{N}\){]} the set of integers (\(a\in \mathbb{N}\Leftrightarrow\) \sphinxcode{\sphinxupquote{int a}}), \sphinxcode{\sphinxupquote{int}} means \sphinxcode{\sphinxupquote{long int}} inside \sphinxstylestrong{FreeFEM}

\item {} 
{[}\(\mathbb{R}\){]} the set of real numbers (\(a\in \mathbb{R}\Leftrightarrow\) \sphinxcode{\sphinxupquote{real a}}), \sphinxcode{\sphinxupquote{double}} inside \sphinxstylestrong{FreeFEM}

\item {} 
{[}\(\mathbb{C}\){]} the set of complex numbers (\(a\in \mathbb{C}\Leftrightarrow\) \sphinxcode{\sphinxupquote{complex a}}), \sphinxcode{\sphinxupquote{complex\textless{}double\textgreater{}}}

\item {} 
{[}\(\mathbb{R}^d\){]} \(d\)-dimensional Euclidean space

\end{itemize}


\subsection{Sets, Mappings, Matrices, Vectors}
\label{\detokenize{documentation/notations:sets-mappings-matrices-vectors}}
Let \(E,\, F,\, G\) be three sets and \(A\) the subset of \(E\).
\begin{itemize}
\item {} 
{[}\(\{x\in E|\; P\}\){]} the subset of \(E\) consisting of the elements possessing the property \(P\)

\item {} 
{[}\(E\cup F\){]} the set of elements belonging to \(E\) or \(F\)

\item {} 
{[}\(E\cap F\){]} the set of elements belonging to \(E\) and \(F\)

\item {} 
{[}\(E\setminus A\){]} the set \(\{x\in E|\; x\not\in A\}\)

\item {} 
{[}\(E+F\){]} \(E\cup F\) with \(E\cap F=\emptyset\)

\item {} 
{[}\(E\times F\){]} the Cartesian product of \(E\) and \(F\)

\item {} 
{[}\(E^n\){]} the \(n\)-th power of \(E\) (\(E^2=E\times E\), \(E^n=E\times E^{n-1}\))

\item {} 
{[}\(f:\; E\to F\){]} the mapping form \(E\) into \(F\), i.e., \(E\ni x\mapsto f(x)\in F\)

\item {} 
{[}\(I_E\) or \(I\){]} the identity mapping in \(E\),i.e., \(I(x)=x\quad \forall x\in E\)

\item {} 
{[}\(f\circ g\){]} for \(f:\; F\to G\) and \(g:\; E\to F\), \(E\ni x\mapsto (f\circ g)(x)=f(g(x))\in G\) (see \DUrole{xref,std,std-ref}{Elementary function})

\item {} 
{[}\(f|_A\){]} the restriction of \(f:\; E\to F\) to the subset \(A\) of \(E\)

\item {} 
{[}\(\{a_k\}\){]} column vector with components \(a_k\)

\item {} 
{[}\((a_k)\){]} row vector with components \(a_k\)

\item {} 
{[}\((a_{k})^T\){]} denotes the transpose of a matrix \((a_{k})\), and is \(\{a_{k}\}\)

\item {} 
{[}\(\{a_{ij}\}\){]} matrix with components \(a_{ij}\), and \((a_{ij})^T=(a_{ji})\)

\end{itemize}


\subsection{Numbers}
\label{\detokenize{documentation/notations:numbers}}
For two real numbers \(a,b\)
\begin{itemize}
\item {} 
\([a,b]\) is the interval \(\{x\in \mathbb{R}|\; a\le x\le b\}\)

\item {} 
\(]a,b]\) is the interval \(\{x\in \mathbb{R}|\; a< x\le b\}\)

\item {} 
\([a,b[\) is the interval \(\{x\in \mathbb{R}|\; a\le x< b\}\)

\item {} 
\(]a,b[\) is the interval \(\{x\in \mathbb{R}|\; a< x< b\}\)

\end{itemize}


\subsection{Differential Calculus}
\label{\detokenize{documentation/notations:differential-calculus}}\begin{itemize}
\item {} 
{[}\(\partial f/\partial x\){]} the partial derivative of \(f:\mathbb{R}^d\to \mathbb{R}\) with respect to \(x\) (\sphinxcode{\sphinxupquote{dx(f)}})

\item {} 
{[}\(\nabla f\){]} the gradient of \(f:\Omega\to \mathbb{R}\),i.e., \(\nabla f=(\partial f/\partial x,\, \partial f/\partial y)\)

\item {} 
{[}\(\text{div}(\mathbf{f})\) or \(\nabla.\mathbf{f}\){]} the divergence of \(\mathbf{f}:\Omega\to \mathbb{R}^d\), i.e., \(\text{div}(\mathbf{f})=\partial f_1/\partial x+\partial f_2/\partial y\)

\item {} 
{[}\(\Delta f\){]} the Laplacian of \(f:\; \Omega\to \mathbb{R}\), i.e., \(\Delta f=\partial^2f/\partial x^2+\partial^2 f/\partial y^2\)

\end{itemize}


\subsection{Meshes}
\label{\detokenize{documentation/notations:meshes}}\begin{itemize}
\item {} 
{[}\(\Omega\){]} usually denotes a domain on which PDE is defined

\item {} 
{[}\(\Gamma\){]} denotes the boundary of \(\Omega\),i.e., \(\Gamma=\partial\Omega\) (keyword \sphinxcode{\sphinxupquote{border}}, see {\hyperref[\detokenize{documentation/meshGeneration:meshborder}]{\sphinxcrossref{\DUrole{std,std-ref}{Border}}}})

\item {} 
{[}\(\mathcal{T}_h\){]} the triangulation of \(\Omega\), i.e., the set of triangles \(T_k\), where \(h\) stands for mesh size (keyword \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{buildmesh}}, see {\hyperref[\detokenize{documentation/meshGeneration:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}})

\item {} 
{[}\(n_t\){]} the number of triangles in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nt}})

\item {} 
{[}\(\Omega_h\){]} denotes the approximated domain \(\Omega_h=\cup_{k=1}^{n_t}T_k\) of \(\Omega\).
If \(\Omega\) is polygonal domain, then it will be \(\Omega=\Omega_h\)

\item {} 
{[}\(\Gamma_h\){]} the boundary of \(\Omega_h\)

\item {} 
{[}\(n_v\){]} the number of vertices in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nv}})

\item {} 
{[}\(n_{be}\){]} the number of boundary element in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nbe}})

\item {} 
{[}\(|\Omega_h|\){]} the measure (area or volume) in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.measure}})

\item {} 
{[}\(|\partial \Omega_h|\){]} the measure of the border (length or area) in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.bordermeasure}})

\item {} 
{[}\(h_{min}\){]} the minimum edge size of \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.hmin}})

\item {} 
{[}\(h_{max}\){]} the maximum edge size of \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.hmax}})

\item {} 
{[}{[}\(q^iq^j\){]}{]} the segment connecting \(q^i\) and \(q^j\)

\item {} 
{[}\(q^{k_1},q^{k_2},q^{k_3}\){]} the vertices of a triangle \(T_k\) with anti-clock direction (get the coordinate of \(q^{k_j}\) by \sphinxcode{\sphinxupquote{(Th{[}k-1{]}{[}j-1{]}.x, Th{[}k-1{]}{[}j-1{]}.y)}})

\item {} 
{[}\(I_{\Omega}\){]} the set \(\{i\in \mathbb{N}|\; q^i\not\in \Gamma_h\}\)

\end{itemize}


\subsection{Finite Element Spaces}
\label{\detokenize{documentation/notations:finite-element-spaces}}\begin{itemize}
\item {} 
{[}\(L^2(\Omega)\){]} the set \(\displaystyle{\left\{w(x,y)\left|\; \int_{\Omega}|w(x,y)|^2\text{d} x\text{d} y<\infty\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{norm:}\; \| w\|_{0,\Omega}&=\left(\int_{\Omega}|w(x,y)|^2\text{d} x\text{d} y\right)^{1/2}\\
\textrm{scalar product:}\; (v,w)&=\int_{\Omega}vw\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
{[}\(H^1(\Omega)\){]} the set \(\displaystyle{\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}\left(|\partial w/\partial x|^2+|\partial w/\partial y|^2\right)\text{d} x\text{d} y <\infty\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{norm:}\; \| w\|_{1,\Omega}=\left(\| w\|_{0,\Omega}^2+\|\nabla u\|_{0.\Omega}^2\right)^{1/2}\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
{[}\(H^m(\Omega)\){]} the set \(\displaystyle{\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}\frac{\partial^{|\alpha|} w}{\partial x^{\alpha_1}\partial y^{\alpha_2}}\in L^2(\Omega)\quad\forall \alpha=(\alpha_1,\alpha_2)\in \mathbb{N}^2,\, |\alpha|=\alpha_1+\alpha_2\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{scalar product:}\; (v,w)_{1,\Omega}=
\sum_{|\alpha|\le m}\int_{\Omega} D^{\alpha}v D^{\alpha}w\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
{[}\(H^1_0(\Omega)\){]} the set \(\left\{w\in H^1(\Omega)\left|\; u=0\quad \textrm{on }\Gamma\right.\right\}\)

{[}\(L^2(\Omega)^2\){]} denotes \(L^2(\Omega)\times L^2(\Omega)\), and also \(H^1(\Omega)^2=H^1(\Omega)\times H^1(\Omega)\)

\item {} 
{[}\(V_h\){]} denotes the finite element space created by \sphinxcode{\sphinxupquote{fespace Vh(Th, *)}} in \sphinxstylestrong{FreeFEM} (see {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Elements}}}} for \sphinxcode{\sphinxupquote{*}})

\item {} 
{[}\(\Pi_h f\){]} the projection of the function \(f\) into \(V_h\) (\sphinxcode{\sphinxupquote{func f=x\textasciicircum{}2*y\textasciicircum{}3; Vh v = f;}}) means \(v = Pi_h (f) * [\{v\}]\) for FE-function \(v\) in \(V_h\) means the column vector \((v_1,\cdots,v_M)^T\) if \(v=v_1\phi_1+\cdots+v_M\phi_M\), which is shown by \sphinxcode{\sphinxupquote{fespace Vh(Th, P2); Vh v; cout \textless{}\textless{} v{[}{]} \textless{}\textless{} endl;}}

\end{itemize}


\section{Mesh Generation}
\label{\detokenize{documentation/meshGeneration:mesh-generation}}\label{\detokenize{documentation/meshGeneration:meshgeneration}}\label{\detokenize{documentation/meshGeneration::doc}}
Let us begin with the two important keywords: \sphinxcode{\sphinxupquote{border}} and \sphinxcode{\sphinxupquote{buildmesh}}.


\subsection{Square}
\label{\detokenize{documentation/meshGeneration:square}}\label{\detokenize{documentation/meshGeneration:meshsquare}}
The command \sphinxcode{\sphinxupquote{square}} triangulates the unit square.

The following generates a \(4 \times 5\) grid in the unit square \([0,1]^2\). The labels of the boundaries are shown in \hyperref[\detokenize{documentation/meshGeneration:figboundarylabels}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figboundarylabels}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Square}.png}
\caption{Boundary labels of the mesh by \sphinxcode{\sphinxupquote{square(10,10)}}}\label{\detokenize{documentation/meshGeneration:figboundarylabels}}\end{figure}

To construct a \(n\times m\) grid in the rectangle \([x_0,x_1]\times [y_0,y_1]\), proceed as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{1.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Adding the named parameter \sphinxcode{\sphinxupquote{flags=icase}} with icase:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{-1}
\item {} 
will produce a mesh where all quads are split with diagonal \(x-y=constant\)

\item {} 
will produce \sphinxstyleemphasis{Union Jack flag} type of mesh

\item {} 
will produce a mesh where all quads are split with diagonal \(x+y=constant\)

\item {} 
same as in case 0, except two corners where the triangles are the same as case 2 to avoid having 3 vertices on the boundary

\item {} 
same as in case 2, except two corners where the triangles are the same as case 0 to avoid having 3 vertices on the boundary

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{icase}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Adding the named parameter \sphinxcode{\sphinxupquote{label=labs}} will
change the 4 default label numbers to \sphinxcode{\sphinxupquote{labs{[}i-1{]}}}, for
example \sphinxcode{\sphinxupquote{int{[}int{]} labs={[}11, 12, 13, 14{]}}}, and adding the
named parameter \sphinxcode{\sphinxupquote{region=10}} will change the region number
to \(10\), for instance (v 3.8).

To see all of these flags at work, check {\hyperref[\detokenize{example/meshGeneration:examplemeshsquare}]{\sphinxcrossref{\DUrole{std,std-ref}{Square mesh example}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{labs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{labs}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square flags = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Border}
\label{\detokenize{documentation/meshGeneration:border}}\label{\detokenize{documentation/meshGeneration:meshborder}}
Boundaries are defined piecewise by parametrized curves. The pieces can only intersect at their endpoints, but it is possible to join more than two endpoints. This can be used to structure the mesh if an area touches a border and create new regions by dividing larger ones:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{others} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{inner} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C05}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C06}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
  \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
  \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 1 has region number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 2 has redion number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

Borders and mesh are respectively shown in \hyperref[\detokenize{documentation/meshGeneration:figmultipleborder}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figmultipleborder}}} and \hyperref[\detokenize{documentation/meshGeneration:figgeneratedmesh}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figgeneratedmesh}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border1}.png}
\caption{Multiple border ends intersect}\label{\detokenize{documentation/meshGeneration:id14}}\label{\detokenize{documentation/meshGeneration:figmultipleborder}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border2}.png}
\caption{Generated mesh}\label{\detokenize{documentation/meshGeneration:id15}}\label{\detokenize{documentation/meshGeneration:figgeneratedmesh}}\end{subfigure}
\caption{Border}\phantomsection\label{\detokenize{documentation/meshGeneration:MeshGeneration_Border}}

\end{figure}


Triangulation keywords assume that the domain is defined as being on the \sphinxstyleemphasis{left} (resp \sphinxstyleemphasis{right}) of its oriented parameterized boundary
\begin{equation*}
\begin{split}\Gamma_j = \{(x,y)\left|\; x=\varphi_x(t),\, y=\varphi_y(t),\, a_j\le t\le b_j\right.\}\end{split}
\end{equation*}
To check the orientation plot \(t\mapsto (\varphi_x(t),\varphi_y(t)),\, t_0\le t\le t_1\). If it is as in \hyperref[\detokenize{documentation/meshGeneration:figborder}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figborder}}}, then the domain lies on the shaded area, otherwise it lies on the opposite side.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_Border3}.png}
\caption{Orientation of the boundary defined by \((\phi_x(t),\phi_y(t))\)}\label{\detokenize{documentation/meshGeneration:figborder}}\end{figure}

The general expression to define a triangulation with \sphinxcode{\sphinxupquote{buildmesh}} is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Mesh\PYGZus{}Name} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{n}{m1}\PYG{p}{)}\PYG{o}{+}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{o}{+}\PYG{n}{GammaJ}\PYG{p}{(}\PYG{n}{mj}\PYG{p}{)}\PYG{p}{,} \PYG{n}{OptionalParameter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \(m_j\) are positive or negative numbers to indicate how many vertices should be on \(\Gamma_j,\, \Gamma=\cup_{j=1}^J \Gamma_J\), and the optional parameter (see also \DUrole{xref,std,std-ref}{References}), separated with a comma, can be:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbvx= int}}, to set the maximum number of vertices in the mesh.

\item {} 
\sphinxcode{\sphinxupquote{fixedborder= bool}}, to say if the mesh generator can change the boundary mesh or not (by default the boundary mesh can change; beware that with periodic boundary conditions (see. {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}), it can be dangerous.

\end{itemize}

The orientation of boundaries can be changed by changing the sign of \(m_j\).

The following example shows how to change the orientation. The example generates the unit disk with a small circular hole, and assigns “1” to the unit disk (“2” to the circle inside). The boundary label \sphinxstylestrong{must be non-zero}, but it can also be omitted.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see a plot of the border mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thwithouthole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithouthole}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thwithouthole.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithhole}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thwithhole.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
Notice that the orientation is changed by \sphinxcode{\sphinxupquote{b(-30)}} in the 5th line. In the 7th line, \sphinxcode{\sphinxupquote{ps="fileName"}} is used to generate a postscript file with identification shown on the figure.
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border4}.png}
\caption{Mesh without hole}\label{\detokenize{documentation/meshGeneration:id16}}\label{\detokenize{documentation/meshGeneration:figmeswithouthhole}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border5}.png}
\caption{Mesh with hole}\label{\detokenize{documentation/meshGeneration:id17}}\label{\detokenize{documentation/meshGeneration:figmeshwithhole}}\end{subfigure}
\caption{Mesh with a hole}\phantomsection\label{\detokenize{documentation/meshGeneration:MeshWithHole}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
Borders are evaluated only at the time \sphinxcode{\sphinxupquote{plot}} or \sphinxcode{\sphinxupquote{buildmesh}} is called so the global variables are defined at this time. In this case, since \(r\) is changed between the two border calls, the following code will not work because the first border will be computed with r=0.3:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// bug (a trap) because}
    \PYG{c+c1}{// the two circles have the same radius = :math:{}`0.3{}`}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Multi-Border}
\label{\detokenize{documentation/meshGeneration:multi-border}}
Sometimes it can be useful to make an array of the border, but unfortunately it is incompatible with the \sphinxstylestrong{FreeFEM} syntax. To bypass this problem, if the number of segments of the discretization \(n\) is an array, we make an implicit loop on all of the values of the array, and the index variable \(i\) of the loop is defined after the parameter definition, like in \sphinxcode{\sphinxupquote{border a(t=0, 2*pi; i)}} …

A first very small example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nn} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot 3 circles with 10, 20, 30 points}
\end{sphinxVerbatim}

And a more complex example to define a square with small circles:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{yy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{//radius, center of the 4 circles}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{RC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{XC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{YC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NC} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//list number of :math:{}`\PYGZbs{}pm{}` segments of the 4 circles borders}

\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// i is the index variable of the multi border loop}
    \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{t1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{t1} \PYG{o}{+} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{t1} \PYG{o}{+} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{RC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{n}{XC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{RC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{n}{YC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{label} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nn} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//4 border, with 4, 4, 5, 7 segment respectively}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{(}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{cc}\PYG{p}{(}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Data Structures and Read/Write Statements for a Mesh}
\label{\detokenize{documentation/meshGeneration:data-structures-and-read-write-statements-for-a-mesh}}\label{\detokenize{documentation/meshGeneration:meshdatastructurereadwrite}}
Users who want to read a triangulation made elsewhere should see the structure of the file generated below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The mesh is shown on \hyperref[\detokenize{documentation/meshGeneration:figbuildmesh}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figbuildmesh}}}.

The information about \sphinxcode{\sphinxupquote{Th}} are saved in the file \sphinxcode{\sphinxupquote{mesh.msh}} whose structure is shown on \hyperref[\detokenize{documentation/meshGeneration:tabmeshstructure}]{Table \ref{\detokenize{documentation/meshGeneration:tabmeshstructure}}}.

There, \(n_v\) denotes the number of vertices, \(n_t\) the number of triangles and \(n_s\) the number of edges on boundary.

For each vertex \(q^i,\, i=1,\cdots,n_v\), denoted by \((q^i_x,q^i_y)\) the \(x\)-coordinate and \(y\)-coordinate.

Each triangle \(T_k, k=1,\cdots,n_t\) has three vertices \(q^{k_1},\, q^{k_2},\,q^{k_3}\) that are oriented counter-clockwise.

The boundary consists of 10 lines \(L_i,\, i=1,\cdots,10\) whose end points are \(q^{i_1},\, q^{i_2}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Data}.png}
\caption{Mesh by \sphinxcode{\sphinxupquote{buildmesh(C(10))}}}\label{\detokenize{documentation/meshGeneration:figbuildmesh}}\end{figure}

In the \hyperref[\detokenize{documentation/meshGeneration:figbuildmesh}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:figbuildmesh}}}, we have the following.

\(n_v=14, n_t=16, n_s=10\)

\(q^1=(-0.309016994375, 0.951056516295)\)

\(\dots\)

\(q^{14}=(-0.309016994375, -0.951056516295)\)

The vertices of \(T_1\) are \(q^9, q^{12},\, q^{10}\).

\(\dots\)

The vertices of \(T_{16}\) are \(q^9, q^{10}, q^{6}\).

The edge of the 1st side \(L_1\) are \(q^6, q^5\).

\(\dots\)

The edge of the 10th side \(L_{10}\) are \(q^{10}, q^6\).


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{The structure of \sphinxstyleliteralintitle{\sphinxupquote{mesh\_sample.msh}}}\label{\detokenize{documentation/meshGeneration:tabmeshstructure}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Content of the file
&\sphinxstyletheadfamily 
Explanation
\\
\hline
14 16 10
&
\(n_v\quad n_t\quad n_e\)
\\
\hline
-0.309016994375 0.951056516295 1

0.309016994375 0.951056516295 1

…

-0.309016994375 -0.951056516295 1
&
\(q^1_x\quad q^1_y\quad\) boundary label \(=1\)

\(q^2_x\quad q^2_y\quad\) boundary label \(=1\)

…

\(q^{14}_x\quad q^{14}_y\quad\) boundary label \(=1\)
\\
\hline
9 12 10 0

5 9 6 0

…

9 10 6 0
&
\(1_1\quad 1_2\quad 1_3\quad\) region label \(=0\)

\(2_1\quad 2_2\quad 2_3\quad\) region label \(=0\)

…

\(16_1\quad 16_2\quad 16_3\quad\) region label \(=0\)
\\
\hline
6 5 1

5 2 1

…

10 6 1
&
\(1_1\quad 1_2\quad\) boundary label \(=1\)

\(2_1\quad 2_2\quad\) boundary label \(=1\)

…

\(10_1\quad 10_2\quad\) boundary label \(=1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

In \sphinxstylestrong{FreeFEM} there are many mesh file formats available for communication with other tools such as \sphinxcode{\sphinxupquote{emc2}}, \sphinxcode{\sphinxupquote{modulef}}, … (see {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh format chapter}}}} ).

The extension of a file implies its format.
More details can be found on the file format .msh in the article by F. Hecht “bamg : a bidimensional anisotropic mesh generator” \sphinxcite{references:hecht1998-2}.

A mesh file can be read into \sphinxstylestrong{FreeFEM} except that the names of the borders are lost and only their reference numbers are kept.
So these borders have to be referenced by the number which corresponds to their order of appearance in the program, unless this number is overwritten by the keyword \sphinxcode{\sphinxupquote{label}}. Here are some examples:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{ceiling}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ceiling}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.am\PYGZus{}fmt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//\PYGZdq{}formatted Marrocco\PYGZdq{} format}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//\PYGZdq{}bamg\PYGZdq{}\PYGZhy{}type mesh}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//freefem format}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.nopo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//modulef format}
\PYG{k+kt}{mesh} \PYG{n}{th2} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//read the mesh}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{ceiling}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ceiling}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//save mesh in different formats}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.am\PYGZus{}fmt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format \PYGZdq{}formated Marrocco\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format database db mesh \PYGZdq{}bamg\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format freefem}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.nopo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// modulef format}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{femp1}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{//save the fespace function in a file}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//the file is automatically closed at the end of the block}
\PYG{c+c1}{//read a file and put it in a fespace function}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//the file is equally automatically closed}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2}
\PYG{c+c1}{//read the mesh for freefem format saved mesh}
\PYG{k+kt}{mesh} \PYG{n}{th2} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace 2}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{//solve:}
\PYG{c+c1}{//  \PYGZdl{}u + \PYGZbs{}Delta u = g\PYGZdl{} in \PYGZdl{}\PYGZbs{}Omega \PYGZdl{}}
\PYG{c+c1}{//  \PYGZdl{}u=0\PYGZdl{} on \PYGZdl{}\PYGZbs{}Gamma\PYGZus{}1\PYGZdl{}}
\PYG{c+c1}{//  \PYGZdl{}\PYGZbs{}frac\PYGZob{}\PYGZbs{}partial u \PYGZcb{}\PYGZob{}\PYGZbs{}partial n\PYGZcb{} = g\PYGZdl{} on \PYGZdl{}\PYGZbs{}Gamma\PYGZus{}2\PYGZdl{}}
\PYG{k+kt}{solve} \PYG{n+nf}{Problem}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
  \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{)}\PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{g}\PYG{o}{*}\PYG{n}{v}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{g}\PYG{o}{*}\PYG{n}{v}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Mesh Connectivity and data}
\label{\detokenize{documentation/meshGeneration:mesh-connectivity-and-data}}
The following example explains methods to obtain mesh information.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Get data of the mesh}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{NbTriangles} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{MeshArea} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{BorderLenght} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of triangle(s) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mesh area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{MeshArea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Border length = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{BorderLenght} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Th(i) return the vextex i of Th}
    \PYG{c+c1}{// Th[k] return the triangle k of Th}
    \PYG{c+c1}{// Th[k][i] return the vertex i of the triangle k of Th}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Th[i][j] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{x}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, y= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{y}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, label=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Hack to get vertex coordinates}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{femp1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{femp1} \PYG{n}{Thx}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{Thy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{NbVertices} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of vertices = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbVertices} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NbVertices}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{old method: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Thx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Thy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Method to find information of point (0.55,0.6)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;} \PYG{c+c1}{//the triangle number}
    \PYG{k+kt}{int} \PYG{n}{RLabel} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//the region label}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle number in point (0.55, 0.6): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Region label in point (0.55, 0.6): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{RLabel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Information of triangle}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{TArea} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;} \PYG{c+c1}{//triangle area}
    \PYG{k+kt}{real} \PYG{n}{TRegion} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//triangle region}
    \PYG{k+kt}{real} \PYG{n}{TLabel} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label}\PYG{p}{;} \PYG{c+c1}{//triangle label, same as region for triangles}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Area of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TArea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Region of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TRegion} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TLabel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Hack to get a triangle containing point x, y or region number (old method)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{femp0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{femp0} \PYG{n}{TNumbers}\PYG{p}{;} \PYG{c+c1}{//a P0 function to get triangle numbering}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{TNumbers}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{n}{femp0} \PYG{n}{RNumbers} \PYG{o}{=} \PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//a P0 function to get the region number}

    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{TNumbers}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Number of the triangle containing (0.55, 0,6)}
    \PYG{k+kt}{int} \PYG{n}{RNumber} \PYG{o}{=} \PYG{n}{RNumbers}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Number of the region containing (0.55, 0,6)}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Point (0.55,0,6) :}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Triangle number = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Region number = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{RNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// New method to get boundary information and mesh adjacent}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

    \PYG{c+c1}{// Number of boundary elements}
    \PYG{k+kt}{int} \PYG{n}{NbBoundaryElements} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of boundary element = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbBoundaryElements} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Boundary element k in \PYGZob{}0, ..., Th.nbe\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{BoundaryElement} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{BoundaryElement} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Vertice l in \PYGZob{}0, 1\PYGZcb{} of boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Vertex} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Vertex }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ of boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Vertex} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Triangle containg the boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Triangle} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Element}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle containing the boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Triangle} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Triangle egde nubmer containing the boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Edge} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{whoinElement}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle edge number containing the boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Edge} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Adjacent triangle of the triangle k by edge e}
    \PYG{k+kt}{int} \PYG{n}{Adjacent} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//The value of e is changed to the corresponding edge in the adjacent triangle}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Adjacent triangle of the triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ by edge }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Adjacent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Corresponding edge = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// If there is no adjacent triangle by edge e, the same triangle is returned}
    \PYG{c+c1}{//Th[k] == Th[k].adj(e)}
    \PYG{c+c1}{// Else a different triangle is returned}
    \PYG{c+c1}{//Th[k] != Th[k].adj(e)}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Print mesh connectivity }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{NbTriangles} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, label }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ee}\PYG{p}{;} \PYG{n}{e} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{e}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{c+c1}{//set ee to e, and ee is change by method adj,}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{}=\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ee}\PYG{o}{=}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ee}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, adj: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ee}\PYG{o}{=}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{NbBoundaryElements} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbBoundaryElements}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , label }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Element}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{whoinElement} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{boundingbox}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{boundingbox:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xmin = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, xmax = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ymin = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ymax = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
// Get data of the mesh
Number of \PYG{n+nv}{triangle} \PYG{o}{=} \PYG{l+m}{8}
Mesh \PYG{n+nv}{area} \PYG{o}{=} \PYG{l+m}{1}
Border \PYG{n+nv}{length} \PYG{o}{=} \PYG{l+m}{4}
\PYG{l+m}{0} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{0} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{1} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{2} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{2}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{2} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{4} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{4} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{4} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{5} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{5} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{5} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{6}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{6} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{6} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{6} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{7} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{7} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{7} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
// Hack to get vertex coordinates
Number of \PYG{n+nv}{vertices} \PYG{o}{=} \PYG{l+m}{9}
Th\PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{1}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{0} \PYG{l+m}{1}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{2}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{0} \PYG{l+m}{2}
   old method: \PYG{l+m}{1} \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{3}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{0}.5 \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{4}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{0}.5 \PYG{l+m}{0}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{5}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{0}.5 \PYG{l+m}{2}
   old method: \PYG{l+m}{1} \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{6}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{1}
Th\PYG{o}{(}\PYG{l+m}{7}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{1} \PYG{l+m}{3}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{1}
Th\PYG{o}{(}\PYG{l+m}{8}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{3}
   old method: \PYG{l+m}{1} \PYG{l+m}{1}
// Method to find the information of point \PYG{o}{(}\PYG{l+m}{0}.55,0.6\PYG{o}{)}
Triangle number in point \PYG{o}{(}\PYG{l+m}{0}.55, \PYG{l+m}{0}.6\PYG{o}{)}: \PYG{l+m}{7}
Region label in point \PYG{o}{(}\PYG{l+m}{0}.55, \PYG{l+m}{0}.6\PYG{o}{)}: \PYG{l+m}{0}
// Information of a triangle
Area of triangle \PYG{l+m}{7}: \PYG{l+m}{0}.125
Region of triangle \PYG{l+m}{7}: \PYG{l+m}{0}
Label of triangle \PYG{l+m}{7}: \PYG{l+m}{0}
// Hack to get a triangle containing point x, y or region number \PYG{o}{(}old method\PYG{o}{)}
Point \PYG{o}{(}\PYG{l+m}{0}.55,0,6\PYG{o}{)} :
   Triangle \PYG{n+nv}{number} \PYG{o}{=} \PYG{l+m}{7}
   Region \PYG{n+nv}{number} \PYG{o}{=} \PYG{l+m}{0}
// New method to get boundary information and mesh adjacent
Number of boundary \PYG{n+nv}{element} \PYG{o}{=} \PYG{l+m}{8}
Boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}
Vertex \PYG{l+m}{1} of boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{1}
Triangle containing the boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}
Triangle edge number containing the boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{2}
Adjacent triangle of the triangle \PYG{l+m}{0} by edge \PYG{n+nv}{1} \PYG{o}{=} \PYG{l+m}{1}
   Corresponding \PYG{n+nv}{edge} \PYG{o}{=} \PYG{l+m}{2}
// Print mesh connectivity
\PYG{l+m}{0} : \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{4}, label \PYG{l+m}{0}
\PYG{l+m}{1} : \PYG{l+m}{0} \PYG{l+m}{4} \PYG{l+m}{3}, label \PYG{l+m}{0}
\PYG{l+m}{2} : \PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{5}, label \PYG{l+m}{0}
\PYG{l+m}{3} : \PYG{l+m}{1} \PYG{l+m}{5} \PYG{l+m}{4}, label \PYG{l+m}{0}
\PYG{l+m}{4} : \PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{7}, label \PYG{l+m}{0}
\PYG{l+m}{5} : \PYG{l+m}{3} \PYG{l+m}{7} \PYG{l+m}{6}, label \PYG{l+m}{0}
\PYG{l+m}{6} : \PYG{l+m}{4} \PYG{l+m}{5} \PYG{l+m}{8}, label \PYG{l+m}{0}
\PYG{l+m}{7} : \PYG{l+m}{4} \PYG{l+m}{8} \PYG{l+m}{7}, label \PYG{l+m}{0}
\PYG{l+m}{0} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{2}, adj: \PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{1} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{1}, adj: \PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{2} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{2}, adj: \PYG{l+m}{0}
\PYG{l+m}{3} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{5} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{5} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{1}, adj: \PYG{l+m}{0}
\PYG{l+m}{5} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{6} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{6} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{6} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{7} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{7} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{7} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} : \PYG{l+m}{0} \PYG{l+m}{1} , label \PYG{l+m}{1}, triangle \PYG{l+m}{0} \PYG{l+m}{2}
\PYG{l+m}{1} : \PYG{l+m}{1} \PYG{l+m}{2} , label \PYG{l+m}{1}, triangle \PYG{l+m}{2} \PYG{l+m}{2}
\PYG{l+m}{2} : \PYG{l+m}{2} \PYG{l+m}{5} , label \PYG{l+m}{2}, triangle \PYG{l+m}{2} \PYG{l+m}{0}
\PYG{l+m}{3} : \PYG{l+m}{5} \PYG{l+m}{8} , label \PYG{l+m}{2}, triangle \PYG{l+m}{6} \PYG{l+m}{0}
\PYG{l+m}{4} : \PYG{l+m}{6} \PYG{l+m}{7} , label \PYG{l+m}{3}, triangle \PYG{l+m}{5} \PYG{l+m}{0}
\PYG{l+m}{5} : \PYG{l+m}{7} \PYG{l+m}{8} , label \PYG{l+m}{3}, triangle \PYG{l+m}{7} \PYG{l+m}{0}
\PYG{l+m}{6} : \PYG{l+m}{0} \PYG{l+m}{3} , label \PYG{l+m}{4}, triangle \PYG{l+m}{1} \PYG{l+m}{1}
\PYG{l+m}{7} : \PYG{l+m}{3} \PYG{l+m}{6} , label \PYG{l+m}{4}, triangle \PYG{l+m}{5} \PYG{l+m}{1}
boundingbox:
\PYG{n+nv}{xmin} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{xmax} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{ymin} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{ymax} \PYG{o}{=} \PYG{l+m}{1}
\end{sphinxVerbatim}

The real characteristic function of a mesh \sphinxcode{\sphinxupquote{Th}} is \sphinxcode{\sphinxupquote{chi(Th)}} in 2D and 3D where:

\sphinxcode{\sphinxupquote{chi(Th)(P)=1}} if \(P\in Th\)

\sphinxcode{\sphinxupquote{chi(Th)(P)=0}} if \(P\not\in Th\)


\subsection{The keyword “triangulate”}
\label{\detokenize{documentation/meshGeneration:the-keyword-triangulate}}
\sphinxstylestrong{FreeFEM} is able to build a triangulation from a set of points.
This triangulation is a Delaunay mesh of the convex hull of the set of points.
It can be useful to build a mesh from a table function.

The coordinates of the points and the value of the table function are defined separately with rows of the form: \sphinxcode{\sphinxupquote{x y f(x,y)}} in a file such as:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mf}{0.51387} \PYG{l+m+mf}{0.175741} \PYG{l+m+mf}{0.636237}
\PYG{l+m+mf}{0.308652} \PYG{l+m+mf}{0.534534} \PYG{l+m+mf}{0.746765}
\PYG{l+m+mf}{0.947628} \PYG{l+m+mf}{0.171736} \PYG{l+m+mf}{0.899823}
\PYG{l+m+mf}{0.702231} \PYG{l+m+mf}{0.226431} \PYG{l+m+mf}{0.800819}
\PYG{l+m+mf}{0.494773} \PYG{l+m+mf}{0.12472} \PYG{l+m+mf}{0.580623}
\PYG{l+m+mf}{0.0838988} \PYG{l+m+mf}{0.389647} \PYG{l+m+mf}{0.456045}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Triangulate1}.png}
\caption{Delaunay mesh of the convex hull of point set in file xy}\label{\detokenize{documentation/meshGeneration:id18}}\label{\detokenize{documentation/meshGeneration:figdelaunaymesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Triangulate2}.png}
\caption{Isolvalue of table function}\label{\detokenize{documentation/meshGeneration:id19}}\label{\detokenize{documentation/meshGeneration:figisovalue}}\end{subfigure}
\caption{Triangulate}\phantomsection\label{\detokenize{documentation/meshGeneration:Triangulate}}

\end{figure}


The third column of each line is left untouched by the \sphinxcode{\sphinxupquote{triangulate}} command.
But you can use this third value to define a table function with rows of the form: \sphinxcode{\sphinxupquote{x y f(x,y)}}.

The following example shows how to make a mesh from the file \sphinxcode{\sphinxupquote{xyf}} with the format stated just above.
The command \sphinxcode{\sphinxupquote{triangulate}} only uses the 1st and 2nd columns.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Build the Delaunay mesh of the convex hull}
\PYG{k+kt}{mesh} \PYG{n}{Thxy}\PYG{o}{=}\PYG{n+nf}{triangulate}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xyf}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//points are defined by the first 2 columns of file {}`xyf{}`}

\PYG{c+c1}{// Plot the created mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thxy}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vhxy}\PYG{p}{(}\PYG{n}{Thxy}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhxy} \PYG{n}{fxy}\PYG{p}{;}

\PYG{c+c1}{// Reading the 3rd column to define the function fxy}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xyf}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{fxy}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{yy} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{fxy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//to read third row only.}
                                      \PYG{c+c1}{//xx and yy are just skipped}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fxy}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

One new way to build a mesh is to have two arrays: one for the \(x\) values and the other for the \(y\) values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//set two arrays for the x\PYGZsq{}s and y\PYGZsq{}s}
\PYG{n}{Vhxy} \PYG{n}{xx}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{yy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{c+c1}{//build the mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{triangulate}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Boundary FEM Spaces Built as Empty Meshes}
\label{\detokenize{documentation/meshGeneration:boundary-fem-spaces-built-as-empty-meshes}}
To define a Finite Element space on a boundary, we came up with the idea of a mesh with no internal points (called empty mesh).
It can be useful to handle Lagrange multipliers in mixed and mortar methods.

So the function \sphinxcode{\sphinxupquote{emptymesh}} removes all the internal points of a mesh except points on internal boundaries.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

It is also possible to build an empty mesh of a pseudo subregion with \sphinxcode{\sphinxupquote{emptymesh(Th, ssd)}} using the set of edges from the mesh \sphinxcode{\sphinxupquote{Th}}; an edge \(e\) is in this set when, with the two adjacent triangles \(e =t1\cap t2\) and \(ssd[T1] \neq ssd[T2]\) where \(ssd\) refers to the pseudo region numbering of triangles, they are stored in the \sphinxcode{\sphinxupquote{int{[}int{]}}} array of size “the number of triangles”.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ssd}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//build the pseudo region numbering}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ssd}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{iq} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//because 2 triangles per quad}
        \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{n}{ssd}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ix}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{iy}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//build emtpy with all edges \PYGZdl{}e=T1 \PYGZbs{}cap T2\PYGZdl{} and \PYGZdl{}ssd[T1] \PYGZbs{}neq ssd[T2]\PYGZdl{}}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{emptymesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_EmptyMesh1}.png}
\caption{The empty mesh with boundary}\label{\detokenize{documentation/meshGeneration:id20}}\label{\detokenize{documentation/meshGeneration:figemptymesh1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_EmptyMesh2}.png}
\caption{An empty mesh defined from a pseudo region numbering of triangle}\label{\detokenize{documentation/meshGeneration:id21}}\label{\detokenize{documentation/meshGeneration:figemptymesh2}}\end{subfigure}
\caption{Empty mesh}

\end{figure}



\subsubsection{Remeshing}
\label{\detokenize{documentation/meshGeneration:remeshing}}\label{\detokenize{documentation/meshGeneration:EmptyMesh}}

\subsection{Movemesh}
\label{\detokenize{documentation/meshGeneration:movemesh}}\label{\detokenize{documentation/meshGeneration:meshgenerationmovemesh}}
Meshes can be translated, rotated, and deformed by \sphinxcode{\sphinxupquote{movemesh}}; this is useful for elasticity to watch the deformation due to the displacement \(\mathbf{\Phi}(x,y)=(\Phi_1(x,y),\Phi_2(x,y))\) of shape.

It is also useful to handle free boundary problems or optimal shape problems.

If \(\Omega\) is triangulated as \(T_h(\Omega)\), and \(\mathbf{\Phi}\) is a displacement vector then \(\mathbf{\Phi}(T_h)\) is obtained by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{p}{[}\PYG{n}{Phi1}\PYG{p}{,} \PYG{n}{Phi2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Sometimes the transformed mesh is invalid because some triangles have flipped over (meaning it now has a negative area).
To spot such problems, one may check the minimum triangle area in the transformed mesh with \sphinxcode{\sphinxupquote{checkmovemesh}} before any real transformation.

For example:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \Phi_1(x,y) &=& x+k*\sin(y*\pi)/10)\\
    \Phi_2(x,y) &=& y+k*\cos(y\pi)/10)
\end{array}\end{split}
\end{equation*}
for a big number \(k>1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lshape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{uu} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{vv} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Checkmovemesh}
\PYG{k+kt}{real} \PYG{n}{minT0} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return the min triangle area}
\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{// find a correct move mesh}
    \PYG{k+kt}{real} \PYG{n}{minT} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{minT} \PYG{o}{\PYGZgt{}} \PYG{n}{minT0}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{//if big enough}
    \PYG{k+kp}{coef} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Movemesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MovedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_MoveMesh1}.png}
\caption{L-shape}\label{\detokenize{documentation/meshGeneration:id22}}\label{\detokenize{documentation/meshGeneration:figlshape}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_MoveMesh2}.png}
\caption{Moved L-shape}\label{\detokenize{documentation/meshGeneration:id23}}\label{\detokenize{documentation/meshGeneration:figmovedlshape}}\end{subfigure}
\caption{Move mesh}\phantomsection\label{\detokenize{documentation/meshGeneration:MoveMesh}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
Consider a function \(u\) defined on a mesh \sphinxcode{\sphinxupquote{Th}}.
A statement like \sphinxcode{\sphinxupquote{Th=movemesh(Th...)}} does not change \(u\) and so the old mesh still exists.
It will be destroyed when no function uses it.
A statement like \(u=u\) redefines \(u\) on the new mesh \sphinxcode{\sphinxupquote{Th}} with interpolation and therefore destroys the old \sphinxcode{\sphinxupquote{Th}}, if \(u\) was the only function using it.
\end{sphinxadmonition}

Now, we give an example of moving a mesh with a Lagrangian function \(u\) defined on the moving mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{t} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{f}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{minarea} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{f}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{minarea} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//movemesh will be ok}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{f}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Min area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{minarea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{tmp}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//save the value}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{c+c1}{//to change the FEspace and mesh associated with u}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}\PYG{c+c1}{//set the value of u without any mesh update}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// In this program, since u is only defined on the last mesh, all the}
\PYG{c+c1}{// previous meshes are deleted from memory.}
\end{sphinxVerbatim}


\subsubsection{Regular Triangulation: hTriangle}
\label{\detokenize{documentation/meshGeneration:regular-triangulation-htriangle}}\label{\detokenize{documentation/meshGeneration:meshregulartriangulation}}
For a set \(S\), we define the diameter of \(S\) by
\begin{equation*}
\begin{split}\textrm{diam}(S)=\sup\{|\mathbf{x}-\mathbf{y}|; \; \mathbf{x},\, \mathbf{y}\in S\}\end{split}
\end{equation*}
The sequence \(\{\mathcal{T}_h\}_{h\rightarrow 0}\) of
\(\Omega\) is called \sphinxstyleemphasis{regular} if they satisfy the following:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\(\lim_{h\rightarrow 0}\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}=0\)

\item {} 
There is a number \(\sigma>0\) independent of \(h\) such that \(\frac{\rho(T_k)}{\textrm{diam}(T_k)}\ge \sigma\quad \textrm{for all }T_k\in \mathcal{T}_h\) where \(\rho(T_k)\) are the diameter of the inscribed circle of \(T_k\).

\end{enumerate}

We put \(h(\mathcal{T}_h)=\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}\), which is obtained by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size of mesh = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Adaptmesh}
\label{\detokenize{documentation/meshGeneration:adaptmesh}}
The function:
\begin{equation*}
\begin{split}f(x,y) = 10.0x^3+y^3+\tan^{-1}[\varepsilon/(\sin(5.0y)-2.0x)],\ \varepsilon = 0.0001\end{split}
\end{equation*}
sharply varies in value and the initial mesh given by one of the commands in the {\hyperref[\detokenize{documentation/meshGeneration:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation part}}}} cannot reflect its sharp variations.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{hmin} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{h}\PYG{o}{*}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//old mesh is deleted}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_AdaptMesh1}.png}
\caption{3D graphs for the initial mesh and 1st and 2nd mesh adaptations}\label{\detokenize{documentation/meshGeneration:figmeshadaptation}}\end{figure}

\sphinxstylestrong{FreeFEM} uses a variable metric/Delaunay automatic meshing algorithm.

The command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{ATh} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

create the new mesh \sphinxcode{\sphinxupquote{ATh}} adapted to the Hessian
\begin{equation*}
\begin{split}D^2f=(\partial^2 f/\partial x^2,\, \partial^2 f/\partial x\partial y, \partial^2 f/\partial y^2)\end{split}
\end{equation*}
of a function (formula or FE-function).

Mesh adaptation is a very powerful tool when the solution of a problem varies locally and sharply.

Here we solve the \DUrole{xref,std,std-ref}{Poisson’s problem}, when \(f=1\) and \(\Omega\) is a L-shape domain.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh2}.png}
\caption{L-shape domain and its boundary name}\label{\detokenize{documentation/meshGeneration:id24}}\label{\detokenize{documentation/meshGeneration:adaptmesh2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh3}.png}
\caption{Final solution after 4-times adaptation}\label{\detokenize{documentation/meshGeneration:id25}}\label{\detokenize{documentation/meshGeneration:adaptmesh3}}\end{subfigure}
\caption{Mesh adaptation}\phantomsection\label{\detokenize{documentation/meshGeneration:AdaptMesh}}

\end{figure}


\begin{sphinxadmonition}{tip}{Tip:}
The solution has the singularity \(r^{3/2},\, r=|x-\gamma|\) at the point \(\gamma\) of the intersection of two lines \(bc\) and \(bd\) (see \hyperref[\detokenize{documentation/meshGeneration:adaptmesh2}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:adaptmesh2}}}).
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

To speed up the adaptation, the default parameter \sphinxcode{\sphinxupquote{err}} of \sphinxcode{\sphinxupquote{adaptmesh}} is changed by hand; it specifies the required precision, so as to make the new mesh finer or coarser.

The problem is coercive and symmetric, so the linear system can be solved with the conjugate gradient method (parameter \sphinxcode{\sphinxupquote{solver=CG}}) with the stopping criteria on the residual, here \sphinxcode{\sphinxupquote{eps=1.e-6}}).

By \sphinxcode{\sphinxupquote{adaptmesh}}, the slope of the final solution is correctly computed near the point of intersection of \(bc\) and \(bd\) as in \hyperref[\detokenize{documentation/meshGeneration:adaptmesh3}]{Fig.\@ \ref{\detokenize{documentation/meshGeneration:adaptmesh3}}}.

This method is described in detail in \sphinxcite{references:hecht1998}.
It has a number of default parameters which can be modified.

If \sphinxcode{\sphinxupquote{f1,f2}} are functions and \sphinxcode{\sphinxupquote{thold, Thnew}} are meshes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{n}{f1} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,}\PYG{n}{f2} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{f2}\PYG{p}{]} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The additional parameters of \sphinxcode{\sphinxupquote{adaptmesh}} are:

See \DUrole{xref,std,std-ref}{Reference part} for more inforamtions
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{hmin=}} Minimum edge size.}] \leavevmode
Its default is related to the size of the domain to be meshed and the precision of the mesh generator.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{hmax=}} Maximum edge size.}] \leavevmode
It defaults to the diameter of the domain to be meshed.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{err=}} \(P_1\) interpolation error level (0.01 is the default).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{errg=}} Relative geometrical error.}] \leavevmode
By default this error is 0.01, and in any case it must be lower than \(1/\sqrt{2}\).
Meshes created with this option may have some edges smaller than the \sphinxcode{\sphinxupquote{-hmin}} due to geometrical constraints.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nbvx=}} Maximum number of vertices generated by the mesh generator (9000 is the default).

\item {} 
\sphinxcode{\sphinxupquote{nbsmooth=}} number of iterations of the smoothing procedure (5 is the default).

\item {} 
\sphinxcode{\sphinxupquote{nbjacoby=}} number of iterations in a smoothing procedure during the metric construction, 0 means no smoothing, 6 is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ratio=}} ratio for a prescribed smoothing on the metric.}] \leavevmode
If the value is 0 or less than 1.1 no smoothing is done on the metric. 1.8 is the default.
If \sphinxcode{\sphinxupquote{ratio \textgreater{} 1.1}}, the speed of mesh size variations is bounded by \(log(\mathtt{ratio})\).

\begin{sphinxadmonition}{note}{Note:}
As \sphinxcode{\sphinxupquote{ratio}} gets closer to 1, the number of generated vertices increases.
This may be useful to control the thickness of refined regions near shocks or boundary layers.
\end{sphinxadmonition}

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{omega=}} relaxation parameter for the smoothing procedure. 1.0 is the default.

\item {} 
\sphinxcode{\sphinxupquote{iso=}} If true, forces the metric to be isotropic. \sphinxcode{\sphinxupquote{false}} is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{abserror=}} If false, the metric is evaluated using the criteria of equi-repartion of relative error.}] \leavevmode
\sphinxcode{\sphinxupquote{false}} is the default.
In this case the metric is defined by:
\begin{equation*}
\begin{split}\mathcal{M} = \left({1\over\mathtt{err}\,\, \mathtt{coef}^2} \quad {
|\mathcal{H}| \over max(\mathtt{CutOff},|\eta|)}\right)^p\end{split}
\end{equation*}
Otherwise, the metric is evaluated using the criteria of equi-distribution of errors.
In this case the metric is defined by:
\begin{equation*}
\begin{split}\mathcal{M} = \left({1\over \mathtt{err}\,\,\mathtt{coef}^2} \quad
{|{\mathcal{H}|} \over
{\sup(\eta)-\inf(\eta)}}\right)^p.\label{eq err abs}\end{split}
\end{equation*}
\end{description}

\item {} 
\sphinxcode{\sphinxupquote{cutoff=}} lower limit for the relative error evaluation.
1.0e-6 is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{verbosity=}} informational messages level (can be chosen between 0 and \(\infty\)).}] \leavevmode
Also changes the value of the global variable verbosity (obsolete).

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{inquire=}} To inquire graphically about the mesh.
\sphinxcode{\sphinxupquote{false}} is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{splitpbedge=}} If true, splits all internal edges in half with two boundary vertices.}] \leavevmode
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{maxsubdiv=}} Changes the metric such that the maximum subdivision of a background edge is bound by \sphinxcode{\sphinxupquote{val}}.}] \leavevmode
Always limited by 10, and 10 is also the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{rescaling=}} if true, the function, with respect to which the mesh is adapted, is rescaled to be between 0 and 1.}] \leavevmode
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{keepbackvertices=}} if true, tries to keep as many vertices from the original mesh as possible.}] \leavevmode
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{IsMetric=}} if true, the metric is defined explicitly.}] \leavevmode
\sphinxcode{\sphinxupquote{false}} is the default.
If the 3 functions \(m_{11}, m_{12}, m_{22}\) are given, they directly define a symmetric matrix field whose Hessian is computed to define a metric.
If only one function is given, then it represents the isotropic mesh size at every point.

For example, if the partial derivatives \sphinxcode{\sphinxupquote{fxx}} (\(=\partial^2 f/\partial x^2\)), \sphinxcode{\sphinxupquote{fxy}} (\(=\partial^2 f/\partial x\partial y\)), \sphinxcode{\sphinxupquote{fyy}} (\(=\partial^2 f/\partial y^2\)) are given, we can set \sphinxcode{\sphinxupquote{Th = adaptmesh(Th, fxx, fxy, fyy, IsMetric=1, nbvx=10000, hmin=hmin);}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{power=}} exponent power of the Hessian used to compute the metric.}] \leavevmode
1 is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{thetamax=}} minimum corner angle in degrees.}] \leavevmode
Default is \(10^\circ\) where the corner is \(ABC\) and the angle is the angle of the two vectors \({AB}, {BC}\), (\(0\) imply no corner, \(90\) imply perpendicular corner, …).

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{splitin2=}} boolean value.}] \leavevmode
If true, splits all triangles of the final mesh into 4 sub-triangles.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} an array of 3 real arrays to set or get metric data information.}] \leavevmode
The size of these three arrays must be the number of vertices.
So if \sphinxcode{\sphinxupquote{m11,m12,m22}} are three P1 finite elements related to the mesh to adapt, you can write: \sphinxcode{\sphinxupquote{metric={[}m11{[}{]},m12{[}{]},m22{[}{]}{]}}} (see file \sphinxcode{\sphinxupquote{convect-apt.edp}} for a full example)

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nomeshgeneration=}} If true, no adapted mesh is generated (useful to compute only a metric).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{periodic=}} Writing \sphinxcode{\sphinxupquote{periodic={[}{[}4,y{]},{[}2,y{]},{[}1,x{]},{[}3,x{]}{]};}} builds an adapted periodic mesh.}] \leavevmode
The sample builds a biperiodic mesh of a square.
(see {\hyperref[\detokenize{documentation/finiteElement:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{periodic finite element spaces}}}}, and see {\hyperref[\detokenize{example/meshGeneration:examplesphere}]{\sphinxcrossref{\DUrole{std,std-ref}{the Sphere example}}}} for a full example)

\end{description}

\end{itemize}

We can use the command \sphinxcode{\sphinxupquote{adaptmesh}} to build a uniform mesh with a constant mesh size.
To build a mesh with a constant mesh size equal to \(\frac{1}{30}\) try:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the initial mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}0.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}1.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//More the one time du to}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Adaptation bound {}`maxsubdiv={}`}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}2.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh4}.png}
\caption{Initial mesh}\label{\detokenize{documentation/meshGeneration:id26}}\label{\detokenize{documentation/meshGeneration:adaptmesh4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh5}.png}
\caption{First iteration}\label{\detokenize{documentation/meshGeneration:id27}}\label{\detokenize{documentation/meshGeneration:adaptmesh5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh6}.png}
\caption{Last iteration}\label{\detokenize{documentation/meshGeneration:id28}}\label{\detokenize{documentation/meshGeneration:adaptmesh6}}\end{subfigure}
\caption{Mesh adaptation}

\end{figure}



\subsubsection{Trunc}
\label{\detokenize{documentation/meshGeneration:trunc}}\label{\detokenize{documentation/meshGeneration:AdaptMesh2}}
Two operators have been introduced to remove triangles from a mesh or to divide them.
Operator \sphinxcode{\sphinxupquote{trunc}} has two parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{label=}} sets the label number of new boundary item, one by default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{split=}} sets the level \(n\) of triangle splitting.}] \leavevmode
Each triangle is split in \(n\times n\), one by default.

\end{description}

\end{itemize}

To create the mesh \sphinxcode{\sphinxupquote{Th3}} where all triangles of a mesh \sphinxcode{\sphinxupquote{Th}} are split in \(3{\times}3\), just write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The following example construct all “trunced” meshes to the support of the basic function of the space \sphinxcode{\sphinxupquote{Vh}} (cf. \sphinxcode{\sphinxupquote{abs(u)\textgreater{}0}}), split all the triangles in \(5{\times} 5\), and put a label number to \(2\) on a new boundary.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Loop on all degrees of freedom}
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// The basis function i}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Sh1} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Sh1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{trunc}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// reset}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.490\linewidth]{{MeshGeneration_Trunc1}.png}
\caption{Mesh of support the function P1 number 0, split in \(5{\times}5\)}\label{\detokenize{documentation/meshGeneration:id29}}\label{\detokenize{documentation/meshGeneration:trunc1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.490\linewidth]{{MeshGeneration_Trunc1}.png}
\caption{Mesh of support the function P1 number 6, split in \(5{\times}5\)}\label{\detokenize{documentation/meshGeneration:id30}}\label{\detokenize{documentation/meshGeneration:trunc6}}\end{subfigure}
\caption{Trunc}

\end{figure}



\subsubsection{Splitmesh}
\label{\detokenize{documentation/meshGeneration:splitmesh}}\label{\detokenize{documentation/meshGeneration:Trunc}}
Another way to split mesh triangles is to use \sphinxcode{\sphinxupquote{splitmesh}}, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NotSplittedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Splitmesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{splitmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SplittedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_SplitMesh1}.png}
\caption{Initial mesh}\label{\detokenize{documentation/meshGeneration:id31}}\label{\detokenize{documentation/meshGeneration:splitmesh1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_SplitMesh2}.png}
\caption{All left mesh triangle is split conformaly in \sphinxcode{\sphinxupquote{int(1+5*(square(x-0.5)+y*y)\textasciicircum{}2}} triangles}\label{\detokenize{documentation/meshGeneration:id32}}\label{\detokenize{documentation/meshGeneration:splitmesh2}}\end{subfigure}
\caption{Split mesh}

\end{figure}



\subsubsection{Meshing Examples}
\label{\detokenize{documentation/meshGeneration:meshing-examples}}\label{\detokenize{documentation/meshGeneration:meshexamples}}\label{\detokenize{documentation/meshGeneration:SplitMesh}}
\begin{sphinxadmonition}{tip}{Tip:}
Two rectangles touching by a side

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TouchSide.esp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_NACA0012_1}.png}
\caption{Two rectangles touching by a side}\label{\detokenize{documentation/meshGeneration:naca00121}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
NACA0012 Airfoil

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{upper}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{lower}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{upper}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lower}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NACA0012.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_NACA0012_2}.png}
\caption{NACA0012 Airfoil}\label{\detokenize{documentation/meshGeneration:naca00122}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Cardioid

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cardioid.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Cardioid1}.png}
\caption{Domain with Cardioid curve boundary}\label{\detokenize{documentation/meshGeneration:cardioid1}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Cassini Egg

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cassini.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Cardioid2}.png}
\caption{Domain with Cassini egg curve boundary}\label{\detokenize{documentation/meshGeneration:cardioid2}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
By cubic Bezier curve

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// A cubic Bezier curve connecting two points with two control points}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{bzi}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{p0}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{p1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q2}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{p0}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{q1}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{q2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p1}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p00} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.95}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{q30} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G3}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bezier.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Bezier}.png}
\caption{Boundary drawn by Bezier curves}\label{\detokenize{documentation/meshGeneration:bezier}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Section of Engine

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{a} \PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L7}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L8}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L3}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L4}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L5}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L6}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L7}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L8}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Engine.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Engine}.png}
\caption{Section of Engine}\label{\detokenize{documentation/meshGeneration:engine}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Domain with U-shape channel

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//width of U\PYGZhy{}shape}
\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{R}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{T}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{U\PYGZhy{}shape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_UShape}.png}
\caption{Domain with U-shape channel changed by :freefem{}`d{}`}\label{\detokenize{documentation/meshGeneration:ushape}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Domain with V-shape cut

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{dAg} \PYG{o}{=} \PYG{l+m+mf}{0.02}\PYG{p}{;} \PYG{c+c1}{//angle of V\PYGZhy{}shape}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{dAg}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pa}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{seg1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{seg2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{seg1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{seg2}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{V\PYGZhy{}shape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_VShape}.png}
\caption{Domain with V-shape cut changed by \sphinxcode{\sphinxupquote{dAg}}}\label{\detokenize{documentation/meshGeneration:vshape}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Smiling face

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{F}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{E1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{E2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{st}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{F}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C4}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C0}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{E1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{E2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SmileFace.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_SmilingFace}.png}
\caption{Smiling face (Mouth is changeable)}\label{\detokenize{documentation/meshGeneration:smilingface}}\end{figure}
\end{sphinxadmonition}

. tip:: 3 points bending
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Square for Three\PYGZhy{}Point Bend Specimens fixed on Fix1, Fix2}
\PYG{c+c1}{// It will be loaded on Load.}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{m} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Load}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Fix1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Fix2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Load}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThreePoint.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{MeshGeneration_Example_ThreePoints}.png}
\caption{Domain for three-point bending test}\label{\detokenize{documentation/meshGeneration:threepoints}}\end{figure}
\end{quote}


\subsubsection{How to change the label of elements and border elements of a mesh}
\label{\detokenize{documentation/meshGeneration:how-to-change-the-label-of-elements-and-border-elements-of-a-mesh}}\label{\detokenize{documentation/meshGeneration:meshgenerationchangelabel}}
Changing the label of elements and border elements will be done using the keyword \sphinxcode{\sphinxupquote{change}}.
The parameters for this command line are for two dimensional and three dimensional cases:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{label =}} is a vector of integer that contains successive pairs of the old label number to the new label number.

\item {} 
\sphinxcode{\sphinxupquote{region =}} is a vector of integer that contains successive pairs of the old region number to new region number.

\item {} 
\sphinxcode{\sphinxupquote{flabel =}} is an integer function given the new value of the label.

\item {} 
\sphinxcode{\sphinxupquote{fregion=}} is an integer function given the new value of the region.

\end{itemize}

These vectors are composed of \(n_{l}\) successive pairs of numbers \(O,N\) where \(n_{l}\) is the number (label or region) that we want to change.
For example, we have :
\begin{equation}\label{equation:documentation/meshGeneration:eq.org.vector.change.label}
\begin{split}\mathtt{label} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]\end{split}
\end{equation}
An example of using this function is given here:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the label of Edges 2 in 0.}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the label of Edges 4 in 0.}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Th1} \PYG{o}{+} \PYG{n}{Th2}\PYG{p}{;} \PYG{c+c1}{//\PYGZsq{}gluing together\PYGZsq{} of meshes Th1 and Th2}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nb lab = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}
     \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// Definition of a macro}

\PYG{k+kt}{solve} \PYG{k+kr}{P}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{“gluing” different mesh} In line 17 of the previous file, the method to “gluing” different meshes of the same dimension in \sphinxstylestrong{FreeFEM} is using.
This function is the operator “+” between meshes.
The method implemented needs the point in adjacent meshes to be the same.


\subsubsection{Mesh in three dimensions}
\label{\detokenize{documentation/meshGeneration:mesh-in-three-dimensions}}

\subsection{Cube}
\label{\detokenize{documentation/meshGeneration:cube}}
A new function \sphinxcode{\sphinxupquote{cube}} like the function \sphinxcode{\sphinxupquote{square}} in 2d is the simple way to a build cubic object, in plugin \sphinxcode{\sphinxupquote{msh3}} (need \sphinxcode{\sphinxupquote{load "msh3"}}).

The following code generates a \(3\times 4 \times 5\) grid in the unit cube \([0, 1]^3\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

By default the labels are :
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
face \(y=0\),

\item {} 
face \(x=1\),

\item {} 
face \(y=1\),

\item {} 
face \(x=0\),

\item {} 
face \(z=0\),

\item {} 
face \(z=1\)

\end{enumerate}

and the region number is \(0\).

A full example of this function to build a mesh of cube \(]-1,1[^3\) with face label given by \((ix + 4*(iy+1) + 16*(iz+1))\) where \((ix, iy, iz)\) are the coordinates of the barycenter of the current face, is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l6} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{57}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{r11} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l6}\PYG{p}{,} \PYG{k+kp}{flags} \PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, border area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sx} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sy} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sz} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sx}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sy}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sz}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ix} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iy}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{16}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//value of ix,iy,iz =\PYGZgt{} face min 0, face max 2, no face 1}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, s = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ix} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ii} \PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{real} \PYG{n}{volr11} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume region = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{volr11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{volr11} \PYG{o}{\PYGZhy{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nb err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nl}{Enter}\PYG{o}{:} \PYG{n+nl}{BuildCube}\PYG{o}{:} \PYG{l+m+mi}{3}
  \PYG{n}{kind} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{k+kr}{n} \PYG{n}{tet} \PYG{n}{Cube} \PYG{o}{=} \PYG{l+m+mi}{6} \PYG{o}{/} \PYG{k+kr}{n} \PYG{n}{slip} \PYG{l+m+mi}{6} \PYG{l+m+mi}{19}
\PYG{n}{Cube}  \PYG{k+kr}{nv}\PYG{o}{=}\PYG{l+m+mi}{210} \PYG{k+kr}{nt}\PYG{o}{=}\PYG{l+m+mi}{720} \PYG{k+kr}{nbe}\PYG{o}{=}\PYG{l+m+mi}{296}
\PYG{n+nl}{Out}\PYG{o}{:}  \PYG{n}{BuildCube}
\PYG{n}{Volume} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{k+kt}{border} \PYG{k+kr}{area} \PYG{o}{=} \PYG{l+m+mi}{24}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{110} \PYG{o}{:} \PYG{l+m+mi}{25}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{101} \PYG{o}{:} \PYG{l+m+mi}{37}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mo}{011} \PYG{o}{:} \PYG{l+m+mi}{40}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{211} \PYG{o}{:} \PYG{l+m+mi}{42}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{121} \PYG{o}{:} \PYG{l+m+mi}{45}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{57}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{112} \PYG{o}{:} \PYG{l+m+mi}{57}
\PYG{n}{Volume} \PYG{k+kr}{region} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{o}{:} \PYG{l+m+mi}{8}
\PYG{n}{Nb} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Cube}.jpg}
\caption{The mesh 3d of function \sphinxcode{\sphinxupquote{cube(4, 5, 6, flags=3)}}}\label{\detokenize{documentation/meshGeneration:meshgeneration-cube}}\end{figure}


\subsection{Read/Write Statements for a Mesh in 3D}
\label{\detokenize{documentation/meshGeneration:read-write-statements-for-a-mesh-in-3d}}\label{\detokenize{documentation/meshGeneration:meshreadwrite3d}}
In three dimensions, the file mesh format supported for input and output files by \sphinxstylestrong{FreeFEM} are the extension .msh and .mesh.
These formats are described in the {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.

\sphinxstylestrong{Extension file .msh} The structure of the files with extension .msh in 3D is given by:
\begin{equation*}
\begin{split}\begin{array}{cccccc}
    n_v & n_{tet} & n_{tri} & & \\
    q^1_x & q^1_y & q^1_z & Vertex label & \\
    q^2_x & q^2_y & q^2_z & Vertex label & \\
    \vdots & \vdots & \vdots & \vdots & \\
    q^{n_v}_x & q^{n_v}_y & q^{n_v}_z & Vertex label & \\
    1_1 & 1_2 & 1_3 & 1_4 & region label \\
    2_1 & 2_2 & 2_3 & 2_4 & region label \\
    \vdots & \vdots & \vdots & \vdots & \vdots \\
    (n_{tet})_1 & (n_{tet})_2 & (n_{tet})_3 & (n_{tet})_4 & region label \\
    1_1 & 1_2 & 1_3 & boundary label & \\
    2_1 & 2_2 & 2_3 & boundary label & \\
    \vdots & \vdots & \vdots & \vdots & \\
    (n_tri)_{1} & (n_{tri})_2 & (n_{tri})_3 & boundary label & \\
\end{array}\end{split}
\end{equation*}
In this structure, \(n_v\) denotes the number of vertices, \(n_{tet}\) the number of tetrahedra and \(n_{tri}\) the number of triangles.

For each vertex \(q^i,\, i=1,\cdots,n_v\), we denote by \((q^i_x,q^i_y,q^i_z)\) the \(x\)-coordinate, the \(y\)-coordinate and the \(z\)-coordinate.

Each tetrahedra \(T_k, k=1,\cdots,n_{tet}\) has four vertices \(q^{k_1},\, q^{k_2},\,q^{k_3}, \,q^{k_4}\).

The boundary consists of a union of triangles.
Each triangle \(be_j, j=1,\cdots,n_{tri}\) has three vertices \(q^{j_1},\, q^{j_2},\,q^{j_3}\).

\sphinxstylestrong{extension file .mesh} The data structure for a three dimensional mesh is composed of the data structure presented in {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}} and a data structure for the tetrahedra. The tetrahedra of a three dimensional mesh are referred using the following field:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Tetrahedra
NbTetrahedra
Vertex1 Vertex2 Vertex3 Vertex4 Label
...
Vertex1 Vertex2 Vertex3 Vertex4 Label
\end{sphinxVerbatim}

This field is express with the notation of {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.


\subsection{TetGen: A tetrahedral mesh generator}
\label{\detokenize{documentation/meshGeneration:tetgen-a-tetrahedral-mesh-generator}}
\sphinxstylestrong{TetGen}

TetGen is a software developed by Dr. Hang Si of Weierstrass Institute for Applied Analysis and Stochastics in Berlin, Germany \sphinxcite{references:hang2006}.
TetGen is free for research and non-commercial use.
For any commercial license utilization, a commercial license is available upon request to Hang Si.

This software is a tetrahedral mesh generator of a three dimensional domain defined by its boundary.
The input domain takes into account a polyhedral or a piecewise linear complex.
This tetrahedralization is a constrained Delaunay tetrahedralization.

The method used in TetGen to control the quality of the mesh is a Delaunay refinement due to Shewchuk \sphinxcite{references:shewchuk1998}.
The quality measure of this algorithm is the Radius-Edge Ratio (see Section 1.3.1 \sphinxcite{references:hang2006} for more details).
A theoretical bound of this ratio of the Shewchuk algorithm is obtained for a given complex of vertices, constrained segments and facets of surface mesh, with no input angle less than 90 degrees.
This theoretical bound is 2.0.

The launch of TetGen is done with the keyword \sphinxcode{\sphinxupquote{tetg}}.
The parameters of this command line is:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{reftet=}} sets the label of tetrahedra.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} is a vector of integers that contains the old labels number at index \(2i\) and the new labels number at index \(2i+1\) of Triangles.}] \leavevmode
This parameter is initialized as a label for the keyword {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{switch=}} A string expression.}] \leavevmode
This string corresponds to the command line switch of TetGen see Section 3.2 of \sphinxcite{references:hang2006}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nbofholes=}} Number of holes (default value: “size of \sphinxcode{\sphinxupquote{holelist}} / 3”).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{holelist=}} This array corresponds to \sphinxcode{\sphinxupquote{holelist}} of TetGenio data structure \sphinxcite{references:hang2006}.}] \leavevmode
A real vector of size \sphinxcode{\sphinxupquote{3 * nbofholes}}.
In TetGen, each hole is associated with a point inside this domain.
This vector is \(x_{1}^{h}, y_{1}^{h}, z_{1}^{h}, x_{2}^{h}, y_{2}^{h}, z_{2}^{h}, \cdots,\) where \(x_{i}^{h},y_{i}^{h},z_{i}^{h}\) is the associated point with the \(i^{\mathrm{th}}\) hole.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{nbofregions=}} Number of regions (default value: “size of \sphinxcode{\sphinxupquote{regionlist}} / 5”).

\item {} 
\sphinxcode{\sphinxupquote{regionlist=}} This array corresponds to \sphinxcode{\sphinxupquote{regionlist}} of TetGenio data structure \sphinxcite{references:hang2006}.

The attribute and the volume constraint of region are given in this real vector of size \sphinxcode{\sphinxupquote{5 * nbofregions}}.
The \(i^{\mathrm{th}}\) region is described by five elements: \(x-\)coordinate, \(y-\)coordinate and \(z-\)coordinate of a point inside this domain (\(x_{i},y_{i},z_{i}\)); the attribute (\(at_{i}\)) and the maximum volume for tetrahedra (\(mvol_{i}\)) for this region.

The \sphinxcode{\sphinxupquote{regionlist}} vector is: \(x_{1}, y_{1}, z_{1}, at_{1}, mvol_{1}, x_{2}, y_{2}, z_{2}, at_{2}, mvol_{2}, \cdots\).

\item {} 
\sphinxcode{\sphinxupquote{nboffacetcl=}} Number of facets constraints “size of \sphinxcode{\sphinxupquote{facetcl}} / 2”).

\item {} 
\sphinxcode{\sphinxupquote{facetcl=}} This array corresponds to \sphinxcode{\sphinxupquote{facetconstraintlist}} of TetGenio data structure \sphinxcite{references:hang2006}.

The \(i^{th}\) facet constraint is defined by the facet marker \(Ref_{i}^{fc}\) and the maximum area for faces \(marea_{i}^{fc}\).
The \sphinxcode{\sphinxupquote{facetcl}} array is: \(Ref_{1}^{fc}, marea_{1}^{fc}, Ref_{2}^{fc}, marea_{2}^{fc}, \cdots\).

This parameters has no effect if switch \sphinxcode{\sphinxupquote{q}} is not selected.

\end{itemize}

Principal switch parameters in TetGen:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{p}} Tetrahedralization of boundary.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{q}} Quality mesh generation.}] \leavevmode
The bound of Radius-Edge Ratio will be given after the option \sphinxcode{\sphinxupquote{q}}.
By default, this value is 2.0.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{a}} Constructs with the volume constraints on tetrahedra.}] \leavevmode
These volumes constraints are defined with the bound of the previous switch \sphinxcode{\sphinxupquote{q}} or in the parameter \sphinxcode{\sphinxupquote{regionlist}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{A}} Attributes reference to region given in the \sphinxcode{\sphinxupquote{regionlist}}.}] \leavevmode
The other regions have label 0.

\end{description}

The option \sphinxcode{\sphinxupquote{AA}} gives a different label at each region.
This switch works with the option \sphinxcode{\sphinxupquote{p}}.
If option :freefem{}`r{}` is used, this switch has no effect.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{r}} Reconstructs and Refines a previously generated mesh.}] \leavevmode
This character is only used with the command line \sphinxcode{\sphinxupquote{tetgreconstruction}}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{Y}} This switch preserves the mesh on the exterior boundary.

This switch must be used to ensure a conformal mesh between two adjacent meshes.

\item {} 
\sphinxcode{\sphinxupquote{YY}} This switch preserves the mesh on the exterior and interior boundary.

\item {} 
\sphinxcode{\sphinxupquote{C}} The consistency of the result’s mesh is testing by TetGen.

\item {} 
\sphinxcode{\sphinxupquote{CC}} The consistency of the result’s mesh is testing by TetGen and also constrained checks of Delaunay mesh (if \sphinxcode{\sphinxupquote{p}} switch is selected) or the consistency of Conformal Delaunay (if \sphinxcode{\sphinxupquote{q}} switch is selected).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{V}} Give information of the work of TetGen.}] \leavevmode
More information can be obtained in specified \sphinxcode{\sphinxupquote{VV}} or \sphinxcode{\sphinxupquote{VVV}}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{Q}} Quiet: No terminal output except errors

\item {} 
\sphinxcode{\sphinxupquote{M}} The coplanar facets are not merging.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{T}} Sets a tolerance for coplanar test.}] \leavevmode
The default value is \(1e-8\).

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{d}} Intersections of facets are detected.

\end{itemize}

To obtain a tetrahedral mesh with TetGen, we need the surface mesh of a three dimensional domain.
We now give the command line in \sphinxstylestrong{FreeFEM} to construct these meshes.

\sphinxstylestrong{keyword: movemesh23}

A simple method to construct a surface is to place a two dimensional domain in a three dimensional space.
This corresponds to moving the domain by a displacement vector of this form \(\mathbf{\Phi(x,y)} = (\Phi1(x,y), \Phi2(x,y), \Phi3(x,y))\).

The result of moving a two dimensional mesh Th2 by this three dimensional displacement is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The parameters of this command line are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{transfo=}} {[}\(\Phi 1\), \(\Phi 2\), \(\Phi 3\){]} sets the displacement vector of transformation \(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\).

\item {} 
\sphinxcode{\sphinxupquote{label=}} sets an integer label of triangles.

\item {} 
\sphinxcode{\sphinxupquote{orientation=}} sets an integer orientation of mesh.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ptmerge=}} A real expression.}] \leavevmode
When you transform a mesh, some points can be merged.
This parameter is the criteria to define two merging points.
By default, we use
\begin{equation*}
\begin{split}ptmerge \: = \: 1e-7 \: \:Vol( B ),\end{split}
\end{equation*}
\end{description}

where \(B\) is the smallest axis, parallel boxes containing the discretized domain of \(\Omega\) and \(Vol(B)\) is the volume of this box.

\end{itemize}

We can do a “gluing” of surface meshes using the process given in {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{Change section}}}}.
An example to obtain a three dimensional mesh using the command line \sphinxcode{\sphinxupquote{tetg}} and \sphinxcode{\sphinxupquote{movemesh23}} is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{x10} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x11} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y10} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y11} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{ZZ1min} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1max} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x20} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x21} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y20}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y21}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{ZZ2} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX2} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY2min} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY2max} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x30}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x31}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y30}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y31}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX3min} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX3max} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY3} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ3} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thsq1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{35}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x10}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x11}\PYG{o}{\PYGZhy{}}\PYG{n}{x10}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y10}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y11}\PYG{o}{\PYGZhy{}}\PYG{n}{y10}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thsq2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x20}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x21}\PYG{o}{\PYGZhy{}}\PYG{n}{x20}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y20}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y21}\PYG{o}{\PYGZhy{}}\PYG{n}{y20}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thsq3} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x30}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x31}\PYG{o}{\PYGZhy{}}\PYG{n}{x30}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y30}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y31}\PYG{o}{\PYGZhy{}}\PYG{n}{y30}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D to 3D surface}
\PYG{k+kt}{mesh3} \PYG{n}{Th31h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq1}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1max}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th31b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq1}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th32h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX2}\PYG{p}{,} \PYG{n}{YY2max}\PYG{p}{,} \PYG{n}{ZZ2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th32b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX2}\PYG{p}{,} \PYG{n}{YY2min}\PYG{p}{,} \PYG{n}{ZZ2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th33h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq3}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX3max}\PYG{p}{,} \PYG{n}{YY3}\PYG{p}{,} \PYG{n}{ZZ3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th33b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq3}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX3min}\PYG{p}{,} \PYG{n}{YY3}\PYG{p}{,} \PYG{n}{ZZ3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Gluing surfaces}
\PYG{k+kt}{mesh3} \PYG{n}{Th33} \PYG{o}{=} \PYG{n}{Th31h} \PYG{o}{+} \PYG{n}{Th31b} \PYG{o}{+} \PYG{n}{Th32h} \PYG{o}{+} \PYG{n}{Th32b} \PYG{o}{+} \PYG{n}{Th33h} \PYG{o}{+} \PYG{n}{Th33b}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th33}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th33}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Tetrahelize the interior of the cube with TetGen}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.0025}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Thfinal} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th33}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thfinal}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thfinal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Build a mesh of a half cylindrical shell of interior radius 1, and exterior radius 2 and a height of 1.5}
\PYG{k+kt}{func} \PYG{n}{mv2x} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{mv2y} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{mv2z} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Thmv2} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{Thfinal}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{mv2x}\PYG{p}{,} \PYG{n}{mv2y}\PYG{p}{,} \PYG{n}{mv2z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thmv2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thmv2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The command \sphinxcode{\sphinxupquote{movemesh3}} is described in the following section.

\sphinxstylestrong{The keyword tetgtransfo}

This keyword corresponds to a composition of command line \sphinxcode{\sphinxupquote{tetg}} and \sphinxcode{\sphinxupquote{movemesh23}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3surf}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Th3surf = movemesh23(Th2, transfo={[}Phi(1), Phi(2), Phi(3){]})}} and \sphinxcode{\sphinxupquote{Th2}} is the input two dimensional mesh of \sphinxcode{\sphinxupquote{tetgtransfo}}.

The parameters of this command line are, on one hand, the parameters \sphinxcode{\sphinxupquote{label}}, \sphinxcode{\sphinxupquote{switch}}, \sphinxcode{\sphinxupquote{regionlist}}, \sphinxcode{\sphinxupquote{nboffacetcl}}, \sphinxcode{\sphinxupquote{facetcl}} of keyword \sphinxcode{\sphinxupquote{tetg}} and on the other hand, the parameter \sphinxcode{\sphinxupquote{ptmerge}} of keyword \sphinxcode{\sphinxupquote{movemesh23}}.

\begin{sphinxadmonition}{note}{Note:}
To use \sphinxcode{\sphinxupquote{tetgtransfo}}, the result’s mesh of \sphinxcode{\sphinxupquote{movemesh23}} must be a closed surface and define one region only. Therefore, the parameter \sphinxcode{\sphinxupquote{regionlist}} is defined for one region.

An example of this keyword can be found in line 61 of the {\hyperref[\detokenize{example/meshGeneration:examplebuildlayermesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Build layer mesh example}}}}.
\end{sphinxadmonition}

\sphinxstylestrong{The keyword tetgconvexhull}

\sphinxstylestrong{FreeFEM}, using TetGen, is able to build a tetrahedralization from a set of points.
This tetrahedralization is a Delaunay mesh of the convex hull of the set of points.

The coordinates of the points can be initialized in two ways.
The first is a file that contains the coordinate of points \(X_{i}=(x_{i}, y_{i}, z_{i})\).
This file is organized as follows:
\begin{equation*}
\begin{split}\begin{array}{ccc}
n_{v} & & \\
x_{1} & y_{1} & z_{1} \\
x_{2} & y_{2} & z_{2} \\
\vdots &\vdots & \vdots \\
x_{n_v} & y_{n_v} & z_{n_v}
\end{array}\end{split}
\end{equation*}
The second way is to give three arrays that correspond respectively to the \(x-\)coordinates, \(y-\)coordinates and \(z-\)coordinates.

The parameters of this command line are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{switch=}} A string expression.}] \leavevmode
This string corresponds to the command line \sphinxcode{\sphinxupquote{switch}} of TetGen see Section 3.2 of \sphinxcite{references:hang2006}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{reftet=}} An integer expression.}] \leavevmode
Set the label of tetrahedra.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} An integer expression.}] \leavevmode
Set the label of triangles.

\end{description}

\end{itemize}

In the string \sphinxcode{\sphinxupquote{switch}}, we can’t used the option \sphinxcode{\sphinxupquote{p}} and \sphinxcode{\sphinxupquote{q}} of TetGen.


\subsection{Reconstruct/Refine a three dimensional mesh with TetGen}
\label{\detokenize{documentation/meshGeneration:reconstruct-refine-a-three-dimensional-mesh-with-tetgen}}
Meshes in three dimension can be refined using TetGen with the command line \sphinxcode{\sphinxupquote{tetgreconstruction}}.

The parameter of this keyword are
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{region=}} an integer array that changes the region number of tetrahedra.}] \leavevmode
This array is defined as the parameter \sphinxcode{\sphinxupquote{reftet}} in the keyword \sphinxcode{\sphinxupquote{change}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} an integer array that changes the label of boundary triangles.}] \leavevmode
This array is defined as the parameter \sphinxcode{\sphinxupquote{label}} in the keyword \sphinxcode{\sphinxupquote{change}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{sizeofvolume=}} a reel function.}] \leavevmode
This function constraints the volume size of the tetrahedra in the domain (see {\hyperref[\detokenize{documentation/meshGeneration:meshfirstisotropemeshadaptation}]{\sphinxcrossref{\DUrole{std,std-ref}{Isotrope mesh adaption section}}}} to build a 3d adapted mesh).

\end{description}

\end{itemize}

The parameters \sphinxcode{\sphinxupquote{switch}}, \sphinxcode{\sphinxupquote{nbofregions}}, \sphinxcode{\sphinxupquote{regionlist}}, \sphinxcode{\sphinxupquote{nboffacetcl}} and \sphinxcode{\sphinxupquote{facetcl}} of the command line which call TetGen (\sphinxcode{\sphinxupquote{tetg}}) is used for \sphinxcode{\sphinxupquote{tetgrefine}}.

In the parameter \sphinxcode{\sphinxupquote{switch=}}, the character \sphinxcode{\sphinxupquote{r}} should be used without the character \sphinxcode{\sphinxupquote{p}}.

For instance, see the manual of TetGen \sphinxcite{references:hang2006} for effect of \sphinxcode{\sphinxupquote{r}} to other character.

The parameter \sphinxcode{\sphinxupquote{regionlist}} defines a new volume constraint in the region.
The label in the \sphinxcode{\sphinxupquote{regionlist}} will be the previous label of region.

This parameter and \sphinxcode{\sphinxupquote{nbofregions}} can’t be used with the parameter \sphinxcode{\sphinxupquote{sizeofvolume}}.

\sphinxstylestrong{Example refinesphere.edp}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// \PYGZdl{}]\PYGZhy{}pi/2, pi/2[X]0, 2pi[ \PYGZdl{}}

\PYG{c+c1}{// A parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Partial derivative of the parametrization DF}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of the surface of spheres}
\PYG{k+kt}{real} \PYG{n}{Rmin} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1min}\PYG{p}{,} \PYG{n}{f2min}\PYG{p}{,} \PYG{n}{f3min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Contruct the volume}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Refine}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newlabel} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domainrefine} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sphrefine} \PYG{o}{=} \PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3sph}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{newlabel}\PYG{p}{,}
    \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{,} \PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Re\PYGZhy{}Refine}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newlabel2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fsize} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{z}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sphrefine2} \PYG{o}{=} \PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3sph}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{newlabel2}\PYG{p}{,}
    \PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{n}{fsize}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Medit}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{isotroperefine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sphrefine}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{anisotroperefine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sphrefine2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Moving mesh in three dimensions}
\label{\detokenize{documentation/meshGeneration:moving-mesh-in-three-dimensions}}
Meshes in three dimensions can be translated, rotated, and deformed using the command line \sphinxcode{\sphinxupquote{movemesh}} as in the 2D case (see {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationmovemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{section movemesh}}}}).
If \(\Omega\) is tetrahedrized as \(T_{h}(\Omega)\), and \(\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))\) is a displacement vector then \(\Phi(T_{h})\) is obtained by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Phi1}\PYG{p}{,} \PYG{n}{Phi2}\PYG{p}{,} \PYG{n}{Phi3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The parameters of movemesh in three dimensions are:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{region=}} sets the integer labels of the tetrahedra.}] \leavevmode
0 by default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} sets the labels of the border faces.}] \leavevmode
This parameter is initialized as the label for the keyword {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{facemerge=}} An integer expression.}] \leavevmode
When you transform a mesh, some faces can be merged.
This parameter equals to one if the merges’ faces is considered.
Otherwise it equals to zero.
By default, this parameter is equal to 1.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ptmerge =}} A real expression.}] \leavevmode
When you transform a mesh, some points can be merged.
This parameter is the criteria to define two merging points.
By default, we use
\begin{equation*}
\begin{split}ptmerge \: = \: 1e-7 \: \:Vol( B ),\end{split}
\end{equation*}
\end{description}

where \(B\) is the smallest axis parallel boxes containing the discretion domain of \(\Omega\) and \(Vol(B)\) is the volume of this box.

\item {} 
\sphinxcode{\sphinxupquote{orientation =}} An integer expression (1 by default), to reverse or not to reverse the orientation of the tetrahedra if it is not positive.

\end{itemize}

An example of this command can be found in the {\hyperref[\detokenize{example/misc:examplepoissonequation3d}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s equation 3D example}}}}.


\subsection{Layer mesh}
\label{\detokenize{documentation/meshGeneration:layer-mesh}}
In this section, we present the command line to obtain a Layer mesh: \sphinxcode{\sphinxupquote{buildlayers}}.
This mesh is obtained by extending a two dimensional mesh in the \(z\)-axis.

The domain \(\Omega_{3d}\) defined by the layer mesh is equal to \(\Omega_{3d} = \Omega_{2d} \times [zmin, zmax]\) where \(\Omega_{2d}\) is the domain defined by the two dimensional meshes.
\(zmin\) and \(zmax\) are functions of \(\Omega_{2d}\) in \(\R\) that defines respectively the lower surface and upper surface of \(\Omega_{3d}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_LayerMesh}.png}
\caption{Example of Layer mesh in three dimensions.}\label{\detokenize{documentation/meshGeneration:meshgenerationlayermesh}}\end{figure}

For a vertex of a two dimensional mesh \(V_{i}^{2d} = (x_{i},y_{i})\), we introduce the number of associated vertices in the \(z-\)axis \(M_{i}+1\).

We denote by \(M\) the maximum of \(M_{i}\) over the vertices of the two dimensional mesh.
This value is called the number of layers (if \(\forall i, \; M_{i}=M\) then there are \(M\) layers in the mesh of \(\Omega_{3d}\)).
\(V_{i}^{2d}\) generated \(M+1\) vertices which are defined by:
\begin{equation*}
\begin{split}\forall j=0, \ldots, M, \quad V_{i,j}^{3d} = ( x_{i}, y_{i}, \theta_{i}(z_{i,j}) ),\end{split}
\end{equation*}
where \((z_{i,j})_{j=0,\ldots,M}\) are the \(M+1\) equidistant points on the interval \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d})]\):
\begin{equation*}
\begin{split}z_{i,j} = j \: \delta \alpha + zmin(V_{i}^{2d}), \quad \delta \alpha= \frac{ zmax( V_{i}^{2d} ) - zmin( V_{i}^{2d}) }{M}.\end{split}
\end{equation*}
The function \(\theta_{i}\), defined on \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\), is given by:
\begin{equation*}
\begin{split}\theta_{i}(z) = \left \{
\begin{array}{cl}
\theta_{i,0} & \mbox{if} \: z=zmin(V_{i}^{2d}), \\
\theta_{i,j} & \mbox{if} \: z \in ] \theta_{i,j-1}, \theta_{i,j}],\\
\end{array}
\right.\end{split}
\end{equation*}
with \((\theta_{i,j})_{j=0,\ldots,M_{i}}\) are the \(M_{i}+1\) equidistant points on the interval \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\).

Set a triangle \(K=(V_{i1}^{2d}\), \(V_{i2}^{2d}\), \(V_{i3}^{2d})\) of the two dimensional mesh.
\(K\) is associated with a triangle on the upper surface (resp. on the lower surface) of layer mesh:

\(( V_{i1,M}^{3d}, V_{i2,M}^{3d}, V_{i3,M}^{3d} )\) (resp. \(( V_{i1,0}^{3d}, V_{i2,0}^{3d}, V_{i3,0}^{3d})\)).

Also \(K\) is associated with \(M\) volume prismatic elements which are defined by:
\begin{equation*}
\begin{split}\forall j=0,\ldots,M, \quad H_{j} = ( V_{i1,j}^{3d}, V_{i2,j}^{3d}, V_{i3,j}^{3d}, V_{i1,j+1}^{3d}, V_{i2,j+1}^{3d}, V_{i3,j+1}^{3d} ).\end{split}
\end{equation*}
Theses volume elements can have some merged point:
\begin{itemize}
\item {} 
0 merged point : prism

\item {} 
1 merged points : pyramid

\item {} 
2 merged points : tetrahedra

\item {} 
3 merged points : no elements

\end{itemize}

The elements with merged points are called degenerate elements.
To obtain a mesh with tetrahedra, we decompose the pyramid into two tetrahedra and the prism into three tetrahedra.
These tetrahedra are obtained by cutting the quadrilateral face of pyramid and prism with the diagonal which have the vertex with the maximum index (see \sphinxcite{references:hecht1992} for the reason of this choice).

The triangles on the middle surface obtained with the decomposition of the volume prismatic elements are the triangles generated by the edges on the border of the two dimensional mesh.
The label of triangles on the border elements and tetrahedra are defined with the label of these associated elements.

The arguments of \sphinxcode{\sphinxupquote{buildlayers}} is a two dimensional mesh and the number of layers \(M\).

The parameters of this command are:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{zbound=}} \([zmin,zmax]\) where \(zmin\) and \(zmax\) are functions expression.}] \leavevmode
Theses functions define the lower surface mesh and upper mesh of surface mesh.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{coef=}} A function expression between {[}0,1{]}.}] \leavevmode
This parameter is used to introduce degenerate element in mesh.

\end{description}

The number of associated points or vertex \(V_{i}^{2d}\) is the integer part of \(coef(V_{i}^{2d}) M\).

\item {} 
\sphinxcode{\sphinxupquote{region=}} This vector is used to initialize the region of tetrahedra.

This vector contains successive pairs of the 2d region number at index \(2i\) and the corresponding 3d region number at index \(2i+1\), like {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxcode{\sphinxupquote{labelmid=}} This vector is used to initialize the 3d labels number of the vertical face or mid face from the 2d label number.

This vector contains successive pairs of the 2d label number at index \(2i\) and the corresponding 3d label number at index \(2i+1\), like {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxcode{\sphinxupquote{labelup=}} This vector is used to initialize the 3d label numbers of the upper/top face from the 2d region number.

This vector contains successive pairs of the 2d region number at index \(2i\) and the corresponding 3d label number at index \(2i+1\), like {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxcode{\sphinxupquote{labeldown=}} Same as the previous case but for the lower/down face label.

\end{itemize}

Moreover, we also add post processing parameters that allow to moving the mesh.
These parameters correspond to parameters \sphinxcode{\sphinxupquote{transfo}}, \sphinxcode{\sphinxupquote{facemerge}} and \sphinxcode{\sphinxupquote{ptmerge}} of the command line \sphinxcode{\sphinxupquote{movemesh}}.

The vector \sphinxcode{\sphinxupquote{region}}, \sphinxcode{\sphinxupquote{labelmid}}, \sphinxcode{\sphinxupquote{labelup}} and \sphinxcode{\sphinxupquote{labeldown}} These vectors are composed of \(n_{l}\) successive pairs of number \(O_i,N_l\) where \(n_{l}\) is the number (label or region) that we want to get.

An example of this command is given in the {\hyperref[\detokenize{example/meshGeneration:examplebuildlayermesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Build layer mesh example}}}}.

\begin{sphinxadmonition}{tip}{Tip:}
Cube

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Cube.idp}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{func} \PYG{k+kt}{mesh3} \PYG{n}{Cube} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{NN}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{BB}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{z0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{z1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nz} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// 2D mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Thx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// 3D mesh}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{z0}\PYG{p}{,}\PYG{n}{z1}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{labelup} \PYG{o}{=} \PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{labeldown} \PYG{o}{=} \PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{Th}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Unit cube

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NN} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the number of step in each direction}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BB} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the bounding box}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the label of the 6 face left,right, front, back, down, right}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{BB}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_LayerMesh_Example1}.png}
\caption{The mesh of a cube made with \sphinxcode{\sphinxupquote{cube.edp}}}\label{\detokenize{documentation/meshGeneration:meshgenerationlayermeshexample1}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Cone

An axisymtric mesh on a triangle with degenerateness

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{HH} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{nn}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Taxe}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{HH}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Hypo}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{HH}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{RR}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Vert}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{RR}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{HH}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Taxe}\PYG{p}{(}\PYG{n}{HH}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Hypo}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{HH}\PYG{o}{*}\PYG{n}{HH}\PYG{o}{+}\PYG{n}{RR}\PYG{o}{*}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Vert}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// 3D mesh}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nn}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayersT} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n}{RR}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{c+c1}{//number of layers}
\PYG{k+kt}{real} \PYG{n}{zminT} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmaxT} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{c+c1}{//height 2*pi}
\PYG{k+kt}{func} \PYG{n}{fx} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fy} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fz} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r4T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{//trick function:}
\PYG{c+c1}{//The function defined the proportion}
\PYG{c+c1}{//of number layer close to axis with reference MaxLayersT}
\PYG{k+kt}{func} \PYG{n}{deg} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{l+m+mf}{.01}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{/}\PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{HH}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{)}\PYG{o}{/}\PYG{n}{RR}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3T} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{n}{deg}\PYG{p}{,} \PYG{n}{MaxLayersT}\PYG{p}{,}
    \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zminT}\PYG{p}{,} \PYG{n}{zmaxT}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{,} \PYG{n}{fz}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{facemerge}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1T}\PYG{p}{,} \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2T}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cone}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3T}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_LayerMesh_Example2}.png}
\caption{The mesh of a cone made with \sphinxcode{\sphinxupquote{cone.edp}}}\label{\detokenize{documentation/meshGeneration:meshgenerationlayermeshexample2}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Buildlayer mesh

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2} \PYG{o}{=} \PYG{l+m+mi}{98}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a box with one hole and two regions}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r3} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;}  \PYG{c+c1}{//the triangles of uppper surface mesh}
                        \PYG{c+c1}{//generated by the triangle in the 2D region}
                        \PYG{c+c1}{//of mesh Th of label 4 as label 12}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r4} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}\PYG{p}{;}  \PYG{c+c1}{//the triangles of lower surface mesh}
                        \PYG{c+c1}{//generated by the triangle in the 2D region}
                        \PYG{c+c1}{//of mesh Th of label 4 as label 45.}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{r3}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{box 2 regions 1 hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a sphere with TetGen}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{test} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paACQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{test} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{test}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere 2 regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Meshing examples}
\label{\detokenize{documentation/meshGeneration:meshing-examples-1}}\label{\detokenize{documentation/meshGeneration:id13}}
\begin{sphinxadmonition}{tip}{Tip:}
Lake

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// 3D mesh}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,}
    \PYG{k+kp}{coef}\PYG{o}{=}\PYG{k+kr}{max}\PYG{p}{(}\PYG{p}{(}\PYG{n}{zmax}\PYG{o}{\PYGZhy{}}\PYG{n}{zmin}\PYG{p}{)}\PYG{o}{/}\PYG{n}{zmax}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,}
    \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,}\PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,}
    \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,}
    \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{rlow}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Hole region

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0,2pi[}

\PYG{c+c1}{// 3D mesh}
\PYG{c+c1}{//parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//partial derivative of the parametrization}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//construction of the surface of spheres}
\PYG{k+kt}{real} \PYG{n}{Rmin} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1min}\PYG{p}{,} \PYG{n}{f2min}\PYG{p}{,} \PYG{n}{f3min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{Rmax} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3sph2} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1max}\PYG{p}{,} \PYG{n}{f2max}\PYG{p}{,} \PYG{n}{f3max}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//gluing meshse}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n}{Th3sph} \PYG{o}{+} \PYG{n}{Th3sph2}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ TetGen call without hole }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3fin} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sphere with two regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3fin}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ TetGen call with hole }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{hole} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3finhole} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{hole}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sphere with a hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3finhole}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Build a 3d mesh of a cube with a balloon}
\label{\detokenize{documentation/meshGeneration:build-a-3d-mesh-of-a-cube-with-a-balloon}}
First the \sphinxcode{\sphinxupquote{MeshSurface.idp}} file to build boundary mesh of a Hexaedra and of a Sphere:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{mesh3} \PYG{n+nf}{SurfaceHex} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{L}\PYG{p}{,} \PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x1} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{z0} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{z1} \PYG{o}{=} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nz} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{mesh} \PYG{n}{Thx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{ny}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{z0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Thy} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{z0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Thz} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{refX} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Xmin, Ymax faces labels renumbering}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{refY} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Ymin, Ymax faces labesl renumbering}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refz} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{refZ} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Zmin, Zmax faces labels renumbering}

    \PYG{k+kt}{mesh3} \PYG{n}{Thx0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x0}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refx}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thx1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refX}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thy0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thy}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refy}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thy1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thy}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refY}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thz0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thz}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{z0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refz}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Thz1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thz}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{z1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refZ}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Thx0} \PYG{o}{+} \PYG{n}{Thx1} \PYG{o}{+} \PYG{n}{Thy0} \PYG{o}{+} \PYG{n}{Thy1} \PYG{o}{+} \PYG{n}{Thz0} \PYG{o}{+} \PYG{n}{Thz1}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{Th}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{mesh3} \PYG{n+nf}{Sphere} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{R}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{h}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{L}\PYG{p}{,} \PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//]\PYGZhy{}pi/2, pi/2[X]0,2pi[}

    \PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//to store the periodic condition}

    \PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{n}{h}\PYG{o}{/}\PYG{n}{R}\PYG{p}{;} \PYG{c+c1}{//hh mesh size on unite sphere}
    \PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ref} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{mesh3} \PYG{n}{ThS} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{R}\PYG{p}{,} \PYG{n}{f2}\PYG{o}{*}\PYG{n}{R}\PYG{p}{,} \PYG{n}{f3}\PYG{o}{*}\PYG{n}{R}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{k+kp}{orientation}\PYG{p}{,} \PYG{n}{refface}\PYG{o}{=}\PYG{n}{ref}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{ThS}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The test of the two functions and the call to \sphinxcode{\sphinxupquote{TetGen}} mesh generator:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//mesh size on sphere}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThS} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThS}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hex\PYGZhy{}Sphere}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ThHS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{voltet = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{voltet} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube with ball}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_CubeSphere1}.png}
\caption{The surface mesh of the hex with internal sphere}\label{\detokenize{documentation/meshGeneration:id33}}\label{\detokenize{documentation/meshGeneration:meshgenerationcubesphere1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_CubeSphere2}.png}
\caption{The tetrahedral mesh of the cube with internal ball}\label{\detokenize{documentation/meshGeneration:id34}}\label{\detokenize{documentation/meshGeneration:meshgenerationcubesphere2}}\end{subfigure}
\caption{Cube sphere}

\end{figure}



\subsubsection{Medit}
\label{\detokenize{documentation/meshGeneration:medit}}\label{\detokenize{documentation/meshGeneration:CubeSphere}}
The keyword \sphinxcode{\sphinxupquote{medit}} allows to display a mesh alone or a mesh and one or several functions defined on the mesh using the Pascal Frey’s freeware \sphinxcode{\sphinxupquote{medit}}.
\sphinxcode{\sphinxupquote{medit}} opens its own window and uses OpenGL extensively.
Naturally to use this command \sphinxcode{\sphinxupquote{medit}} must be installed.

A vizualisation with \sphinxcode{\sphinxupquote{medit}} of scalar solutions \(f1\) and \(f2\) continuous, piecewise linear and known at the vertices of the mesh Th is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol1 sol2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The first plot named \sphinxcode{\sphinxupquote{sol1}} display f1.
The second plot names \sphinxcode{\sphinxupquote{sol2}} display f2.

The arguments of the function \sphinxcode{\sphinxupquote{medit}} are the name of the differents scenes (separated by a space) of \sphinxcode{\sphinxupquote{medit}}, a mesh and solutions.

Each solution is associated with one scene.
The scalar, vector and symmetric tensor solutions are specified in the format described in the section dealing with the keyword \sphinxcode{\sphinxupquote{savesol}}.

The parameters of this command line are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{order=}} 0 if the solution is given at the center of gravity of elements.}] \leavevmode
1 is the solution is given at the vertices of elements.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{meditff=}} set the name of execute command of medit.}] \leavevmode
By default, this string is medit.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{save=}} set the name of a file \sphinxcode{\sphinxupquote{.sol}} or \sphinxcode{\sphinxupquote{.solb}} to save solutions.

\end{itemize}

This command line allows also to represent two differents meshes and solutions on them in the same windows.
The nature of solutions must be the same.
Hence, we can vizualize in the same window the different domains in a domain decomposition method for instance.
A vizualisation with medit of scalar solutions \(h1\) and \(h2\) at vertices of the mesh Th1 and Th2 respectively are obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol2domain}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th1}\PYG{p}{,} \PYG{n}{h1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
Medit

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Initial Problem:}
\PYG{c+c1}{// Resolution of the following EDP:}
\PYG{c+c1}{// \PYGZhy{}Delta u\PYGZus{}s = f on \PYGZbs{}Omega = \PYGZob{} (x,y) \textbar{} 1 \PYGZlt{}= sqrt(x\PYGZca{}2+y\PYGZca{}2) \PYGZlt{}= 2 \PYGZcb{}}
\PYG{c+c1}{// \PYGZhy{}Delta u\PYGZus{}1 = f1 on \PYGZbs{}Omega\PYGZus{}1 = \PYGZob{} (x,y) \textbar{} 0.5 \PYGZlt{}= sqrt(x\PYGZca{}2+y\PYGZca{}2) \PYGZlt{}= 1. \PYGZcb{}}
\PYG{c+c1}{// u = 1 on Gamma}
\PYG{c+c1}{// Null Neumman condition on Gamma\PYGZus{}1 and on Gamma\PYGZus{}2}
\PYG{c+c1}{// We find the solution u by solving two EDP defined on domain Omega and Omega\PYGZus{}1}
\PYG{c+c1}{// This solution is visualize with medit}

\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Omega}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Omega\PYGZus{}1}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{us}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad2}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap2dOmega} \PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Lap2dOmega1} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f1}\PYG{o}{*}\PYG{n}{v1}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Lap2dOmega}\PYG{p}{;}
\PYG{n}{Lap2dOmega1}\PYG{p}{;}

\PYG{c+c1}{// Plot with medit}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{us}\PYG{p}{,} \PYG{n}{Th1}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{save}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{testsavemedit.solb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Mshmet}
\label{\detokenize{documentation/meshGeneration:mshmet}}\label{\detokenize{documentation/meshGeneration:meshgenerationmshmet}}
Mshmet is a software developed by P. Frey that allows to compute an anisotropic metric based on solutions (i.e. Hessian-based).
This software can return also an isotropic metric.
Moreover, \sphinxcode{\sphinxupquote{mshmet}} can also construct a metric suitable for levelset interface capturing.
The solution can be defined on 2D or 3D structured/unstructured meshes.
For example, the solution can be an error estimate of a FE solution.

Solutions for \sphinxcode{\sphinxupquote{mshmet}} are given as an argument.
The solution can be a \sphinxcode{\sphinxupquote{func}}, a vector \sphinxcode{\sphinxupquote{func}}, a symmetric tensor, a \sphinxcode{\sphinxupquote{fespace}} function, a \sphinxcode{\sphinxupquote{fespace}} vector function and a \sphinxcode{\sphinxupquote{fespace}} symmetric tensor.
The symmetric tensor argument is defined as this type of data for datasol argument.
This software accepts more than one solution.

For example, the metric \(M\) computed with \sphinxcode{\sphinxupquote{mshmet}} for the solution \(u\) defined on the mesh \(Th\) is obtained by writing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//a scalar fespace function}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{M} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The parameters of the keyword \sphinxcode{\sphinxupquote{mshmet}} are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{normalization =}} (b) do a normalization of all solution in \([0,1]\).

\item {} 
\sphinxcode{\sphinxupquote{aniso =}} (b) build anisotropic metric if 1 (default 0: isotropic)

\item {} 
\sphinxcode{\sphinxupquote{levelset =}} (b) build metric for levelset method (default: \sphinxcode{\sphinxupquote{false}})

\item {} 
\sphinxcode{\sphinxupquote{verbosity =}} (l) level of verbosity

\item {} 
\sphinxcode{\sphinxupquote{nbregul =}} (l) number of regularization’s iteration of solutions given (default 0).

\item {} 
\sphinxcode{\sphinxupquote{hmin =}} (d)

\item {} 
\sphinxcode{\sphinxupquote{hmax =}} (d)

\item {} 
\sphinxcode{\sphinxupquote{err =}} (d) level of error.

\item {} 
\sphinxcode{\sphinxupquote{width =}} (d) the width

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric =}} a vector of double.}] \leavevmode
This vector contains an initial metric given to \sphinxcode{\sphinxupquote{mshmet}}.
The structure of the metric vector is described in the next paragraph.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{loptions =}} a vector of integer of size 7.}] \leavevmode
This vector contains the integer parameters of \sphinxcode{\sphinxupquote{mshmet}} (for expert only).
\begin{itemize}
\item {} 
loptions(0): normalization (default 1).

\item {} \begin{description}
\item[{loptions(1): isotropic parameters (default 0).}] \leavevmode
1 for isotropic metric results otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(2): level set parameters (default 0).}] \leavevmode
1 for building level set metric otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(3): debug parameters (default 0).}] \leavevmode
1 for turning on debug mode otherwise 0.

\end{description}

\item {} 
loptions(4): level of verbosity (default 10).

\item {} 
loptions(5): number of regularization’s iteration of solutions given (default 0).

\item {} \begin{description}
\item[{loptions(6): previously metric parameter (default 0).}] \leavevmode
1 for using previous metric otherwise 0.

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{doptions=}} a vector of double of size 4.}] \leavevmode
This vector contains the real parameters of \sphinxcode{\sphinxupquote{mshmet}} (for expert only).
\begin{itemize}
\item {} 
doptions(0): hmin : min size parameters (default 0.01).

\item {} 
doptions(1): hmax : max size parameters (default 1.0).

\item {} 
doptions(2): eps : tolerance parameters (default 0.01).

\item {} 
doptions(2): width : relative width for Level Set (\(0<w<1\)) (default 0.05).

\end{itemize}

\end{description}

\end{itemize}

The result of the keyword \sphinxcode{\sphinxupquote{mshmet}} is a \sphinxcode{\sphinxupquote{real{[}int{]}}} which contains the metric computed by \sphinxcode{\sphinxupquote{mshmet}} at the different vertices \(V_{i}\) of the mesh.

With \(nv\) is the number of vertices, the structure of this vector is:
\begin{equation*}
\begin{split}M_{iso}= (m(V_0), m(V_1), \ldots, m(V_{nv}))^t\end{split}
\end{equation*}
for a isotropic metric \(m\).
For a symmetric tensor metric \(h=\left(\begin{array}{ccc} m_{1 1} & m_{1 2} & m_{1 3}\\ m_{2 1} & m_{2 2} & m_{2 3} \\ m_{3 1} & m_{3 2} & m_{3 3} \end{array}\right)\) , the parameters \sphinxcode{\sphinxupquote{metric}} is:
\begin{equation*}
\begin{split}M_{aniso}= (H(V_{0}), \ldots, H(V_{nv}) )^t\end{split}
\end{equation*}
where \(H(V_{i})\) is the vector of size 6 defined by \([m11,m21,m22,m31,m32,m33]\)

\begin{sphinxadmonition}{tip}{Tip:}
mshmet

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mshmet}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh3}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh3} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh3P1}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh3P1} \PYG{n}{usol}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Problem2}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u3}\PYG{o}{*}\PYG{n}{v3}\PYG{o}{*}\PYG{l+m+mf}{1.0e\PYGZhy{}10}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v3}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Problem2}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u3}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u3}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metric:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{usol}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{usol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{FreeYams}
\label{\detokenize{documentation/meshGeneration:freeyams}}
FreeYams is a surface mesh adaptation software which is developed by P. Frey.
This software is a new version of yams.
The adapted surface mesh is constructed with a geometric metric tensor field.
This field is based on the intrinsic properties of the discrete surface.

Also, this software allows to construct a simplification of a mesh.
This decimation is based on the Hausdorff distance between the initial and the current triangulation.
Compared to the software yams, FreeYams can be used also to produce anisotropic triangulations adapted to levelset simulations.
A technical report on freeYams documentation is available \sphinxhref{https://www.ljll.math.upmc.fr/frey/publications/RT-0252.pdf}{here}.

To call FreeYams in \sphinxstylestrong{FreeFEM}, we used the keyword \sphinxcode{\sphinxupquote{freeyams}}.
The arguments of this function are the initial mesh and/or metric.
The metric with \sphinxcode{\sphinxupquote{freeyams}} are a \sphinxcode{\sphinxupquote{func}}, a \sphinxcode{\sphinxupquote{fespace}} function, a symmetric tensor function, a symmetric tensor \sphinxcode{\sphinxupquote{fespace}} function or a vector of double (\sphinxcode{\sphinxupquote{real{[}int{]}}}).
If the metric is a vector of double, this data must be given in \sphinxcode{\sphinxupquote{metric}} parameter.
Otherwise, the metric is given in the argument.

For example, the adapted mesh of \sphinxcode{\sphinxupquote{Thinit}} defined by the metric \(u\) defined as \sphinxcode{\sphinxupquote{fespace}} function is obtained by writing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Thinit}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{freeyams}\PYG{p}{(}\PYG{n}{Thinit}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The symmetric tensor argument for \sphinxcode{\sphinxupquote{freeyams}} keyword is defined as this type of data for datasol argument.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{aniso=}} (b) aniso or iso metric (default 0, iso)

\item {} 
\sphinxcode{\sphinxupquote{mem=}} (l) memory of for freeyams in Mb (default -1,
freeyams choose)

\item {} 
\sphinxcode{\sphinxupquote{hmin=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{hmax=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{gradation=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{option=}} (l)
\begin{itemize}
\item {} 
0 : mesh optimization (smoothing+swapping)

\item {} 
1 : decimation+enrichment adaptated to a metric map. (default)

\item {} 
-1 : decimation adaptated to a metric map.

\item {} 
2 : decimation+enrichment with a Hausdorff-like method

\item {} 
-2 : decimation with a Hausdorff-like method

\item {} 
4 : split triangles recursively.

\item {} 
9 : No-Shrinkage Vertex Smoothing

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{ridgeangle=}} (d)

\item {} 
\sphinxcode{\sphinxupquote{absolute=}} (b)

\item {} 
\sphinxcode{\sphinxupquote{verbosity=}} (i)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} vector expression.}] \leavevmode
This parameters contains the metric at the different vertices on the initial mesh.
With \(nv\) is the number of vertices, this vector is:

\end{description}
\begin{equation*}
\begin{split}M_{iso}= ( m(V_0), m(V_1), \ldots, m(V_{nv}) )^t\end{split}
\end{equation*}
for a scalar metric \(m\).
For a symmetric tensor metric
\(h=\left(\begin{array}{ccc} m_{1 1} & m_{1 2} & m_{1 3}\\ m_{2 1} & m_{2 2} & m_{2 3} \\ m_{3 1} & m_{3 2} & m_{3 3} \end{array}\right)\), the parameters \sphinxcode{\sphinxupquote{metric}} is:
\begin{equation*}
\begin{split}M_{aniso}= ( H(V_{0}), \ldots, H(V_{nv}) )^t\end{split}
\end{equation*}
where \(H(V_{i})\) is the vector of size 6 defined by \([m11,m21,m22,m31,m32,m33]\)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{loptions=}} a vector of integer of size 13.}] \leavevmode
This vectors contains the integer options of FreeYams. (just for the expert)
\begin{itemize}
\item {} \begin{description}
\item[{loptions(0): anisotropic parameter (default 0).}] \leavevmode
If you give an anisotropic metric 1 otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(1): Finite Element correction parameter (default 0).}] \leavevmode
1 for \sphinxstyleemphasis{no} Finite Element correction otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(2): Split multiple connected points parameter (default 1).}] \leavevmode
1 for splitting multiple connected points otherwise 0.

\end{description}

\item {} 
loptions(3): maximum value of memory size in Mbytes (default -1: the size is given by freeyams).

\item {} \begin{description}
\item[{loptions(4): set the value of the connected component which we want to obtain.}] \leavevmode
(Remark: freeyams give an automatic value at each connected component).

\end{description}

\item {} 
loptions(5): level of verbosity

\item {} \begin{description}
\item[{loptions(6): Create point on straight edge (no mapping) parameter (default 0).}] \leavevmode
1 for creating point on straight edge otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(7): validity check during smoothing parameter.}] \leavevmode
This parameter is only used with No-Shrinkage Vertex Smoothing optimization (optimization option parameter 9).
1 for No validity checking during smoothing otherwise 0.

\end{description}

\item {} 
loptions(8): number of desired’s vertices (default -1).

\item {} 
loptions(9): number of iteration of optimizations (default 30).

\item {} \begin{description}
\item[{loptions(10): no detection parameter (default 0).}] \leavevmode
1 for detecting the ridge on the mesh otherwise 0.
The ridge definition is given in the parameter doptions(12).

\end{description}

\item {} \begin{description}
\item[{loptions(11): no vertex smoothing parameter (default 0).}] \leavevmode
1 for smoothing the vertices otherwise 0.

\end{description}

\item {} 
loptions(12): Optimization level parameter (default 0).

\end{itemize}
\begin{itemize}
\item {} 
0 : mesh optimization (smoothing+swapping)

\item {} 
1 : decimation+enrichment adaptated to a metric map.

\item {} 
-1: decimation adaptated to a metric map.

\item {} 
2 : decimation+enrichment with a Hausdorff-like method

\item {} 
-2: decimation with a Hausdorff-like method

\item {} 
4 : split triangles recursively.

\item {} 
9 : No-Shrinkage Vertex Smoothing

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{doptions=}} a vector of double of size 11.}] \leavevmode
This vectors contains the real options of freeyams.

\end{description}
\begin{itemize}
\item {} 
doptions(0): Set the geometric approximation (Tangent plane deviation) (default 0.01).

\item {} 
doptions(1): Set the lamda parameter (default -1).

\item {} 
doptions(2): Set the mu parmeter (default -1).

\item {} 
doptions(3): Set the gradation value (Mesh density control) (default 1.3).

\item {} 
doptions(4): Set the minimal size(hmin) (default -2.0: the size is automatically computed).

\item {} 
doptions(5): Set the maximal size(hmax) (default -2.0: the size is automatically computed).

\item {} 
doptions(6): Set the tolerance of the control of Chordal deviation (default -2.0).

\item {} 
doptions(7): Set the quality of degradation (default 0.599).

\item {} 
doptions(8): Set the declic parameter (default 2.0).

\item {} 
doptions(9): Set the angular walton limitation parameter (default 45 degree).

\item {} 
doptions(10): Set the angular ridge detection (default 45 degree).

\end{itemize}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
freeyams

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{freeyams}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{freeyams}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SurfaceMesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{mmg3d}
\label{\detokenize{documentation/meshGeneration:mmg3d}}
\begin{sphinxadmonition}{note}{\label{documentation/meshGeneration:index-0}Todo:}
mmg3d-v4.0
\end{sphinxadmonition}

\sphinxhref{http://www.mmgtools.org}{Mmg3d} is a 3D remeshing software developed by C. Dobrzynski and P. Frey.

This software allows to remesh an initial mesh made of tetrahedra.
This initial mesh is adapted to a geometric metric tensor field or to a displacement vector (moving rigid body).
The metric can be obtained with {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationmshmet}]{\sphinxcrossref{\DUrole{std,std-ref}{mshmet}}}}.

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
If no metric is given, an isotropic metric is computed by analyzing the size of the edges in the initial mesh.

\item {} 
If a displacement is given, the vertices of the surface triangles are moved without verifying the geometrical structure of the new surface mesh.

\end{itemize}
\end{sphinxadmonition}

The parameters of \sphinxcode{\sphinxupquote{mmg3d}} are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{options=}} vector expression.}] \leavevmode
This vector contains the option parameters of \sphinxcode{\sphinxupquote{mmg3d}}.
It is a vector of 6 values, with the following meaning:

\end{description}
\begin{itemize}
\item {} 
Optimization parameters : (default 1)

0 : mesh optimization.

1 : adaptation with metric (deletion and insertion vertices) and optimization.

-1 : adaptation with metric (deletion and insertion vertices) without optimization.

4 : split tetrahedra (be careful modify the surface).

9 : moving mesh with optimization.

-9 : moving mesh without optimization.

\item {} 
Debug mode : (default 0)

1 : turn on debug mode.

0 : otherwise.

\item {} 
Specify the size of bucket per dimension (default 64)

\item {} 
Swapping mode : (default 0)

1 : no edge or face flipping.

0 : otherwise.

\item {} 
Insert points mode : (default 0)

1 : no edge splitting or collapsing and no insert points.

0 : otherwise.

\end{itemize}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{4}
\item {} 
Verbosity level (default 3)

\end{enumerate}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{memory=}} integer expression.}] \leavevmode
Set the maximum memory size of new mesh in Mbytes.
By default the number of maximum vertices, tetrahedra and triangles are respectively 500 000, 3000 000, 100000 which represent approximately a memory of 100 Mo.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} vector expression.}] \leavevmode
This vector contains the metric given at \sphinxcode{\sphinxupquote{mmg3d}}.
It is a vector of size \(nv\) or 6 \(nv\) respectively for an isotropic and anisotropic metric where \(nv\) is the number of vertices in the initial mesh.
The structure of \sphinxcode{\sphinxupquote{metric}} vector is described in the {\hyperref[\detokenize{documentation/meshGeneration:meshgenerationmshmet}]{\sphinxcrossref{\DUrole{std,std-ref}{mshmet}}}}.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{displacement=}} \([\Phi1, \Phi2, \Phi3]\) set the displacement vector of the initial mesh \(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{displVect=}} sets the vector displacement in a vector expression.}] \leavevmode
This vector contains the displacement at each point of the initial mesh.
It is a vector of size 3 \(nv\).

\end{description}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
mmg3d

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mmg3d}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Nxyz} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{Nxyz}\PYG{p}{,} \PYG{n}{Bxyz}\PYG{p}{,} \PYG{n}{Lxyz}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{isometric}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{isometric}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.17}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{mmg3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{memory}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kp}{metric}\PYG{o}{=}\PYG{n}{isometric}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Isometric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Falling spheres

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mmg3d}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mf}{11.5}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{opt} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vit}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zero} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{dep} \PYG{o}{=} \PYG{n}{vit}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThSg} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThSd} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{310}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ThSd} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{ThSd}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThSg} \PYG{o}{+} \PYG{n}{ThSd}\PYG{p}{;}\PYG{c+c1}{//gluing surface meshes}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThHS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ThHS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{holes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domaine}\PYG{p}{,} \PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{holes}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Box\PYGZhy{}With\PYGZhy{}two\PYGZhy{}Ball}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{310}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{n}{dep}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Falling loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{it} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{it} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{29}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ITERATION }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Lap}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Sphere falling}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{mmg3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{options}\PYG{o}{=}\PYG{n}{opt}\PYG{p}{,} \PYG{k+kp}{displacement}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zero}\PYG{p}{,} \PYG{n}{zero}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{memory}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{A first 3d isotrope mesh adaptation process}
\label{\detokenize{documentation/meshGeneration:a-first-3d-isotrope-mesh-adaptation-process}}\label{\detokenize{documentation/meshGeneration:meshfirstisotropemeshadaptation}}
\begin{sphinxadmonition}{tip}{Tip:}
Adaptation 3D

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mshmet}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l1111} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//labels}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{errm} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{;} \PYG{c+c1}{//level of error}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l1111}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{l11}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{l01}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{l01}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\textbar{}} \PYG{p}{(}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\textbar{}} \PYG{p}{(}\PYG{k+kr}{z} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//remove the ]0.5,1[\PYGZca{}3 cube}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{usol}\PYG{p}{,} \PYG{n}{h}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u min, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//for resizing h[] because the mesh change}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{normalization}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{aniso}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{nbregul}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{hmin}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{,} \PYG{k+kp}{hmax}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{errm}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{h min, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{errm} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;} \PYG{c+c1}{//change the level of error}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv} \PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{n}{h}\PYG{o}{*}\PYG{n}{h}\PYG{o}{*}\PYG{n}{h}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//rebuild mesh}
    \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{U\PYGZhy{}adap\PYGZhy{}iso\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{ii}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Build a 2d mesh from a isoline}
\label{\detokenize{documentation/meshGeneration:build-a-2d-mesh-from-a-isoline}}
The idea is to get the discretization of an isoline of fluid meshes, this tool can be useful to construct meshes from image.
First, we give an example of the isovalue meshes \(0.2\) of analytical function \(\sqrt{(x-1/2)^2 +(y-1/2)^2}\), on unit square.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the isoline points}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the begin, end couple of lines}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{iso} \PYG{o}{=} \PYG{l+m+mf}{0.2} \PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso} \PYG{o}{=} \PYG{p}{[}\PYG{k+kp}{iso}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//to see the iso line}

    \PYG{k+kt}{int} \PYG{n}{nbc} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{k+kp}{iso}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{isoline}} parameters are \sphinxcode{\sphinxupquote{Th}} the mesh, the expression \(u\), the bidimentionnal array \sphinxcode{\sphinxupquote{xy}} to store the list coordinate of the points.
The list of named parameter are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{iso=}} value of the isoline to compute (0 is the default value)

\item {} 
\sphinxcode{\sphinxupquote{close=}} close the isoline with the border (default \sphinxcode{\sphinxupquote{true}}), we add the part of the mesh border such the value is less than the isovalue

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{smoothing=}} number of smoothing process is the \({l} ^{r} {s}\) where \(l\) is the length of the current line component, \(r\) the ratio, \(s\) is smoothing value.}] \leavevmode
The smoothing default value is 0.

\end{description}

\item {} 
\sphinxcode{\sphinxupquote{ratio=}} the ratio (1 by default).

\item {} 
\sphinxcode{\sphinxupquote{eps=}} relative \(\varepsilon\) (default 1e-10)

\item {} 
\sphinxcode{\sphinxupquote{beginend=}} array to get begin, end couple of each of sub line (resize automatically)

\item {} 
\sphinxcode{\sphinxupquote{file=}} to save the data curve in data file for gnuplot

\end{itemize}

In the array \sphinxcode{\sphinxupquote{xy}} you get the list of vertices of the isoline, each connex line go from \(i= i_0^c ,\dots, i_1^c-1\) with \(i_0^c =be(2*c)\) \(i_1^c =be(2*c+1)\), and where \(x_i= xy(0,i), y_i=yx( 1,i), l_i=xy(2,i)\).

Here \(l_i\) is the length of the line (the origin of the line is point \(i_0^c\)).

The sense of the isoline is such that the upper part is at the left size of the isoline.
So here : the minimum is a point \(0.5,05\) so the curve 1 turn in the clockwise sense, the order of each component are sort such that the number of point by component is decreasing.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of the line component = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nbc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of points = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{.}\PYG{k+kr}{m} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{be = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{be} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

      \PYG{c+c1}{// shows the lines component}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{nbc}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{i0} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
         \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Curve }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
         \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{i0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{i1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ y= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
         \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{i0}\PYG{o}{:}\PYG{n}{i1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{i0}\PYG{o}{:}\PYG{n}{i1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ curve }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{length of last curve = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{.}\PYG{k+kr}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

We also have a new function to easily parametrize a discrete curve defined by the couple \(be, xy\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{Curve0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//component 0}
    \PYG{k+kt}{int} \PYG{n}{i0}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{xy}\PYG{p}{,} \PYG{n}{i0}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Curve 0}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{Curve1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//component 1}
    \PYG{k+kt}{int} \PYG{n}{i0}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{xy}\PYG{p}{,} \PYG{n}{i0}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Curve 1}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Curve1}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//show curve}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Curve1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Secondly, we use this idea to build meshes from an image, we use the plugins \sphinxcode{\sphinxupquote{ppm2rnm}} to read \sphinxcode{\sphinxupquote{pgm}} a gray scale image and then we extract the gray contour at level 0.25.

\begin{sphinxadmonition}{tip}{Tip:}
Leman lake

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ppm2rnm}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{string} \PYG{n}{leman} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LemanLake.pgm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{AreaLac} \PYG{o}{=} \PYG{l+m+mf}{580.03}\PYG{p}{;} \PYG{c+c1}{//in km\PYGZca{}2}
\PYG{k+kt}{real} \PYG{n}{hsize} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nc}\PYG{p}{;} \PYG{c+c1}{//nb of curve}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ff1}\PYG{p}{(}\PYG{n}{leman}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//read image}
    \PYG{c+c1}{//and set it in a rect. array}
    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{.}\PYG{k+kr}{m}\PYG{p}{;}
    \PYG{c+c1}{//build a Cartesian mesh such that the origin is in the right place.}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//warning the numbering of the vertices (x,y) is}
    \PYG{c+c1}{//given by \PYGZdl{}i = x/nx + nx* y/ny \PYGZdl{}}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{f1}\PYG{p}{;}
    \PYG{n}{f1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{;} \PYG{c+c1}{//transform array in finite element functions.}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Curves}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{l+m+mf}{.1}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//The longest isoline: the lake}
\PYG{k+kt}{int} \PYG{n}{ic0} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ic1} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{NC} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ic1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{hsize}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{xl} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{yl} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{Curves}\PYG{p}{,} \PYG{n}{ic0}\PYG{p}{,} \PYG{n}{ic1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZgt{}}\PYG{n}{xl}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{n}{yl}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{G}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{scale} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{AreaLac}\PYG{o}{/}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Km\PYGZca{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{AreaLac} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Km\PYGZca{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{leman.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Isoline1}.jpg}
\caption{The image of the Leman lake meshes}\label{\detokenize{documentation/meshGeneration:id35}}\label{\detokenize{documentation/meshGeneration:meshgenerationisoline1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Isoline2}.png}
\caption{The mesh of the lake}\label{\detokenize{documentation/meshGeneration:id36}}\label{\detokenize{documentation/meshGeneration:meshgenerationisoline2}}\end{subfigure}
\caption{Isoline}\phantomsection\label{\detokenize{documentation/meshGeneration:Isoline}}

\end{figure}

\end{sphinxadmonition}


\section{Finite element}
\label{\detokenize{documentation/finiteElement:finite-element}}\label{\detokenize{documentation/finiteElement:finiteelement}}\label{\detokenize{documentation/finiteElement::doc}}
As stated in \DUrole{xref,std,std-ref}{tutorials}, FEM approximates all functions \(w\) as:
\begin{equation*}
\begin{split}w(x,y)\simeq w_0\phi_0(x,y)+w_1\phi_1(x,y)+\cdots+w_{M-1}\phi_{M-1}(x,y)\end{split}
\end{equation*}
with finite element basis functions \(\phi_k(x,y)\) and numbers \(w_k\) (\(k=0,\cdots,M-1\)).
The functions \(\phi_k(x,y)\) are constructed from the triangle \(T_{i_k}\), and called \sphinxstyleemphasis{shape functions}.

In \sphinxstylestrong{FreeFEM}, the finite element space:
\begin{equation*}
\begin{split}V_h=\left\{w\left|\; w_0\phi_0+w_1\phi_1+\cdots+w_{M-1}\phi_{M-1},\, w_i\in \R\right.\right\}\end{split}
\end{equation*}
is easily created by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or with \(\ell\) pairs of periodic boundary conditions in 2D:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{la1}\PYG{p}{,} \PYG{n}{sa1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{sb1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
              \PYG{p}{[}\PYG{n}{lak}\PYG{p}{,} \PYG{n}{sak}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lbk}\PYG{p}{,} \PYG{n}{sbl}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and in 3D:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{la1}\PYG{p}{,} \PYG{n}{sa1}\PYG{p}{,} \PYG{n}{ta1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{sb1}\PYG{p}{,} \PYG{n}{tb1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
              \PYG{p}{[}\PYG{n}{lak}\PYG{p}{,} \PYG{n}{sak}\PYG{p}{,} \PYG{n}{tak}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lbk}\PYG{p}{,} \PYG{n}{sbl}\PYG{p}{,} \PYG{n}{tbl}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{IDspace}} is the name of the space (e.g. \sphinxcode{\sphinxupquote{Vh}}), \sphinxcode{\sphinxupquote{IDmesh}} is the name of the associated mesh and \sphinxcode{\sphinxupquote{\textless{}IDFE\textgreater{}}} is an identifier of finite element type.

In 2D we have a pair of periodic boundary conditions, if \([la_i, sa_i]\), \([lb_i, sb_i]\) is a pair of \sphinxcode{\sphinxupquote{int}}, and the 2 labels \(la_i\) and \(lb_i\) refer to 2 pieces of boundary to be in equivalence.

If \([la_i, sa_i]\), \([lb_i, sb_i]\) is a pair of \sphinxcode{\sphinxupquote{real}}, then \(sa_i\) and \(sb_i\) give two common abscissa on the two boundary curves, and two points are identified as one if the two abscissa are equal.

In 2D, we have a pair of periodic boundary conditions, if \([la_i, sa_i, ta_i]\), \([lb_i, sb_i, tb_i]\) is a pair of \sphinxcode{\sphinxupquote{int}}, the 2 labels \(la_i\) and \(lb_i\) define the 2 pieces of boundary to be in equivalence.

If \([la_i, sa_i, ta_i]\), \([lb_i, sb_i, tb_i]\) is a pair of \sphinxcode{\sphinxupquote{real}}, then \(sa_i\), \(ta_i\) and \(sb_i\), \(tb_i\) give two common parameters on the two boundary surfaces, and two points are identified as one if the two parameters are equal.

\begin{sphinxadmonition}{note}{Note:}
The 2D mesh of the two identified borders must be the same, so to be sure, use the parameter \sphinxcode{\sphinxupquote{fixedborder=true}} in \sphinxcode{\sphinxupquote{buildmesh}} command (see {\hyperref[\detokenize{documentation/meshGeneration:meshborder}]{\sphinxcrossref{\DUrole{std,std-ref}{fixedborder}}}}).
\end{sphinxadmonition}

As of today, the known types of finite elements are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{{[}P0, P03d{]}}} piecewise constant discontinuous finite element (2d, 3d), the degrees of freedom are the barycenter element value.
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P0}
\begin{split}\P^0_{h} = \left\{ v \in L^2(\Omega) \left|\; \textrm{for all }K \in \mathcal{T}_{h}\;\;\textrm{there is }\alpha_{K}\in \R : \;\; v_{|K} = \alpha_{K } \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P1, P13d{]}}} piecewise linear continuous finite element (2d, 3d), the degrees of freedom are the vertices values.
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1}
\begin{split}\P^1_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h},\ v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P1dc{]}}} piecewise linear discontinuous finite element
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1dc}
\begin{split}\P^1_{dc|h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
Due to an interpolation problem, the degree of freedom is not the vertices but three vertices which move inside \(T(X)= G + .99 (X-G)\) where \(G\) is the barycenter.
\end{sphinxadmonition}

\item {} 
\sphinxcode{\sphinxupquote{{[}P1b, P1b3d{]}}} piecewise linear continuous finite element plus bubble (2d, 3d)

\sphinxstylestrong{The 2D Case:}
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1b}
\begin{split}\P^1_{b|h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\}\end{split}
\end{equation}\end{quote}

\sphinxstylestrong{The 3D Case:}
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:P1b-3d}
\begin{split}\P^1_{b|h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \lambda^{K}_{3} \} \right.\right\}\end{split}
\end{equation}
where \(\lambda^{K}_{i}, i=0,..,d\) are the \(d+1\) barycentric coordinate functions of the element \(K\) (triangle or tetrahedron).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{P1bl,P1bl3d}} piecewise linear continuous finite element plus linear bubble (2d, 3d).

The bubble is built by splitting the \(K\), a barycenter in \(d+1\) sub element. (need \sphinxcode{\sphinxupquote{load "Element\_P1bl"}})

\item {} 
\sphinxcode{\sphinxupquote{{[}P2, P23d{]}}} piecewise \(P_{2}\) continuous finite element (2d, 3d)
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \right.\right\}\end{split}
\end{equation*}
where \(P_{2}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 2\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2b{]}}} piecewise \(P_{2}\) continuous finite element plus bubble
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2dc{]}}} piecewise \(P_{2}\) discontinuous finite element
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{dc|h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \right.\right\}\end{split}
\end{equation*}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
Due to an interpolation problem, the degree of freedom is not the six P2 nodes but six nodes which move inside \(T(X)= G + .99 (X-G)\) where \(G\) is the barycenter.
\end{sphinxadmonition}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2h{]}}} quadratic homogeneous continuous (without \sphinxcode{\sphinxupquote{P1}}).

\item {} 
\sphinxcode{\sphinxupquote{{[}P3{]}}} piecewise \(P_{3}\) continuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P3"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^3_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P3dc{]}}} piecewise \(P_{3}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P3dc"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^3_{dc|h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P4{]}}} piecewise \(P_{4}\) continuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P4"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^4_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h},\ v_{|K} \in P_{4} \right.\right\}\end{split}
\end{equation*}
where \(P_{4}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 4\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P4dc{]}}} piecewise \(P_{4}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P4dc"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^4_{dc|h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{4}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P0Edge{]}}} piecewise \(P_{0}\) discontinuous finite element (2d) contained on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P1Edge{]}}} piecewise \(P_{1}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_1\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P2Edge{]}}} piecewise \(P_{2}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_2\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P3Edge{]}}} piecewise \(P_{3}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_3\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P4Edge{]}}} piecewise \(P_{4}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_4\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P5Edge{]}}} piecewise \(P_{5}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_5\) on each edge of the mesh.

\item {} 
\sphinxcode{\sphinxupquote{{[}P2Morley{]}}} piecewise \(P_{2}\) non conform finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Morley"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3},
\left\{\begin{array}{c}
    v \mbox{ continuous at vertices,}\\
    \p_n{v} \mbox{ continuous at middle of edge,}
\end{array}\right.
\right.\right\}\end{split}
\end{equation*}
where \(P_{2}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 2\).

\begin{sphinxadmonition}{warning}{Warning:}
To build the interplant of a function \(u\) (scalar) for this finite element, we need the function and 2 partial derivatives \((u,u_x, u_y)\), creating this vectorial finite element with 3 components \((u,u_x,u_y)\).
\end{sphinxadmonition}

See our example for solving the BiLaplacien problem:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Morley}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2Morley}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//The Morley finite element space}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{bilaplacien}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n}{bilap} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{bilaplacien}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}HCT{]}}} \(P_3\) \(C^1\) conforms finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_HCT"}}) one 3 sub triangles.
\begin{quote}

Lets call \(\mathcal{T}^\triangle_{h}\) the sub mesh of \(\mathcal{T}_{h}\) where all triangles are split in 3 at the barycenter.
\begin{equation*}
\begin{split}\P^{HCT}_{h} = \left\{ v \in C^1(\Omega) \left|\; \forall K \in \mathcal{T}^\triangle_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).

The degrees of freedom are the values of the normal derivative at the mid-point of each edge \sphinxcite{references:bernadou1980}.

\begin{sphinxadmonition}{warning}{Warning:}
To build the interplant of a function \(u\) (scalar) for this finite element, we need the function and 2 partial derivatives \((u,u_x, u_y)\), creating this vectorial finite element with 3 components \((u,u_x,u_y)\) like in previous finite element.
\end{sphinxadmonition}
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}P2BR{]}}} (needs \sphinxcode{\sphinxupquote{load "BernadiRaugel"}}) the Bernadi Raugel Finite Element is a Vectorial element (2d) with 2 components, see \sphinxcite{references:bernardi1985}.
\begin{quote}

It is a 2D coupled Finite Element, where the Polynomial space is \(P_1^2\) with 3 normal bubble edge functions \((P_2)\).
There are 9 degrees of freedom:
\begin{itemize}
\item {} 
2 components at each of the 3 vertices and

\item {} 
the 3 flux on the 3 edges.

\end{itemize}
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT0, RT03d{]}}} Raviart-Thomas finite element of degree \(0\).
\begin{quote}

\sphinxstylestrong{The 2D Case:}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT0}
\begin{split}RT0_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in \mathcal{T}_{h} ,\ \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}
\sphinxstylestrong{The 3D Case:}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT03d}
\begin{split}RT0_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in \mathcal{T}_{h},\ \mathbf{v}_{|K}(x,y,z) =
\vectthree{\alpha^1_{K}}{\alpha^2_{K}}{\alpha^3_{K}} + \beta_{K}\vectthree{x}{y}{z} \right.\right\}\end{split}
\end{equation}
where by writing \(\textrm{div }\mathbf{w}=\sum_{i=1}^d\p w_i/\p x_i\) with \(\mathbf{w}=(w_i)_{i=1}^d\):
\begin{equation*}
\begin{split}H(\textrm{div})=\left\{\mathbf{w}\in L^{2}(\Omega)^d\left|\textrm{div } \mathbf{w}\in L^{2}(\Omega)\right.\right\}\end{split}
\end{equation*}
and where \(\alpha^1_{K}\), \(\alpha^2_{K}\), \(\alpha^3_{K}\), \(\beta_{K}\) are real numbers.
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT0Ortho{]}}} Raviart-Thomas Orthogonal, or Nedelec finite element type I of degree \(0\) in dimension 2
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:RT0Ortho}
\begin{split}RT0Ortho{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in \mathcal{T}_{h},\ \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}Edge03d{]}}} 3d Nedelec finite element or Edge Element of degree \(0\).
\begin{quote}
\begin{equation*}
\begin{split}Edge0_{h} = \left\{ \mathbf{v} \in H(\textrm{Curl}) \left|\; \forall K \in\mathcal{T}_{h}, \ \mathbf{v}_{|K}(x,y,z) =
    \vectthree{\alpha^1_{K}}{\alpha^2_{K}}{\alpha^3_{K}} + \vectthree{\beta^1_{K}}{\beta^2_{K}}{\beta^3_{K}}\times\vectthree{x}{y}{z} \right.\right\}
:label:eq:Edge03d\end{split}
\end{equation*}
where by writing \(\textrm{curl}\mathbf{w}=\vectthree{\p w_2/\p x_3-\p w_3/\p x_2}{\p w_3/\p x_1-\p w_1/\p x_3}{\p w_1/\p x_2-\p w_2/\p x_1}\) with \(\mathbf{w}=(w_i)_{i=1}^d\):
\begin{equation*}
\begin{split}H(\textrm{curl})=\left\{\mathbf{w}\in L^{2}(\Omega)^d\left|\textrm{curl } \mathbf{w}\in L^{2}(\Omega)^d\right.\right\}\end{split}
\end{equation*}
and \(\alpha^1_{K},\alpha^2_{K},\alpha^3_{K},\beta^1_{K},\beta^2_{K},\beta^3_{K}\) are real numbers.
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}Edge13d{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte3d"}}) 3d Nedelec finite element or Edge Element of degree \(1\).

\item {} 
\sphinxcode{\sphinxupquote{{[}Edge23d{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte3d"}}) 3d Nedelec finite element or Edge Element of degree \(2\).

\item {} 
\sphinxcode{\sphinxupquote{{[}P1nc{]}}} piecewise linear element continuous at the mid-point of the edge only in 2D (Crouzeix-Raviart Finite Element 2D).

\item {} 
\sphinxcode{\sphinxupquote{{[}P2pnc{]}}} piecewise quadratic plus a P3 bubble element with the continuity of the 2 moments on each edge (needs \sphinxcode{\sphinxupquote{load "Element\_P2pnc"}})

\item {} 
\sphinxcode{\sphinxupquote{{[}RT1{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT1}
\begin{split}RT1_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h}, \ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_1^2,P_0, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT1Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT1Ortho}
\begin{split}RT1_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h},\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_1^2,P_0, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT2{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT2}
\begin{split}RT2_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h},\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_2^2, P_1, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}RT2Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:RT2Ortho}
\begin{split}RT2_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h} ,\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_2^2, P_1,\ \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}BDM1{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}}) the Brezzi-Douglas-Marini finite element:
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:BDM1}
\begin{split}BDM1_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h},\ \mathbf{v}_{|K} \in P_1^2\right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}BDM1Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}}) the Brezzi-Douglas-Marini Orthogonal also call Nedelec of type II , finite element
\begin{quote}
\begin{equation}\label{equation:documentation/finiteElement:eq:BDM1Ortho}
\begin{split}BDM1Ortho_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h},\ \mathbf{v}_{|K} \in P_1^2\right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{{[}FEQF{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_QF"}}) the finite element to store functions at default quadrature points (so the quadrature is \sphinxcode{\sphinxupquote{qf5pT}} in 2D and is \sphinxcode{\sphinxupquote{qfV5}} in 3d).
\begin{quote}

For over quadrature you have the following corresponding finite element’s quadrature formula.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{FEQF1}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf1pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF2}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf2pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF5}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf5pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF7}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf7pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF9}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf9pT}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF13d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV1}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF23d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV2}},

\item {} 
\sphinxcode{\sphinxupquote{FEQF53d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV5}}

\end{itemize}
\end{quote}

\end{itemize}

You can use this element to optimize the storage and reuse of functions with a long formula inside an integral for non linear processes.


\subsection{Use of freefem fespace in 2D}
\label{\detokenize{documentation/finiteElement:use-of-freefem-fespace-in-2d}}
With the 2D finite element spaces
\begin{equation*}
\begin{split}X_{h} = \left\{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}X_{ph} = \left\{ v \in X_{h} |\; v\left(\vecttwo{0}{.}\right) = v\left(\vecttwo{1}{.}\right) , v\left(\vecttwo{.}{0}\right) = v\left(\vecttwo{.}{1}\right) \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}M_{h} = \left\{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2} \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}R_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^2)^{2} |\; \forall K \in \mathcal{T}_{h}\quad \mathbf{v}_{|K}(x,y) = \vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \right\}\end{split}
\end{equation*}
when \(\mathcal{T}_h\) is a mesh \(10\times 10\) of the unit square \(]0,1[^2\), we only write in \sphinxstylestrong{FreeFEM}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//bi\PYGZhy{}periodic FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Rh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//vectorial FE}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Xh, Mh, Rh}} expresses finite element spaces (called FE spaces) \(X_h,\, M_h,\, R_h\), respectively.

To use FE-functions \(u_{h},v_{h} \in X_{h}\), \(p_{h},q_{h} \in M_{h}\) and \(U_{h},V_{h} \in R_{h}\), we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}
\PYG{n}{Xph} \PYG{n}{uph}\PYG{p}{,} \PYG{n}{vph}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ph}\PYG{p}{,} \PYG{n}{qh}\PYG{p}{;}
\PYG{n}{Rh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vxh}\PYG{p}{,} \PYG{n}{Vyh}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Xh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uh}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{//array of 10 functions in Xh}
\PYG{n}{Rh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Wxh}\PYG{p}{,} \PYG{n}{Wyh}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//array of 10 functions in Rh}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{//the 6th function at point (0.5, 0.5)}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}               \PYG{c+c1}{//the array of the degree of freedom of the 6th function}
\end{sphinxVerbatim}

The functions \(U_{h}, V_{h}\) have two components so we have
\begin{equation*}
\begin{split}U_{h}=\vecttwo{Uxh}{Uyh} \quad \mbox{and}\quad V_{h}=\vecttwo{Vxh}{Vyh}\end{split}
\end{equation*}

\subsection{Use of fespace in 3D}
\label{\detokenize{documentation/finiteElement:use-of-fespace-in-3d}}
With the 3D finite element spaces
\begin{equation*}
\begin{split}X_{h} = \{ v \in H^{1}(]0,1[^3) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \}\end{split}
\end{equation*}\begin{equation*}
\begin{split}X_{ph} = \left\{ v \in X_{h} |\; v\left(\vecttwo{0}{.}\right) = v\left(\vecttwo{1}{.}\right) , v\left(\vecttwo{.}{0}\right) = v\left(\vecttwo{.}{1}\right) \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}M_{h} = \{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2} \}\end{split}
\end{equation*}\begin{equation*}
\begin{split}R_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^2)^{2} |\; \forall K \in \mathcal{T}_{h}\quad \mathbf{v}_{|K}(x,y) = \vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \right\}\end{split}
\end{equation*}
when \(\mathcal{T}_h\) is a mesh \(10\times 10\times 10\) of the unit cubic \(]0,1[^2\), we write in \sphinxstylestrong{FreeFEM}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//label: 0 up, 1 down, 2 front, 3 left, 4 back, 5 right}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//three\PYGZhy{}periodic FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Rh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT03d}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//vectorial FE}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Xh, Mh, Rh}} expresses finite element spaces (called FE spaces) \(X_h,\, M_h,\, R_h\), respectively.

To define and use FE-functions \(u_{h},v_{h} \in X_{h}\), \(p_{h},q_{h} \in M_{h}\) and \(U_{h},V_{h} \in R_{h}\), we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}
\PYG{n}{Xph} \PYG{n}{uph}\PYG{p}{,} \PYG{n}{vph}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ph}\PYG{p}{,} \PYG{n}{qh}\PYG{p}{;}
\PYG{n}{Rh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{,} \PYG{n}{Uyzh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vxh}\PYG{p}{,} \PYG{n}{Vyh}\PYG{p}{,} \PYG{n}{Vyzh}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Xh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uh}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}             \PYG{c+c1}{//array of 10 functions in Xh}
\PYG{n}{Rh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Wxh}\PYG{p}{,}\PYG{n}{Wyh}\PYG{p}{,}\PYG{n}{Wzh}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// array of 10 functions in Rh}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{//the 6th function at point (0.5, 0.5, 0.5)}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}                   \PYG{c+c1}{//the array of the degree of freedom of the 6th function}
\end{sphinxVerbatim}

The functions \(U_{h}, V_{h}\) have three components, so we have:
\begin{equation*}
\begin{split}U_{h}=\vectthree{Uxh}{Uyh}{Uzh} \quad \mbox{and}\quad V_{h}=\vectthree{Vxh}{Vyh}{Vzh}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
One challenge of the periodic boundary condition is that the mesh must have equivalent faces.

The \sphinxcode{\sphinxupquote{buildlayers}} mesh generator splits each quadrilateral face with the diagonal passing through the vertex with maximum number, so to be sure to have the same mesh one both face periodic the 2D numbering in corresponding edges must be compatible (for example the same variation).

By Default, the numbering of square vertex is correct.

To change the mesh numbering you can use the \sphinxcode{\sphinxupquote{change}} function like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{old2new}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//array set on 0, 1, .., nv\PYGZhy{}1}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{sorder} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{;} \PYG{c+c1}{//choose an order increasing on 4 square borders with x or y}
    \PYG{n+nf}{sort}\PYG{p}{(}\PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{old2new}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build the inverse permutation}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{new2old} \PYG{o}{=} \PYG{n}{old2new}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//inverse the permutation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{renumv}\PYG{o}{=}\PYG{n}{new2old}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The full example is in {\hyperref[\detokenize{example/finiteElement:exampleperiodic3d}]{\sphinxcrossref{\DUrole{std,std-ref}{examples}}}}.
\end{sphinxadmonition}


\subsection{Lagrangian Finite Elements}
\label{\detokenize{documentation/finiteElement:lagrangian-finite-elements}}

\subsubsection{P0-element}
\label{\detokenize{documentation/finiteElement:p0-element}}
For each triangle (d=2) or tetrahedron (d=3) \(T_k\), the basis function \(\phi_k\) in \sphinxcode{\sphinxupquote{Vh(Th, P0)}} is given by:
\begin{equation*}
\begin{split}\phi_k(\mathbf{x})=
\left\{
\begin{array}{cl}
    1 & \textrm{ if }(\mathbf{x})\in T_k\\
    0 & \textrm{ if }(\mathbf{x})\not\in T_k
\end{array}
\right.\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then for vertices \(q^{k_i},\, i=1,2,.. d+1\) in \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}}, \(f_h\) is built as \sphinxcode{\sphinxupquote{fh=}} \(\displaystyle f_h(x,y)=\sum_k f(\frac{\sum_i q^{k_i}}{d+1}) \phi_k\)

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp0}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp0}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) on \sphinxcode{\sphinxupquote{Vh(Th, P0)}} when the mesh \sphinxcode{\sphinxupquote{Th}} is a \(4\times 4\)-grid of \([-1,1]^2\) as in \hyperref[\detokenize{documentation/finiteElement:finiteelementp0p1p2p1nc}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp0p1p2p1nc}}}.


\subsubsection{P1-element}
\label{\detokenize{documentation/finiteElement:p1-element}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{FiniteElement_P1P2}.png}
\caption{\(P_1\) and \(P_2\) degrees of freedom on triangle \(T_k\)}\label{\detokenize{documentation/finiteElement:finiteelementp1p2}}\end{figure}

For each vertex \(q^i\), the basis function \(\phi_i\) in \sphinxcode{\sphinxupquote{Vh(Th, P1)}} is given by:
\begin{equation*}
\begin{split}\phi_i(x,y)&=a^k_i+b^k_ix+c^k_iy \textrm{ for }(x,y)\in T_k,\\
\phi_i(q^i)&=1,\quad \phi_i(q^j)=0 \textrm{ if }i\neq j\end{split}
\end{equation*}
The basis function \(\phi_{k_1}(x,y)\) with the vertex \(q^{k_1}\) in \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}} at point \(p=(x,y)\) in triangle \(T_k\) simply coincide with the \sphinxstyleemphasis{barycentric coordinates} \(\lambda^k_1\) \sphinxstyleemphasis{(area coordinates)}:
\begin{equation*}
\begin{split}\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)=
\frac{\textrm{area of triangle} (p, q^{k_2},q^{k_3})}
{\textrm{area of triangle}(q^{k_1},q^{k_2},q^{k_3})}\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{g}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)\)

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_P0P1P2P1nc}.png}
\caption{Test mesh \sphinxcode{\sphinxupquote{Th}} for projection}\label{\detokenize{documentation/finiteElement:id8}}\label{\detokenize{documentation/finiteElement:finiteelementp0p1p2p1nc}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP0}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P0)}}}\label{\detokenize{documentation/finiteElement:id9}}\label{\detokenize{documentation/finiteElement:finiteelementprojp0}}\end{subfigure}
\caption{Finite element \sphinxcode{\sphinxupquote{P0}}}

\end{figure}



\subsubsection{P2-element}
\label{\detokenize{documentation/finiteElement:p2-element}}\label{\detokenize{documentation/finiteElement:FiniteElement}}
For each vertex or mid-point \(q^i\).
The basis function \(\phi_i\) in \sphinxcode{\sphinxupquote{Vh(Th, P2)}} is given by:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \phi_i(x,y)&=&a^k_i+b^k_ix+c^k_iy+d^k_ix^2+e^k_ixy+f^f_jy^2\textrm{ for }(x,y)\in T_k,\\
    \phi_i(q^i)&=&1,\quad \phi_i(q^j)=0\textrm{ if }i\neq j
\end{array}\end{split}
\end{equation*}
The basis function \(\phi_{k_1}(x,y)\) with the vertex \(q^{k_1}\) in \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}} is defined by the \sphinxstyleemphasis{barycentric coordinates}:
\begin{equation*}
\begin{split}\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)(2\lambda^k_1(x,y)-1)\end{split}
\end{equation*}
and for the mid-point \(q^{k_2}\):
\begin{equation*}
\begin{split}\phi_{k_2}(x,y) = 4\lambda^k_1(x,y)\lambda^k_4(x,y)\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{M}f(q^i)\phi_i(x,y)\quad (\textrm{summation over all vertex or mid-point})\)

See {\hyperref[\detokenize{documentation/finiteElement:finiteelementprojp2}]{\sphinxcrossref{\DUrole{std,std-ref}{Projection to Vh(Th, P2)}}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P2)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1)}}}\label{\detokenize{documentation/finiteElement:id10}}\label{\detokenize{documentation/finiteElement:finiteelementprojp1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP2}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P2)}}}\label{\detokenize{documentation/finiteElement:id11}}\label{\detokenize{documentation/finiteElement:finiteelementprojp2}}\end{subfigure}
\caption{Finite elements \sphinxcode{\sphinxupquote{P1, P2}}}

\end{figure}



\subsection{P1 Nonconforming Element}
\label{\detokenize{documentation/finiteElement:p1-nonconforming-element}}\label{\detokenize{documentation/finiteElement:FiniteElement}}
Refer to \sphinxcite{references:thomasset2012} for details; briefly, we now consider non-continuous approximations so we will lose the property:
\begin{equation*}
\begin{split}w_h\in V_h\subset H^1(\Omega)\end{split}
\end{equation*}
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1nc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(m^i)\phi_i(x,y)\quad (\textrm{summation over all midpoint})\)

Here the basis function \(\phi_i\) associated with the mid-point \(m^i=(q^{k_i}+q^{k_{i+1}})/2\) where \(q^{k_i}\) is the \(i\)-th point in \(T_k\), and we assume that \(j+1=0\) if \(j=3\):
\begin{equation*}
\begin{split}\phi_i(x,y) &= a^k_i+b^k_ix+c^k_iy~\textrm{for }(x,y)\in T_k,\\
\phi_i(m^i) &= 1,\quad \phi_i(m^j)=0\textrm{ if }i\neq j\end{split}
\end{equation*}
Strictly speaking \(\p \phi_i/\p x,\, \p \phi_i/\p y\) contain Dirac distribution \(\rho \delta_{\p T_k}\).

The numerical calculations will automatically \sphinxstyleemphasis{ignore} them.
In \sphinxcite{references:thomasset2012}, there is a proof of the estimation
\begin{equation*}
\begin{split}\left(\sum_{k=1}^{n_v}\int_{T_k}|\nabla w-\nabla w_h|^2\d x\d y\right)^{1/2} =O(h)\end{split}
\end{equation*}
The basis functions \(\phi_k\) have the following properties.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
For the bilinear form \(a\) defined in \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1nc}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1nc}}} satisfy:
\begin{quote}
\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(\phi_i,\phi_i)>0,\qquad a(\phi_i,\phi_j)&\le& 0\quad\textrm{if }i\neq j\\
    \sum_{k=1}^{n_v}a(\phi_i,\phi_k)&\ge& 0
\end{array}\end{split}
\end{equation*}\end{quote}

\item {} 
\(f\ge 0 \Rightarrow u_h\ge 0\)

\item {} 
If \(i\neq j\), the basis function \(\phi_i\) and \(\phi_j\) are \(L^2\)-orthogonal:
\begin{quote}
\begin{equation*}
\begin{split}\int_{\Omega}\phi_i\phi_j\, \d x\d y=0\qquad \textrm{if }i\neq j\end{split}
\end{equation*}
which is false for \(P_1\)-element.
\end{quote}

\end{enumerate}

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1nc}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1nc}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1nc)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1nc}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1nc)}}}\label{\detokenize{documentation/finiteElement:id12}}\label{\detokenize{documentation/finiteElement:finiteelementprojp1nc}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1b}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1b)}}}\label{\detokenize{documentation/finiteElement:id13}}\label{\detokenize{documentation/finiteElement:finiteelementprojp1b}}\end{subfigure}
\caption{Finite elements \sphinxcode{\sphinxupquote{P1nc, P1b}}}

\end{figure}



\subsection{Other FE-space}
\label{\detokenize{documentation/finiteElement:other-fe-space}}\label{\detokenize{documentation/finiteElement:FiniteElement}}
For each triangle \(T_k\in \mathcal{T}_h\), let \(\lambda_{k_1}(x,y),\, \lambda_{k_2}(x,y),\, \lambda_{k_3}(x,y)\) be the area cordinate of the triangle (see \hyperref[\detokenize{documentation/finiteElement:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementp1p2}}}), and put:
\begin{equation*}
\begin{split}\beta_k(x,y)=27\lambda_{k_1}(x,y)\lambda_{k_2}(x,y)\lambda_{k_3}(x,y)\end{split}
\end{equation*}
called \sphinxstyleemphasis{bubble} function on \(T_k\).
The bubble function has the feature: 1. \(\beta_k(x,y)=0\quad \textrm{if }(x,y)\in \p T_k\).
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{1}
\item {} 
\(\beta_k(q^{k_b})=1\) where \(q^{k_b}\) is the barycenter \(\frac{q^{k_1}+q^{k_2}+q^{k_3}}{3}\).

\end{enumerate}

If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)+\sum_{k=1}^{n_t}f(q^{k_b})\beta_k(x,y)\)

See \hyperref[\detokenize{documentation/finiteElement:finiteelementprojp1b}]{Fig.\@ \ref{\detokenize{documentation/finiteElement:finiteelementprojp1b}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1b)}}.


\subsection{Vector Valued FE-function}
\label{\detokenize{documentation/finiteElement:vector-valued-fe-function}}
Functions from \(\R^{2}\) to \(\R^{N}\) with \(N=1\) are called scalar functions and called \sphinxstyleemphasis{vector valued} when \(N>1\).
When \(N=2\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P0}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

makes the space
\begin{equation*}
\begin{split}V_h=\{\mathbf{w}=(w_1,w_2)|\; w_1\in V_h(\mathcal{T}_h,P_0),\,
w_2\in V_h(\mathcal{T}_h,P_1)\}\end{split}
\end{equation*}

\subsubsection{Raviart-Thomas Element}
\label{\detokenize{documentation/finiteElement:raviart-thomas-element}}
In the Raviart-Thomas finite element \(RT0_{h}\), the degrees of freedom are the fluxes across edges \(e\) of the mesh, where the flux of the function \(\mathbf{f} : \R^2 \longrightarrow \R^2\) is \(\int_{e} \mathbf{f}.n_{e}\), \(n_{e}\) is the unit normal of edge \(e\).

This implies an orientation of all the edges of the mesh, for example we can use the global numbering of the edge vertices and we just go from small to large numbers.

To compute the flux, we use a quadrature with one Gauss point, the mid-point of the edge.

Consider a triangle \(T_k\) with three vertices \((\mathbf{a},\mathbf{b},\mathbf{c})\).

Lets denote the vertices numbers by \(i_{a},i_{b},i_{c}\), and define the three edge vectors \(\mathbf{e}^{1},\mathbf{e}^{2},\mathbf{e}^{3}\) by \(sgn(i_{b}-i_{c})(\mathbf{b}-\mathbf{c})\), \(sgn(i_{c}-i_{a})(\mathbf{c}-\mathbf{a})\), \(sgn(i_{a}-i_{b})(\mathbf{a}-\mathbf{b})\).

We get three basis functions:
\begin{equation*}
\begin{split}\boldsymbol{\phi}^{k}_{1}= \frac{sgn(i_{b}-i_{c})}{2|T_k|}(\mathbf{x}-\mathbf{a}),\quad
\boldsymbol{\phi}^{k}_{2}= \frac{sgn(i_{c}-i_{a})}{2|T_k|}(\mathbf{x}-\mathbf{b}),\quad
\boldsymbol{\phi}^{k}_{3}= \frac{sgn(i_{a}-i_{b})}{2|T_k|}(\mathbf{x}-\mathbf{c}),\end{split}
\end{equation*}
where \(|T_k|\) is the area of the triangle \(T_k\).
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{f1h}\PYG{p}{,} \PYG{n}{f2h}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{f1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

then:

\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle \mathbf{f}_h(x,y)=\sum_{k=1}^{n_t}\sum_{l=1}^6 n_{i_lj_l}|\mathbf{e^{i_l}}|f_{j_l}(m^{i_l})\phi_{i_lj_l}\)

where \(n_{i_lj_l}\) is the \(j_l\)-th component of the normal vector \(\mathbf{n}_{i_l}\),
\begin{equation*}
\begin{split}\{m_1,m_2,m_3\} = \left\{\frac{\mathbf{b}+\mathbf{c}}{2},
\frac{\mathbf{a}+\mathbf{c}}{2},
\frac{\mathbf{b}+\mathbf{a}}{2} \right\}\end{split}
\end{equation*}
and \(i_l=\{1,1,2,2,3,3\},\, j_l=\{1,2,1,2,1,2\}\) with the order of \(l\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FiniteElement_RT0}.png}
\caption{Normal vectors of each edge}\label{\detokenize{documentation/finiteElement:finiteelementrt0}}\end{figure}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{uh} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//vectorial FE function}

\PYG{c+c1}{// Change the mesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Xh is unchanged}
\PYG{c+c1}{//Uxh = x; //error: impossible to set only 1 component}
          \PYG{c+c1}{//of a vector FE function}
\PYG{n}{vh} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{;}\PYG{c+c1}{//ok}
\PYG{c+c1}{//and now vh use the 5x5 mesh}
\PYG{c+c1}{//but the fespace of vh is always the 2x2 mesh}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{uh} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//do a interpolation of uh (old) of 5x5 mesh}
        \PYG{c+c1}{//to get the new uh on 10x10 mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vh}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//interpolate vh = ((x\PYGZhy{}1/2)\PYGZca{}2 + y\PYGZca{}2)}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_onoldmesh}.png}
\caption{\sphinxcode{\sphinxupquote{vh}} Iso on mesh \(2\times 2\)}\label{\detokenize{documentation/finiteElement:id14}}\label{\detokenize{documentation/finiteElement:finiteelementonoldmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_onnewmesh}.png}
\caption{\sphinxcode{\sphinxupquote{vh}} Iso on  mesh \(5\times 5\)}\label{\detokenize{documentation/finiteElement:id15}}\label{\detokenize{documentation/finiteElement:finiteelementonnewmesh}}\end{subfigure}
\phantomsection\label{\detokenize{documentation/finiteElement:FiniteElement}}

\end{figure}


To get the value at a point \(x=1,y=2\) of the FE function \sphinxcode{\sphinxupquote{uh}}, or \sphinxcode{\sphinxupquote{{[}Uxh, Uyh{]}}}, one writes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{value}\PYG{p}{;}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get value = uh(2, 4)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get value = Uxh(2, 4)}
\PYG{c+c1}{//OR}
\PYG{k+kr}{x} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//get value = uh(1, 2)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{;} \PYG{c+c1}{//get value = Uxh(1, 2)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uyh}\PYG{p}{;} \PYG{c+c1}{//get value = Uyh(1, 2)}
\end{sphinxVerbatim}

To get the value of the array associated to the FE function \sphinxcode{\sphinxupquote{uh}}, one writes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//get the value of degree of freedom 0}
\PYG{k+kt}{real} \PYG{n}{maxdf} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;} \PYG{c+c1}{//maximum value of degree of freedom}
\PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{c+c1}{//the number of degree of freedom}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{array}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//copy the array of the function uh}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
For a non-scalar finite element function \sphinxcode{\sphinxupquote{{[}Uxh, Uyh{]}}} the two arrays \sphinxcode{\sphinxupquote{Uxh{[}{]}}} and \sphinxcode{\sphinxupquote{Uyh{[}{]}}} are the same array, because the degree of freedom can touch more than one component.
\end{sphinxadmonition}


\subsection{A Fast Finite Element Interpolator}
\label{\detokenize{documentation/finiteElement:a-fast-finite-element-interpolator}}
In practice, one may discretize the variational equations by the Finite Element method.
Then there will be one mesh for \(\Omega_1\) and another one for \(\Omega_2\).
The computation of integrals of products of functions defined on different meshes is difficult.

Quadrature formula and interpolations from one mesh to another at quadrature points are needed.
We present below the interpolation operator which we have used and which is new, to the best of our knowledge.

Let \({\cal T}_{h}^0=\cup_k T^0_k,{\cal T}_{h}^1=\cup_k T^1_k\) be two triangulations of a domain \(\Omega\).
Let:
\begin{equation*}
\begin{split}V({\hbox{{\cal T}}_{h}^i}) =\{ C^0(\Omega_h^i)~:~f|_{T^i_k}\in P_0\},~~~i=0,1\end{split}
\end{equation*}
be the spaces of continuous piecewise affine functions on each triangulation.

Let \(f\in V({\cal T}_{h}^0)\).
The problem is to find \(g\in V({\cal T}_{h}^1)\) such that:
\begin{equation*}
\begin{split}g(q) = f(q) \quad \forall q\hbox{~vertex of ~} {\cal T}_{h}^1\end{split}
\end{equation*}
Although this is a seemingly simple problem, it is difficult to find an efficient algorithm in practice.

We propose an algorithm which is of complexity \(N^1\log N^0\), where \(N^i\) is the number of vertices of \(\cal T_{h}^i\), and which is very fast for most practical 2D applications.

\sphinxstylestrong{Algorithm}

The method has 5 steps.

First a quadtree is built containing all the vertices of the mesh \({\cal T}_{h}^0\) such that in each terminal cell there are at least one, and at most 4, vertices of \({\cal T}_{h}^0\).

For each \(q^1\), vertex of \({\cal T}_{h}^1\) do:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Find the terminal cell of the quadtree containing \(q^1\).

\item {} 
Find the the nearest vertex \(q^0_j\) to \(q^1\) in that cell.

\item {} 
Choose one triangle \(T_k^0\in{\cal T}_{h}^0\) which has \(q^0_j\) for vertex.

\item {} 
Compute the barycentric coordinates \(\{\lambda_j\}_{j=1,2,3}\) of \(q^1\) in \(T^0_k\).
\begin{itemize}
\item {} 
if all barycentric coordinates are positive, go to Step 5

\item {} 
otherwise, if one barycentric coordinate \(\lambda_i\) is negative, replace \(T^0_k\) by the adjacent triangle opposite \(q^0_i\) and go to Step 4.

\item {} 
otherwise, if two barycentric coordinates are negative, take one of the two randomly and replace \(T^0_k\) by the adjacent triangle as above.

\end{itemize}

\item {} 
Calculate \(g(q^1)\) on \(T^0_k\) by linear interpolation of \(f\):
\begin{quote}
\begin{equation*}
\begin{split}g(q^1) = \sum_{j=1,2,3} \lambda_j f(q^0_j)\end{split}
\end{equation*}\end{quote}

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FiniteElement_fastInterpolate}.png}
\caption{To interpolate a function at \(q^0\), the knowledge of the triangle which contains \(q^0\) is needed. The algorithm may start at \(q^1\in T_k^0\) and stall on the boundary (thick line) because the line \(q^0q^1\) is not inside \(\Omega\).
But if the holes are triangulated too (doted line) then the problem does not arise.}\label{\detokenize{documentation/finiteElement:finiteelementfastinterpolate}}\end{figure}

Two problems need to be solved:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{What if :math:{}`q\textasciicircum{}1{}` is not in} \(\Omega^0_h\) \sphinxstyleemphasis{?} Then Step 5 will stop with a boundary triangle.
\begin{quote}

So we add a step which tests the distance of \(q^1\) with the two adjacent boundary edges and selects the nearest, and so on till the distance grows.
\end{quote}

\item {} 
\sphinxstyleemphasis{What if} \(\Omega^0_h\) \sphinxstyleemphasis{is not convex and the marching process of Step 4 locks on a boundary?} By construction Delaunay-Voronoï’s mesh generators always triangulate the convex hull of the vertices of the domain.
\begin{quote}

Therefore, we make sure that this information is not lost when \({\cal T}_{h}^0,{\cal T}_{h}^1\) are constructed and we keep the triangles which are outside the domain on a special list.

That way, in step 5 we can use that list to step over holes if needed.
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Sometimes, in rare cases, the interpolation process misses some points, we can change the search algorithm through a global variable \sphinxcode{\sphinxupquote{searchMethod}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// default value for fast search algorithm}
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// safe search algorithm, uses brute force in case of missing point}
\PYG{c+c1}{// (warning: can be very expensive in cases where a lot of points are outside of the domain)}
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// always uses brute force. It is very computationally expensive.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Step 3 requires an array of pointers such that each vertex points to one triangle of the triangulation.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
The operator \sphinxcode{\sphinxupquote{=}} is the interpolation operator of \sphinxstylestrong{FreeFEM}, the continuous finite functions are extended by continuity to the outside of the domain.

Try the following example :
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thg} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n}{Thg}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ch}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ch} \PYG{n}{us} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Dh}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n+nc}{P2dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dh} \PYG{n}{vs} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Fh}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P2dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Fh} \PYG{n}{ug}\PYG{o}{=}\PYG{n}{us}\PYG{p}{,} \PYG{n}{vg}\PYG{o}{=}\PYG{n}{vs}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{ug}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vs}\PYG{p}{,} \PYG{n}{vg}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_UsUg}.png}
\caption{Extension of a continuous FE-function}\label{\detokenize{documentation/finiteElement:id16}}\label{\detokenize{documentation/finiteElement:finiteelementusug}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_VsVg}.png}
\caption{Extension of discontinuous FE-function}\label{\detokenize{documentation/finiteElement:id17}}\label{\detokenize{documentation/finiteElement:finiteelementvsvg}}\end{subfigure}
\caption{Extension of FE-function}

\end{figure}

\end{quote}
\end{sphinxadmonition}


\subsection{Keywords: Problem and Solve}
\label{\detokenize{documentation/finiteElement:keywords-problem-and-solve}}\label{\detokenize{documentation/finiteElement:Extension}}
For \sphinxstylestrong{FreeFEM}, a problem must be given in variational form, so we need a bilinear form \(a(u,v)\), a linear form \(\ell(f,v)\), and possibly a boundary condition form must be added.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{k+kr}{P} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{l}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{+} \PYG{p}{(}\PYG{k+kp}{boundary} \PYG{n}{condition}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
When you want to formulate the problem and solve it in the same time, you can use the keyword \sphinxcode{\sphinxupquote{solve}}.
\end{sphinxadmonition}


\subsubsection{Weak Form and Boundary Condition}
\label{\detokenize{documentation/finiteElement:weak-form-and-boundary-condition}}
To present the principles of Variational Formulations, also called weak form, for the Partial Differential Equations, let’s take a model problem: a Poisson equation with Dirichlet and Robin Boundary condition.

The problem: Find \(u\) a real function defined on a domain \(\Omega\) of \(\R^d\) \((d=2,3)\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\nabla\cdot(\kappa \nabla u) &=& f & \mbox{ in }\Omega\\
    a u + \kappa \frac{\p u}{\p n} &=& b & \mbox{ on }\Gamma_r\\
    u &=& g & \mbox{ on }\Gamma_d
\end{array}\end{split}
\end{equation*}
where:
\begin{itemize}
\item {} 
if \(d=2\) then \(\nabla.(\kappa \nabla u) = \p_x(\kappa \p_x u ) + \p_y(\kappa \p_y u )\) with \(\p_x u = \frac{\p u}{\p x}\) and \(\p_y u = \frac{\p u}{\p y}\)

\item {} 
if \(d=3\) then \(\nabla.(\kappa \nabla u) = \p_x(\kappa \p_x u) + \p_y(\kappa \p_y u) + \p_z(\kappa \p_z u)\) with \(\p_x u = \frac{\p u}{\p x}\), \(\p_y u = \frac{\p u}{\p y}\) and , \(\p_z u = \frac{\p u}{\p z}\)

\item {} 
The border \(\Gamma=\p \Omega\) is split in \(\Gamma_d\) and \(\Gamma_n\) such that \(\Gamma_d \cap \Gamma_n = \emptyset\) and \(\Gamma_d \cup \Gamma_n = \p \Omega\),

\item {} 
\(\kappa\) is a given positive function, such that \(\exists \kappa_0 \in \R ,\quad 0 < \kappa_0 \leq \kappa\).

\item {} 
\(a\) a given non negative function,

\item {} 
\(b\) a given function.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
This is the well known Neumann boundary condition if \(a=0\), and if \(\Gamma_d\) is empty.

In this case the function appears in the problem just by its derivatives, so it is defined only up to a constant (if \(u\) is a solution then \(u+c\) is also a solution).
\end{sphinxadmonition}

Let \({v}\), a regular test function, null on \(\Gamma_d\), by integration by parts we get:
\begin{equation*}
\begin{split}- \int_{\Omega} \nabla\cdot(\kappa \nabla u) \, {v} \,d\omega
= \int_{\Omega} \kappa \nabla{ v} \cdot \nabla u \,d\omega
- \int_{\Gamma} {v}\kappa \frac{ \p u}{\p \mathbf{n}} \,d\gamma,= \int_{\Omega} f {v} \,d\omega\end{split}
\end{equation*}
where if \(d=2\) the \(\nabla{ v} . \nabla u = (\frac{\p u}{\p x}\frac{\p { v}}{\p x}+\frac{\p u}{\p y}\frac{\p { v}}{\p y})\),

where if \(d=3\) the \(\nabla{ v} . \nabla u = (\frac{\p u}{\p x}\frac{\p { v}}{\p x}+\frac{\p u}{\p y}\frac{\p { v}}{\p y} + \frac{\p u}{\p z}\frac{\p { v}}{\p z})\),

and where \(\mathbf{n}\) is the unitary outer-pointing normal of the \(\Gamma\).

Now we note that \(\kappa \frac{ \p u}{\p n} = - a u + b\) on \(\Gamma_r\) and \(v=0\) on \(\Gamma_d\) and \(\Gamma = \Gamma_d \cup \Gamma_n\) thus:
\begin{equation*}
\begin{split}- \int_{\Gamma} {v}
\kappa \frac{ \p u}{\p n} = \int_{\Gamma_r} a u v - \int_{\Gamma_r} b v\end{split}
\end{equation*}
The problem becomes:

Find \(u \in V_g = \{w \in H^1(\Omega) / w = g \mbox{ on } \Gamma_d \}\) such that:
\begin{equation}\label{equation:documentation/finiteElement:eqn::v-poisson}
\begin{split}{\int_{\Omega} \kappa \nabla{ v} . \nabla u \,d\omega + \int_{\Gamma_r} a u v \,d\gamma = \int_{\Omega} f {v}} \,d\omega
+ \int_{\Gamma_r} b v \,d\gamma , \quad \forall v \in V_0\end{split}
\end{equation}
where \(V_0 = \{v \in H^1(\Omega) / v = 0 \mbox{ on } \Gamma_d \}\)

Except in the case of Neumann conditions everywhere, the problem \eqref{equation:documentation/finiteElement:eqn::v-poisson} is well posed when \(\kappa\geq \kappa_0>0\).

\begin{sphinxadmonition}{note}{Note:}
If we have only the Neumann boundary condition, linear algebra tells us that the right hand side must be orthogonal to the kernel of the operator for the solution to exist.
\begin{quote}

One way of writing the compatibility condition is:
\begin{equation*}
\begin{split}\int_{\Omega} f \,d\omega + \int_{\Gamma} b \,d\gamma=0\end{split}
\end{equation*}
and a way to fix the constant is to solve for \(u \in H^1(\Omega)\) such that:
\begin{equation*}
\begin{split}{\int_{\Omega} (\varepsilon u v \; + \; \kappa \nabla{ v} . \nabla u) \,d\omega
= \int_{\Omega} f {v}} \,d\omega + \int_{\Gamma_r} b v \,d\gamma , \quad \forall v \in H^1(\Omega)\end{split}
\end{equation*}
where \(\varepsilon\) is a small parameter (\(\sim \kappa\; 10^{-10} |\Omega|^{\frac2d}\)).
\end{quote}

Remark that if the solution is of order \(\frac{1}{\varepsilon}\) then the compatibility condition is unsatisfied, otherwise we get the solution such that \(\int_\Omega u = 0\), you can also add a Lagrange multiplier to solve the real mathematical problem like in the {\hyperref[\detokenize{example/finiteElement:examplelagrangemultipliers}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagrange multipliers example}}}}.
\end{sphinxadmonition}

In \sphinxstylestrong{FreeFEM}, the bidimensional problem \eqref{equation:documentation/finiteElement:eqn::v-poisson} becomes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n+nf}{Pw} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{o}{/}\PYG{o}{/}\PYG{n}{int\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{Omega}\PYG{p}{\PYGZcb{}} \PYG{n}{kappa} \PYG{n}{nabla} \PYG{n}{v} \PYG{p}{.} \PYG{n}{nabla} \PYG{n}{u}
        \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} a u v}
        \PYG{n}{a} \PYG{o}{*} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Omega\PYGZcb{} f v}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} b v}
        \PYG{n}{b} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{gd}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)} \PYG{c+c1}{//u = g on Gamma\PYGZus{}d}
    \PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Th}} is a mesh of the bi-dimensional domain \(\Omega\), and \sphinxcode{\sphinxupquote{gd}} and \sphinxcode{\sphinxupquote{gn}} are respectively the boundary labels of boundary \(\Gamma_d\) and \(\Gamma_n\).

And the three dimensional problem \eqref{equation:documentation/finiteElement:eqn::v-poisson} becomes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{]}\PYG{c+c1}{//}
\PYG{k+kt}{problem} \PYG{n}{Pw} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{o}{/}\PYG{o}{/}\PYG{n}{int\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{Omega}\PYG{p}{\PYGZcb{}} \PYG{n}{kappa} \PYG{n}{nabla} \PYG{n}{v} \PYG{p}{.} \PYG{n}{nabla} \PYG{n}{u}
        \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} a u v}
        \PYG{n}{a} \PYG{o}{*} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Omega\PYGZcb{} f v}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} b v}
        \PYG{n}{b} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{gd}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)} \PYG{c+c1}{//u = g on Gamma\PYGZus{}d}
    \PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{Th}} is a mesh of the three dimensional domain \(\Omega\), and \sphinxcode{\sphinxupquote{gd}} and \sphinxcode{\sphinxupquote{gn}} are respectively the boundary labels of boundary \(\Gamma_d\) and \(\Gamma_n\).


\subsection{Parameters affecting solve and problem}
\label{\detokenize{documentation/finiteElement:parameters-affecting-solve-and-problem}}
The parameters are FE functions real or complex, the number \(n\) of parameters is even (\(n=2*k\)), the \(k\) first function parameters are unknown, and the \(k\) last are test functions.

\begin{sphinxadmonition}{note}{Note:}
If the functions are a part of vectorial FE then you must give all the functions of the vectorial FE in the same order (see \DUrole{xref,std,std-ref}{Poisson problem with mixed finite element} for example).
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
Don’t mix complex and real parameters FE function.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{Bug:}

The mixing of multiple \sphinxcode{\sphinxupquote{fespace}} with different periodic boundary conditions are not implemented.

So all the finite element spaces used for tests or unknown functions in a problem, must have the same type of periodic boundary conditions or no periodic boundary conditions.

No clean message is given and the result is unpredictable.
\end{sphinxadmonition}

The parameters are:
\begin{itemize}
\item {} 
\sphinxstylestrong{solver=} \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{CG}}, \sphinxcode{\sphinxupquote{Crout}},  \sphinxcode{\sphinxupquote{Cholesky}}, \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}}, \sphinxcode{\sphinxupquote{UMFPACK}} …
\begin{quote}

The default solver is \sphinxcode{\sphinxupquote{sparsesolver}} (it is equal to \sphinxcode{\sphinxupquote{UMFPACK}} if no other sparse solver is defined) or is set to \sphinxcode{\sphinxupquote{LU}} if no direct sparse solver is available.

The storage mode of the matrix of the underlying linear system depends on the type of solver chosen; for \sphinxcode{\sphinxupquote{LU}} the matrix is sky-line non symmetric, for \sphinxcode{\sphinxupquote{Crout}} the matrix is sky-line symmetric, for \sphinxcode{\sphinxupquote{Cholesky}} the matrix is sky-line symmetric positive definite, for \sphinxcode{\sphinxupquote{CG}} the matrix is sparse symmetric positive, and for \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{UMFPACK}} the matrix is just sparse.
\end{quote}

\item {} 
\sphinxstylestrong{eps=} a real expression.
\begin{quote}

\(\varepsilon\) sets the stopping test for the iterative methods like \sphinxcode{\sphinxupquote{CG}}.

Note that if \(\varepsilon\) is negative then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < |\varepsilon|\end{split}
\end{equation*}
if it is positive, then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < \frac{|\varepsilon|}{|| A x_{0} - b ||}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxstylestrong{init=} boolean expression, if it is false or 0 the matrix is reconstructed.
\begin{quote}

Note that if the mesh changes the matrix is reconstructed too.
\end{quote}

\item {} 
\sphinxstylestrong{precon=} name of a function (for example \sphinxcode{\sphinxupquote{P}}) to set the preconditioner.
\begin{quote}

The prototype for the function \sphinxcode{\sphinxupquote{P}} must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{xx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxstylestrong{tgv=} Huge value (\(10^{30}\)) used to implement Dirichlet boundary conditions.

\item {} 
\sphinxstylestrong{tolpivot=} sets the tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}} (\(10^{-1}\)) and, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorisation (\(10^{-20}\)).

\item {} 
\sphinxstylestrong{tolpivotsym=} sets the tolerance of the pivot sym in \sphinxcode{\sphinxupquote{UMFPACK}}

\item {} 
\sphinxstylestrong{strategy=} sets the integer \sphinxcode{\sphinxupquote{UMFPACK}} strategy (\(0\) by default).

\end{itemize}


\subsection{Problem definition}
\label{\detokenize{documentation/finiteElement:problem-definition}}\label{\detokenize{documentation/finiteElement:problemdefinition}}
Below \sphinxcode{\sphinxupquote{v}} is the unknown function and \sphinxcode{\sphinxupquote{w}} is the test function.

After the “=” sign, one may find sums of:
\begin{itemize}
\item {} 
Identifier(s); this is the name given earlier to the variational form(s) (type \sphinxcode{\sphinxupquote{varf}} ) for possible reuse.
\begin{quote}

Remark, that the name in the \sphinxcode{\sphinxupquote{varf}} of the unknown test function is forgotten, we use the order in the argument list to recall names as in a \sphinxcode{\sphinxupquote{C++}} function,
\end{quote}

\item {} 
The terms of the bilinear form itself: if \(K\) is a given function,

\item {} 
Bilinear part for 3D meshes \sphinxcode{\sphinxupquote{Th}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int3d(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap (\Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intallfaces(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intallfaces(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{{T\in\mathtt{Th},T\subset \Omega_{1}}}\int_{\p T } K\,v\,w\)

\item {} 
They contribute to the sparse matrix of type \sphinxcode{\sphinxupquote{matrix}} which, whether declared explicitly or not, is constructed by \sphinxstylestrong{FreeFEM}.

\end{itemize}

\item {} 
Bilinear part for 2D meshes \sphinxcode{\sphinxupquote{Th}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int2d(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intalledges(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intalledges(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{{T\in\mathtt{Th},T\subset \Omega_{1}}}\int_{\p T } K\,v\,w\)

\item {} 
They contribute to the sparse matrix of type \sphinxcode{\sphinxupquote{matrix}} which, whether declared explicitly or not, is constructed by \sphinxstylestrong{FreeFEM}.

\end{itemize}

\item {} 
The right hand-side of the Partial Differential Equation in 3D, the terms of the linear form: for given functions \(K,\, f\):
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int3d(Th)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, l)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\in\Omega_l}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int3d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5}) } K \,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intallfaces(Th)(f*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } f\,w\)

\item {} 
A vector of type \sphinxcode{\sphinxupquote{real{[}int{]}}}

\end{itemize}

\item {} 
The right hand-side of the Partial Differential Equation in 2D, the terms of the linear form: for given functions \(K,\, f\):
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int2d(Th)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\in\Omega_l}\int_{T} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5}) } K \,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{int1d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxcode{\sphinxupquote{intalledges(Th)(f*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } f\,w\)

\item {} 
a vector of type \sphinxcode{\sphinxupquote{real{[}int{]}}}

\end{itemize}

\item {} 
The boundary condition terms:
\begin{quote}
\begin{itemize}
\item {} 
An “on” scalar form (for Dirichlet) : \sphinxcode{\sphinxupquote{on(1, u=g)}}
\begin{quote}

Used for all degrees of freedom \(i\) of the boundary referred by “1”, the diagonal term of the matrix \(a_{ii}= tgv\) with the \sphinxstyleemphasis{terrible giant value} \sphinxcode{\sphinxupquote{tgv}} (= \(10^{30}\) by default), and the right hand side \(b[i] = "(\Pi_h g)[i]" \times tgv\), where the \("(\Pi_h g)g[i]"\) is the boundary node value given by the interpolation of \(g\).

\begin{sphinxadmonition}{note}{Note:}
if \(\mathrm{tgv} < 0\) then we put to \(0\) all term of the line \(i\) in the matrix, except diagonal term \(a_{ii}=1\), and \(b[i] = "(\Pi_h g)[i]"\).
\end{sphinxadmonition}
\end{quote}

\item {} 
An “on” vectorial form (for Dirichlet): \sphinxcode{\sphinxupquote{on(1, u1=g1, u2=g2)}}

\end{itemize}

If you have vectorial finite element like \sphinxcode{\sphinxupquote{RT0}}, the 2 components are coupled, and so you have : \(b[i] = "(\Pi_h (g1,g2))[i]" \times tgv\), where \(\Pi_h\) is the vectorial finite element interpolant.
\begin{itemize}
\item {} 
A linear form on \(\Gamma\) (for Neumann in 2d) \sphinxcode{\sphinxupquote{-int1d(Th)(f*w)}} or \sphinxcode{\sphinxupquote{-int1d(Th, 3)(f*w)}}

\item {} 
A bilinear form on \(\Gamma\) or \(\Gamma_{2}\) (for Robin in 2d) \sphinxcode{\sphinxupquote{int1d(Th)(K*v*w)}} or \sphinxcode{\sphinxupquote{int1d(Th,2)(K*v*w)}}

\item {} 
A linear form on \(\Gamma\) (for Neumann in 3d) \sphinxcode{\sphinxupquote{-int2d(Th)(f*w)}} or \sphinxcode{\sphinxupquote{-int2d(Th, 3)(f*w)}}

\item {} 
A bilinear form on \(\Gamma\) or \(\Gamma_{2}\) (for Robin in 3d) \sphinxcode{\sphinxupquote{int2d(Th)(K*v*w)}} or \sphinxcode{\sphinxupquote{int2d(Th,2)(K*v*w)}}

\end{itemize}
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
If needed, the different kind of terms in the sum can appear more than once.

\item {} 
The integral mesh and the mesh associated to test functions or unknown functions can be different in the case of linear form.

\item {} 
\sphinxcode{\sphinxupquote{N.x}}, \sphinxcode{\sphinxupquote{N.y}} and \sphinxcode{\sphinxupquote{N.z}} are the normal’s components.

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
It is not possible to write in the same integral the linear part and the bilinear part such as in \sphinxcode{\sphinxupquote{int1d(Th)(K*v*w - f*w)}}.
\end{sphinxadmonition}


\subsection{Numerical Integration}
\label{\detokenize{documentation/finiteElement:numerical-integration}}
Let \(D\) be a \(N\)-dimensional bounded domain.

For an arbitrary polynomial \(f\) of degree \(r\), if we can find particular (quadrature) points \(\mathbf{\xi}_j,\, j=1,\cdots,J\) in \(D\) and (quadrature) constants \(\omega_j\) such that
\begin{equation*}
\begin{split}\int_{D}f(\mathbf{x}) = \sum_{\ell =1}^L c_\ell f(\mathbf{\xi}_\ell)\end{split}
\end{equation*}
then we have an error estimate (see \sphinxcite{references:crouzeix1984}), and then there exists a constant \(C>0\) such that
\begin{equation*}
\begin{split}\left|\int_{D}f(\mathbf{x}) - \sum_{\ell =1}^L \omega_\ell
f(\mathbf{\xi}_\ell )\right|
\le C|D|h^{r+1}\end{split}
\end{equation*}
for any function \(r + 1\) times continuously differentiable \(f\) in \(D\), where \(h\) is the diameter of \(D\) and \(|D|\) its measure (a point in the segment \([q^iq^j]\) is given as
\begin{equation*}
\begin{split}\{(x,y)|\; x=(1-t)q^i_x+tq^j_x,\, y=(1-t)q^i_y+tq^j_y,\, 0\le t\le 1\}\end{split}
\end{equation*}
For a domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Gamma_h=\p\Omega_h\) by:

\(\int_{\Gamma_h}f(\mathbf{x})ds\) =\sphinxcode{\sphinxupquote{int1d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, qfe=*)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, qforder=*)(f)}}

where * stands for the name of the quadrature formula or the precision (order) of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily Quadrature formula on an edge
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\(L\)
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qfe}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
Point in \([q^i, q^j]\)
&\sphinxstyletheadfamily 
\(\omega_\ell\)
&\sphinxstyletheadfamily 
Exact on \(P_k,\ k=\)
\\
\hline
\(1\)
&
\sphinxcode{\sphinxupquote{qf1pE}}
&
\(2\)
&
\(1/2\)
&
\(||q^iq^j||\)
&
\(1\)
\\
\hline
\(2\)
&
\sphinxcode{\sphinxupquote{qf2pE}}
&
\(3\)
&
\((1\pm\sqrt{1/3})/2\)
&
\(||q^iq^j||/2\)
&
\(3\)
\\
\hline
\(3\)
&
\sphinxcode{\sphinxupquote{qf3pE}}
&
\(6\)
&
\((1\pm\sqrt{3/5})/2\)

\(1/2\)
&
\((5/18)||q^iq^j||\)

\((8/18)||q^iq^j||\)
&
\(5\)
\\
\hline
\(4\)
&
\sphinxcode{\sphinxupquote{qf4pE}}
&
\(8\)
&
\((1\pm\frac{525+70\sqrt{30}}{35})/2\)

\((1\pm\frac{525-70\sqrt{30}}{35})/2\)
&
\(\frac{18-\sqrt{30}}{72}||q^iq^j||\)

\(\frac{18+\sqrt{30}}{72}||q^iq^j||\)
&
\(7\)
\\
\hline
\(5\)
&
\sphinxcode{\sphinxupquote{qf5pE}}
&
\(10\)
&
\((1\pm\frac{245+14\sqrt{70}}{21})/2\)

\(1/2\)

\((1\pm\frac{245-14\sqrt{70}}{21})/2\)
&
\(\frac{322-13\sqrt{70}}{1800}||q^iq^j||\)

\(\frac{64}{225}||q^iq^j||\)

\(\frac{322+13\sqrt{70}}{1800}||q^iq^j||\)
&
\(9\)
\\
\hline
\(2\)
&
\sphinxcode{\sphinxupquote{qf1pElump}}
&
\(2\)
&
\(0\)

\(1\)
&
\(||q^iq^j||/2\)

\(||q^iq^j||/2\)
&
\(1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

where \(|q^iq^j|\) is the length of segment \(\overline{q^iq^j}\).

For a part \(\Gamma_1\) of \(\Gamma_h\) with the label “1”, we can calculate the integral over \(\Gamma_1\) by:

\(\int_{\Gamma_1}f(x,y)ds\) =\sphinxcode{\sphinxupquote{int1d(Th, 1)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, 1, qfe=qf2pE)(f)}}

The integrals over \(\Gamma_1,\, \Gamma_3\) are given by:

\(\int_{\Gamma_1\cup \Gamma_3}f(x,y)ds\)

For each triangle \(T_k=[q^{k_1}q^{k_2}q^{k_3}]\), the point \(P(x,y)\) in \(T_k\) is expressed by the \sphinxstyleemphasis{area coordinate} as \(P(\xi,\eta)\):
\begin{equation*}
\begin{split}&|T_k|=\frac12 \left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|\quad
D_1=\left|
\begin{array}{ccc}
    1&x&y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_2=\left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&x&y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_3=\left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&x&y
\end{array}
\right|\\
&\xi=\frac12 D_1/|T_k|\qquad
\eta=\frac12 D_2/|T_k|\qquad \textrm{then }
1-\xi-\eta=\frac12 D_3/|T_k|\end{split}
\end{equation*}
For a two dimensional domain or a border of three dimensional domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Omega_h\) by:

\(\int_{\Omega_h}f(x,y)\) =\sphinxcode{\sphinxupquote{int2d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int2d(Th, qft=*)(f)}}
=\sphinxcode{\sphinxupquote{int2d(Th, qforder=*)(f)}}

where * stands for the name of quadrature formula or the order of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily Quadrature formula on a triangle
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\(L\)
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qft}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
Point in \(T_k\)
&\sphinxstyletheadfamily 
\(\omega_\ell\)
&\sphinxstyletheadfamily 
Exact on \(P_k,\ k=\)
\\
\hline
1
&
\sphinxcode{\sphinxupquote{qf1pT}}
&
2
&
\(\left(\frac{1}{3},\frac{1}{3}\right)\)
&
\(|T_k|\)
&
\(1\)
\\
\hline
3
&
\sphinxcode{\sphinxupquote{qf2pT}}
&
3
&
\(\left(\frac{1}{2},\frac{1}{2}\right)\)

\(\left(\frac{1}{2},0\right)\)

\(\left(0,\frac{1}{2}\right)\)
&
\(|T_k|/3\)

\(|T_k|/3\)

\(|T_k|/3\)
&
\(2\)
\\
\hline
7
&
\sphinxcode{\sphinxupquote{qf5pT}}
&
6
&
\(\left(\frac{1}{3},\frac{1}{3}\right)\)

\(\left(\frac{6-\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)\)

\(\left(\frac{6-\sqrt{15}}{21},\frac{9+2\sqrt{15}}{21}\right)\)

\(\left(\frac{9+2\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)\)

\(\left(\frac{6+\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)\)

\(\left(\frac{6+\sqrt{15}}{21},\frac{9-2\sqrt{15}}{21}\right)\)

\(\left(\frac{9-2\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)\)
&
\(0.225|T_k|\)

\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\(\frac{(155+\sqrt{15})|T_k|}{1200}\)

\(\frac{(155+\sqrt{15})|T_k|}{1200}\)

\(\frac{(155+\sqrt{15})|T_k|}{1200}\)
&
\(5\)
\\
\hline
3
&
\sphinxcode{\sphinxupquote{qf1pTlump}}
&&
\(\left(0,0\right)\)

\(\left(1,0\right)\)

\(\left(0,1\right)\)
&
\(|T_k|/3\)

\(|T_k|/3\)

\(|T_k|/3\)
&
\(1\)
\\
\hline
9
&
\sphinxcode{\sphinxupquote{qf2pT4P1}}
&&
\(\left(\frac{1}{4},\frac{3}{4}\right)\)

\(\left(\frac{3}{4},\frac{1}{4}\right)\)

\(\left(0,\frac{1}{4}\right)\)

\(\left(0,\frac{3}{4}\right)\)

\(\left(\frac{1}{4},0\right)\)

\(\left(\frac{3}{4},0\right)\)

\(\left(\frac{1}{4},\frac{1}{4}\right)\)

\(\left(\frac{1}{4},\frac{1}{2}\right)\)

\(\left(\frac{1}{2},\frac{1}{4}\right)\)
&
\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/12\)

\(|T_k|/6\)

\(|T_k|/6\)

\(|T_k|/6\)
&
\(1\)
\\
\hline
15
&
\sphinxcode{\sphinxupquote{qf7pT}}
&
8
&
See \sphinxcite{references:taylor2005} for detail
&&
7
\\
\hline
21
&
\sphinxcode{\sphinxupquote{qf9pT}}
&
10
&
See \sphinxcite{references:taylor2005} for detail
&&
9
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

For a three dimensional domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Omega_h\) by:

\(\int_{\Omega_h}f(x,y)\) =\sphinxcode{\sphinxupquote{int3d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int3d(Th,qfV=*)(f)}}
=\sphinxcode{\sphinxupquote{int3D(Th,qforder=*)(f)}}

where * stands for the name of quadrature formula or the order of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily Quadrature formula on a tetrahedron
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\(L\)
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qfV}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
Point in \(T_k\in\R^3\)
&\sphinxstyletheadfamily 
\(\omega_\ell\)
&\sphinxstyletheadfamily 
Exact on \(P_k,\ k=\)
\\
\hline
1
&
\sphinxcode{\sphinxupquote{qfV1}}
&
\(2\)
&
\(\left(\frac{1}{4},\frac{1}{4},\frac{1}{4}\right)\)
&
\(|T_k|\)
&
\(1\)
\\
\hline
4
&
\sphinxcode{\sphinxupquote{qfV2}}
&
\(3\)
&
\(G4(0.58\ldots,0.13\ldots,0.13\ldots)\)
&
\(|T_k|/4\)
&
\(2\)
\\
\hline
14
&
\sphinxcode{\sphinxupquote{qfV5}}
&
\(6\)
&
\(G4(0.72\ldots,0.092\ldots,0.092\ldots)\)

\(G4(0.067\ldots,0.31\ldots,0.31\ldots)\)

\(G6(0.45\ldots,0.045\ldots,0.45\ldots)\)
&
\(0.073\ldots|T_k|\)

\(0.11\ldots|T_k|\)

\(0.042\ldots|T_k|\)
&
\(5\)
\\
\hline
4
&
\sphinxcode{\sphinxupquote{qfV1lump}}
&&
\(G4(1,0,0)\)
&
\(|T_k|/4\)
&
\(1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Where \(G4(a,b,b)\) such that \(a+3b=1\) is the set of the four point in barycentric coordinate:
\begin{equation*}
\begin{split}\{(a,b,b,b),(b,a,b,b),(b,b,a,b),(b,b,b,a)\}\end{split}
\end{equation*}
and where \(G6(a,b,b)\) such that \(2a+2b=1\) is the set of the six points in barycentric coordinate:
\begin{equation*}
\begin{split}\{(a,a,b,b),(a,b,a,b),(a,b,b,a),(b,b,a,a),(b,a,b,a),(b,a,a,b)\}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
These tetrahedral quadrature formulae come from \sphinxurl{http://nines.cs.kuleuven.be/research/ecf/mtables.html}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
By default, we use the formula which is exact for polynomials of degree \(5\) on triangles or edges (in bold in three tables).
\end{sphinxadmonition}

It is possible to add an own quadrature formulae with using plugin \sphinxcode{\sphinxupquote{qf11to25}} on segment, triangle or Tetrahedron.

The quadrature formulae in \(D\) dimension is a bidimentional array of size \(N_q\times (D+1)\) such that the \(D+1\) value of on row \(i=0,...,N_p-1\) are \(w^i,\hat{x}^i_1,...,\hat{x}^i_D\) where \(w^i\) is the weight of the quadrature point, and \(1-\sum_{k=1}^D \hat{x}^i_k ,\hat{x}^i_1,...,\hat{x}^i_D\) is the barycentric coordinate the quadrature point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{qf11to25}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Quadrature on segment}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq1} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF1} \PYG{n+nf}{qf1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf1 on segment}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1}

\PYG{c+c1}{//Quadrature on triangle}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq2} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF2} \PYG{n+nf}{qf2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf2 on triangle}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1}
\PYG{c+c1}{//so must have sum w\PYGZca{}i = 1}

\PYG{c+c1}{// Quadrature on tetrahedron}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq3} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF3} \PYG{n+nf}{qf3}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf3 on get}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1)}

\PYG{c+c1}{// Verification in 1d and 2d}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{I1} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{qf1}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{I1l} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pElump}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{I2} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{n}{qf2}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{I2l} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf1pTlump}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I1l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I2l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{I1}\PYG{o}{\PYGZhy{}}\PYG{n}{I1l}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{I2}\PYG{o}{\PYGZhy{}}\PYG{n}{I2l}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The output is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{1}.67 \PYG{o}{=}\PYG{o}{=} \PYG{l+m}{1}.67
\PYG{l+m}{0}.335 \PYG{o}{=}\PYG{o}{=} \PYG{l+m}{0}.335
\end{sphinxVerbatim}


\subsection{Variational Form, Sparse Matrix, PDE Data Vector}
\label{\detokenize{documentation/finiteElement:variational-form-sparse-matrix-pde-data-vector}}\label{\detokenize{documentation/finiteElement:variationalformsparsematrixpde}}
In \sphinxstylestrong{FreeFEM} it is possible to define variational forms, and use them to build matrices and vectors, and store them to speed-up the script (4 times faster here).

For example let us solve the \DUrole{xref,std,std-ref}{Thermal Conduction problem}.

The variational formulation is in \(L^2(0,T;H^1(\Omega))\); we shall seek \(u^n\) satisfying:
\begin{equation*}
\begin{split}\forall w \in V_{0}; \qquad \int_\Omega \frac{u^n-u^{n-1}}{\delta t} w + \kappa\n u^n\n w) +\int_\Gamma\alpha(u^n-u_{ue})w=0\end{split}
\end{equation*}
where \(V_0 = \{w\in H^1(\Omega)/ w_{|\Gamma_{24}}=0\}\).

So to code the method with the matrices \(A=(A_{ij})\), \(M=(M_{ij})\), and the vectors \(u^n, b^n, b',b", b_{cl}\) (notation if \(w\) is a vector then \(w_i\) is a component of the vector).
\begin{equation*}
\begin{split}u^n = A^{-1} b^n, \quad
\quad b' = b_0 + M u^{n-1},
\quad b"= \frac{1}{\varepsilon} \; b_{cl},
\quad b^n_i = \left\{
\begin{array}{cl} b"_i & \mbox{if }\ i \in \Gamma_{24} \\
b'_i & \mbox{else if } \not\in \Gamma_{24} \end{array}\right.\end{split}
\end{equation*}
Where with \(\frac{1}{\varepsilon} = \mathtt{tgv} = 10^{30}\):
\begin{equation*}
\begin{split}\begin{array}{rcl}
    A_{ij} &=& \left\{\begin{array}{cl} \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and} j=i \\
    \displaystyle
        \int_{\Omega} w_j w_i / dt + k (\nabla w_j. \nabla w_i ) + \int_{\Gamma_{13}} \alpha w_j w_i & \mbox{else if } i \not\in \Gamma_{24}, \mbox{or} j\ne i
        \end{array}\right.\\
        M_{ij} &=& \left\{\begin{array}{cl} \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and} j=i\\
    \displaystyle
        \int_{\Omega} w_j w_i / dt
        & \mbox{else if }i \not\in \Gamma_{24}, \mbox{or} j\ne i \end{array}\right. \\
        b_{0,i} &=& \int_{\Gamma_{13}} \alpha u_{ue} w_i \\
        b_{cl} &=& u^{0} \quad \mbox{the initial data}
\end{array}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{fu0} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{+} \PYG{l+m+mi}{90}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{25.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1} \PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u0} \PYG{o}{=} \PYG{n}{fu0}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{n}{u0}\PYG{p}{;}
\end{sphinxVerbatim}

Create three variational formulation, and build the matrices \(A\),\(M\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vthermic} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vthermic0} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vMass} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{tgv} \PYG{o}{=} \PYG{l+m+mf}{1e30}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, to build the right hand size we need 4 vectors.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{vthermic0}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//constant part of the RHS}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcn} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//tgv on Dirichlet boundary node ( !=0 )}
\PYG{c+c1}{//we have for the node i : i in Gamma\PYGZus{}24 \PYGZhy{}\PYGZgt{} bcn[i] != 0}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcl} \PYG{o}{=} \PYG{k+kp}{tgv}\PYG{o}{*}\PYG{n}{u0}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the Dirichlet boundary condition part}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The boundary condition is implemented by penalization and vector \sphinxcode{\sphinxupquote{bcn}} contains the contribution of the boundary condition \(u=1\), so to change the boundary condition, we have just to multiply the vector \sphinxcode{\sphinxupquote{bc{[}{]}}} by the current value \sphinxcode{\sphinxupquote{f}} of the new boundary condition term by term with the operator \sphinxcode{\sphinxupquote{.*}}.

\DUrole{xref,std,std-ref}{Uzawa model} gives a real example of using all this features.
\end{sphinxadmonition}

And the new version of the algorithm is now:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Time loop}
\PYG{k+kt}{ofstream} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{thermic.dat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b0}\PYG{p}{;} \PYG{c+c1}{//for the RHS}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add the the time dependent part}
    \PYG{c+c1}{//lock boundary part:}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{bcn} \PYG{o}{?} \PYG{n+nl}{bcl} \PYG{o}{:} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//do forall i: b[i] = bcn[i] ? bcl[i] : b[i]}

    \PYG{c+c1}{// Solve}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

    \PYG{c+c1}{// Save}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Display}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{6.0}\PYG{o}{*}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.0}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The functions appearing in the variational form are formal and local to the \sphinxcode{\sphinxupquote{varf}} definition, the only important thing is the order in the parameter list, like in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vb1}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vb2}\PYG{p}{(}\PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

To build matrix \(A\) from the bilinear part the variational form \(a\) of type \sphinxcode{\sphinxupquote{varf}} simply write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Wh} \PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// where}
\PYG{c+c1}{//Vh is \PYGZdq{}fespace\PYGZdq{} for the unknown fields with a correct number of component}
\PYG{c+c1}{//Wh is \PYGZdq{}fespace\PYGZdq{} for the test fields with a correct number of component}
\end{sphinxVerbatim}

Possible named parameters in \sphinxcode{\sphinxupquote{, {[}...{]}}} are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{solver=}} \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{CG}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}}, \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}}, \sphinxcode{\sphinxupquote{UMFPACK}} …
\begin{quote}

The default solver is \sphinxcode{\sphinxupquote{GMRES}}.

The storage mode of the matrix of the underlying linear system depends on the type of solver chosen; for \sphinxcode{\sphinxupquote{LU}} the matrix is sky-line non symmetric, for \sphinxcode{\sphinxupquote{Crout}} the matrix is sky-line symmetric, for \sphinxcode{\sphinxupquote{Cholesky}} the matrix is sky-line symmetric positive definite, for \sphinxcode{\sphinxupquote{CG}} the matrix is sparse symmetric positive, and for \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{UMFPACK}} the matrix is just sparse.
\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{factorize =}} If true then do the matrix factorization for \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Cholesky}} or \sphinxcode{\sphinxupquote{Crout}}, the default value is \sphinxcode{\sphinxupquote{false}}.

\item {} 
\sphinxcode{\sphinxupquote{eps=}} A real expression.
\begin{quote}

\(\varepsilon\) sets the stopping test for the iterative methods like \sphinxcode{\sphinxupquote{CG}}.

Note that if \(\varepsilon\) is negative then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < |\varepsilon|\end{split}
\end{equation*}
if it is positive then the stopping test is
\begin{equation*}
\begin{split}|| A x - b || < \frac{|\varepsilon|}{|| A x_{0} - b ||}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxcode{\sphinxupquote{precon=}} Name of a function (for example \sphinxcode{\sphinxupquote{P}}) to set the preconditioner.

The prototype for the function \sphinxcode{\sphinxupquote{P}} must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{xx}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxcode{\sphinxupquote{tgv=}} Huge value (\(10^{30}\)) used to implement Dirichlet boundary conditions.

\item {} 
\sphinxcode{\sphinxupquote{tolpivot=}} Set the tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}} (\(10^-1\)) and, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorization (\(10^{-20}\)).

\item {} 
\sphinxcode{\sphinxupquote{tolpivotsym=}} Set the tolerance of the pivot sym in \sphinxcode{\sphinxupquote{UMFPACK}}

\item {} 
\sphinxcode{\sphinxupquote{strategy=}} Set the integer UMFPACK strategy (\(0\) by default).

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The line of the matrix corresponding to the space \sphinxcode{\sphinxupquote{Wh}} and the column of the matrix corresponding to the space \sphinxcode{\sphinxupquote{Vh}}.
\end{sphinxadmonition}

To build the dual vector \sphinxcode{\sphinxupquote{b}} (of type \sphinxcode{\sphinxupquote{real{[}int{]}}}) from the linear part of the variational form \sphinxcode{\sphinxupquote{a}} do simply:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

A first example to compute the area of each triangle \(K\) of mesh \(Th\), just do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the space function constant / triangle}
\PYG{n}{Nh} \PYG{n}{areaK}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{varea} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{chiK}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{etaK}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{varea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Effectively, the basic functions of space \(Nh\), are the characteristic function of the element of Th, and the numbering is the numeration of the element, so by construction:
\begin{equation*}
\begin{split}\mathtt{etaK}[i] = \int {1}_{|K_i} = \int_{K_i} 1;\end{split}
\end{equation*}
Now, we can use this to compute error indicators like in example \DUrole{xref,std,std-ref}{Adaptation using residual error indicator}.

First to compute a continuous approximation to the function \(h\) “density mesh size” of the mesh \(Th\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{h} \PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{count}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vmeshsizen} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vedgecount} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Computation of the mesh size}
\PYG{n}{count} \PYG{o}{=} \PYG{n}{vedgecount}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//number of edge / vertex}
\PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vmeshsizen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sum length edge / vertex}
\PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{count}\PYG{p}{;} \PYG{c+c1}{//mean length edge / vertex}
\end{sphinxVerbatim}

To compute error indicator for Poisson equation:
\begin{equation*}
\begin{split}{\eta_K = \int_K h_K^2 |( f + \Delta u_h)|^2 + \int_{\partial K} h_e |[ \frac{\partial u_h}{\partial n} ]|^2 }\end{split}
\end{equation*}
where \(h_K\) is size of the longest edge (\sphinxcode{\sphinxupquote{hTriangle}}), \(h_e\) is the size of the current edge (\sphinxcode{\sphinxupquote{lenEdge}}), \(n\) the normal.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// the space function constant / triangle}
\PYG{n}{Nh} \PYG{n}{etak}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vetaK} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{k+kr}{lenEdge}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{hTriangle}\PYG{o}{*}\PYG{p}{(}\PYG{n}{f} \PYG{o}{+} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vetaK}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We add automatic expression optimization by default, if this optimization creates problems, it can be removed with the keyword \sphinxcode{\sphinxupquote{optimize}} as in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{optimize}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

or you can also do optimization and remove the check by setting \sphinxcode{\sphinxupquote{optimize=2}}.

Remark, it is all possible to build interpolation matrix, like in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VH}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{VH}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build interpolation matrix Vh\PYGZhy{}\PYGZgt{}VH}
\PYG{k+kt}{matrix} \PYG{n}{BB} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build interpolation matrix Vh\PYGZhy{}\PYGZgt{}Wh}
\end{sphinxVerbatim}

and after some operations on sparse matrices are available for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//a full matrix}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{i}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{)} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{sparseA} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sparseA} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{sparseA} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{sparseA} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{sparseB} \PYG{o}{=} \PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{p}{;} \PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sparseB = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sparseB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Interpolation matrix}
\label{\detokenize{documentation/finiteElement:interpolation-matrix}}
It is also possible to store the matrix of a linear interpolation operator from a finite element space \(V_h\) to another \(W_h\) to \sphinxcode{\sphinxupquote{interpolate}}(\(W_h\),\(V_h\),…) a function.

Note that the continuous finite functions are extended by continuity outside of the domain.

The named parameters of function \sphinxcode{\sphinxupquote{interpolate}} are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{inside=}} set true to create zero-extension.

\item {} 
\sphinxcode{\sphinxupquote{t=}} set true to get the transposed matrix

\item {} 
\sphinxcode{\sphinxupquote{op=}} set an integer written below
\begin{itemize}
\item {} 
0 the default value and interpolate of the function

\item {} 
1 interpolate the \(\p_x\)

\item {} 
2 interpolate the \(\p_y\)

\item {} 
3 interpolate the \(\p_z\)

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{U2Vc=}} set the which is the component of \(W_h\) come in \(V_h\) in interpolate process in a int array so the size of the array is number of component of \(W_h\), if the put \(-1\) then component is set to \(0\), like in the following example: (by default the component number is unchanged).
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{V4h}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{V3h}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u2vc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}1 \PYGZhy{}\PYGZgt{} put zero on the component}
\PYG{k+kt}{matrix} \PYG{n}{IV34} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{V3h}\PYG{p}{,} \PYG{n}{V4h}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{u2vc}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//V3h \PYGZlt{}\PYGZhy{} V4h}
\PYG{n}{V4h} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{,} \PYG{n}{a3}\PYG{p}{,} \PYG{n}{a4}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{V3h} \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{b1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{IV34}\PYG{o}{*}\PYG{n}{a1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

So here we have: \sphinxcode{\sphinxupquote{freefem   b1 == 2, b2 == 4, b3 == 0 ...}}
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
Matrix interpolation

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Th4}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh4}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh4} \PYG{n}{v4}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh4}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Interpolation}
\PYG{k+kt}{matrix} \PYG{n}{IV} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//here the function is exended by continuity}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{v}\PYG{o}{=}\PYG{n}{v4}\PYG{p}{;}
\PYG{n}{vv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=} \PYG{n}{IV}\PYG{o}{*}\PYG{n}{v4}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//here v == vv}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diff}\PYG{o}{=} \PYG{n}{vv}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{} v \PYGZhy{} vv \textbar{}\textbar{} = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{diff}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n}{diff}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IV0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//here the function is exended by zero}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4 (inside=1) }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IVt0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4\PYGZca{}t (inside=1) }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IVt0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IV4t0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh4}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh4\PYGZlt{}\PYGZhy{}Vh\PYGZca{}t }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV4t0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IW4} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh4}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Wh4\PYGZlt{}\PYGZhy{}Wh }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IW4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IW4V} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh4}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Wh4\PYGZlt{}\PYGZhy{}Vh }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IW4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

Build interpolation matrix \(A\) at a array of points \((xx[j],yy[j]),\ i = 0,\ 2\) here:
\begin{equation*}
\begin{split}a_ij = dop(w^i_c (xx[j],yy[j]))\end{split}
\end{equation*}
where \(w_i\) is the basic finite element function, \(c\) the component number, \(dop\) the type of diff operator like in op def.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{.3}\PYG{p}{,} \PYG{l+m+mf}{.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{yy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{.1}\PYG{p}{,} \PYG{l+m+mf}{.4}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{dop} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Ixx} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{,} \PYG{k+kp}{op}\PYG{o}{=}\PYG{n}{dop}\PYG{p}{,} \PYG{k+kp}{composante}\PYG{o}{=}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ixx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ww}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n+nf}{dd} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{ww}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ixx}\PYG{o}{*}\PYG{n+nf}{dd}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Schwarz

The following shows how to implement with an interpolation matrix a domain decomposition algorithm based on Schwarz method with Robin conditions.

Given a non-overlapping partition \(\bar\Omega=\bar\Omega_0\cup\bar\Omega_1\) with \(\Omega_0\cap\Omega_1=\emptyset\), \(\Sigma:=\bar\Omega_0\cap\bar\Omega_1\) the algorithm is:
\begin{equation*}
\begin{split}-\Delta u_i &= f \hbox{ in }\Omega_i,~i=0,1,\\
\frac{\partial(u_1-u_0)}{\partial n} + \alpha (u_1-u_0) &=0\hbox{ on }\Sigma.\end{split}
\end{equation*}
The same in variational form is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    &\int_{\Omega_i}\nabla u_i\cdot\nabla v &+ \int_\Sigma\alpha u_i v = \int_{\Omega_i}f v\\
    - \int_{\Omega_j}(\nabla u_j\cdot\nabla v-f v) + \int_\Sigma\alpha u_j v,~~
    \forall v\in H^1_0(\Omega), i,j=[0,1]\cup[1,0]
\end{array}\end{split}
\end{equation*}
To discretized with the \(P^1\) triangular Lagrangian finite element space \(V_h\) simply replace \(H^1_0(\Omega)\) by \(V_h(\Omega_0)\cup V_h(\Omega_1)\).

Then difficulty is to compute \(\int_{\Omega_j} \nabla u_j\cdot\nabla v\) when \(v\) is a basis function of \(V_h(\Omega_i)\), \(i\ne j\).

It is done as follows (with \(\Gamma=\partial\Omega\)):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{Gamma} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{Sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{Niter} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{n}{TH}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{TH}\PYG{p}{(}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}

\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{reg}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh0} \PYG{n}{u0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{b} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{du1dn} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{du0dn} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u0}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{I01} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{I10} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kp}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solving loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{n}{Niter}\PYG{p}{;} \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve on Th[0]}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Du1dn} \PYG{o}{=} \PYG{n}{du1dn}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Tdu1dn}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Tdu1dn} \PYG{o}{=} \PYG{n}{I01}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Du1dn}\PYG{p}{;}
        \PYG{n}{b0} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Tdu1dn}\PYG{p}{;}
        \PYG{n}{u0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Solve on Th[1]}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Du0dn} \PYG{o}{=} \PYG{n}{du0dn}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Tdu0dn}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Tdu0dn} \PYG{o}{=} \PYG{n}{I10}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Du0dn}\PYG{p}{;}
        \PYG{n}{b1} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Tdu0dn}\PYG{p}{;}
        \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iter=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Finite elements connectivity}
\label{\detokenize{documentation/finiteElement:finite-elements-connectivity}}
Here, we show how to get informations on a finite element space \(W_h({\cal T}_n,*)\), where “*” may be \sphinxcode{\sphinxupquote{P1, P2, P1nc}}, etc.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Wh.nt}} gives the number of element of \(W_h\)

\item {} 
\sphinxcode{\sphinxupquote{Wh.ndof}} gives the number of degrees of freedom or unknown

\item {} 
\sphinxcode{\sphinxupquote{Wh.ndofK}} gives the number of degrees of freedom on one element

\item {} 
\sphinxcode{\sphinxupquote{Wh(k,i)}} gives the number of \(i\)th degrees of freedom of element \(k\).

\end{itemize}

See the following example:

\begin{sphinxadmonition}{tip}{Tip:}
Finite element connectivity

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of degree of freedom = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndof} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of degree of freedom / ELEMENT = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndofK} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{kdf} \PYG{o}{=} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{c+c1}{//element 2}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Degree of freedom of element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{kdf}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Number of degree of \PYG{n+nv}{freedom} \PYG{o}{=} \PYG{l+m}{121}
Number of degree of freedom / \PYG{n+nv}{ELEMENT} \PYG{o}{=} \PYG{l+m}{6}
Degree of freedom of element \PYG{l+m}{2}:
\PYG{l+m}{78} \PYG{l+m}{95} \PYG{l+m}{83} \PYG{l+m}{87} \PYG{l+m}{79} \PYG{l+m}{92}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Visualization}
\label{\detokenize{documentation/visualization:visualization}}\label{\detokenize{documentation/visualization:id1}}\label{\detokenize{documentation/visualization::doc}}
Results created by the finite element method can be a huge set of data, so it is very important to render them easy to grasp.

There are two ways of visualization in \sphinxstylestrong{FreeFEM}:
\begin{itemize}
\item {} 
One, the default view, which supports the drawing of meshes, isovalues of real FE-functions, and of vector fields, all by the command \sphinxcode{\sphinxupquote{plot}} (see {\hyperref[\detokenize{documentation/visualization:plot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot section}}}} below).
For publishing purpose, \sphinxstylestrong{FreeFEM} can store these plots as postscript files.

\item {} 
Another method is to use external tools, for example, gnuplot (see {\hyperref[\detokenize{documentation/visualization:gnuplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Gnuplot section}}}}, {\hyperref[\detokenize{documentation/visualization:medit}]{\sphinxcrossref{\DUrole{std,std-ref}{medit section}}}}, {\hyperref[\detokenize{documentation/visualization:paraview}]{\sphinxcrossref{\DUrole{std,std-ref}{Paraview section}}}}, {\hyperref[\detokenize{documentation/visualization:matlab}]{\sphinxcrossref{\DUrole{std,std-ref}{Matlab/Octave section}}}}) using the command \sphinxcode{\sphinxupquote{system}} to launch them and/or to save the data in text files.

\end{itemize}


\subsection{Plot}
\label{\detokenize{documentation/visualization:plot}}\label{\detokenize{documentation/visualization:id2}}
With the command \sphinxcode{\sphinxupquote{plot}}, meshes, isovalues of scalar functions, and vector fields can be displayed.

The parameters of the plot command can be meshes, real FE functions, arrays of 2 real FE functions, arrays of two double arrays, to plot respectively a mesh, a function, a vector field, or a curve defined by the two double arrays.

\begin{sphinxadmonition}{note}{Note:}
The length of an arrow is always bound to be in {[}5‰, 5\%{]} of the screen size in order to see something.
\end{sphinxadmonition}

The \sphinxcode{\sphinxupquote{plot}} command parameters are listed in the \DUrole{xref,std,std-ref}{Reference part}.

The keyboard shortcuts are:
\begin{itemize}
\item {} 
\sphinxstylestrong{enter} tries to show plot

\item {} 
\sphinxstylestrong{p} previous plot (10 plots saved)

\item {} 
\sphinxstylestrong{?} shows this help

\item {} 
\sphinxstylestrong{+,-} zooms in/out around the cursor 3/2 times

\item {} 
\sphinxstylestrong{=} resets the view

\item {} 
\sphinxstylestrong{r} refreshes plot

\item {} 
\sphinxstylestrong{up, down, left, right} special keys to tanslate

\item {} 
\sphinxstylestrong{3} switches 3d/2d plot keys :
\begin{itemize}
\item {} 
\sphinxstylestrong{z,Z} focal zoom and zoom out

\item {} 
\sphinxstylestrong{H,h} increases or decreases the Z scale of the plot

\end{itemize}

\item {} 
\sphinxstylestrong{mouse motion}:
\begin{itemize}
\item {} 
\sphinxstylestrong{left button} rotates

\item {} 
\sphinxstylestrong{right button} zooms (ctrl+button on mac)

\item {} 
\sphinxstylestrong{right button +alt} tanslates (alt+ctrl+button on mac)

\end{itemize}

\item {} 
\sphinxstylestrong{a,A} increases or decreases the arrow size

\item {} 
\sphinxstylestrong{B} switches between showing the border meshes or not

\item {} 
\sphinxstylestrong{i,I} updates or not: the min/max bound of the functions to the window

\item {} 
\sphinxstylestrong{n,N} decreases or increases the number of iso value arrays

\item {} 
\sphinxstylestrong{b} switches between black and white or color plotting

\item {} 
\sphinxstylestrong{g} switches between grey or color plotting

\item {} 
\sphinxstylestrong{f} switches between filling iso or iso line

\item {} 
\sphinxstylestrong{l} switches between lighting or not

\item {} 
\sphinxstylestrong{v} switches between show or not showing the numerical value of colors

\item {} 
\sphinxstylestrong{m} switches between show or not showing the meshes

\item {} 
\sphinxstylestrong{w} window dump in file ffglutXXXX.ppm

\item {} 
\sphinxstylestrong{*} keep/drop viewpoint for next plot

\item {} 
\sphinxstylestrong{k} complex data / change view type

\item {} 
\sphinxstylestrong{ESC} closes the graphics process before version 3.22, after no way to close

\item {} 
\sphinxstylestrong{otherwise} does nothing

\end{itemize}

For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//plot scalar and vectorial FE function}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{vh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{three.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
   \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{grey}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{threeg.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//compute a cut}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
   \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
   \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
   \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//value of uh at point (i/10., i/10.)}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{likegnu.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot}.png}
\caption{Mesh, isovalue and vector}\label{\detokenize{documentation/visualization:id3}}\label{\detokenize{documentation/visualization:figvisumesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot_Grey}.png}
\caption{Enlargement in grey of isovalue and vector}\label{\detokenize{documentation/visualization:id4}}\label{\detokenize{documentation/visualization:figvisugrey}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot_Gnuplot}.png}
\caption{Plots a cut of \sphinxcode{\sphinxupquote{uh}}. Note that a refinement of the same can be obtained in combination with gnuplot}\label{\detokenize{documentation/visualization:id5}}\label{\detokenize{documentation/visualization:figvisucut}}\end{subfigure}
\caption{Plot}\phantomsection\label{\detokenize{documentation/visualization:Plot}}

\end{figure}


To change the color table and to choose the value of iso line you can do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// from: \PYGZbs{}url\PYGZob{}http://en.wikipedia.org/wiki/HSV\PYGZus{}color\PYGZus{}space\PYGZcb{}}
\PYG{c+c1}{// The HSV (Hue, Saturation, Value) model defines a color space}
\PYG{c+c1}{// in terms of three constituent components:}
\PYG{c+c1}{// HSV color space as a color wheel}
\PYG{c+c1}{// Hue, the color type (such as red, blue, or yellow):}
\PYG{c+c1}{// Ranges from 0\PYGZhy{}360 (but normalized to 0\PYGZhy{}100\PYGZpc{} in some applications, like here)}
\PYG{c+c1}{// Saturation, the \PYGZdq{}vibrancy\PYGZdq{} of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}
\PYG{c+c1}{// The lower the saturation of a color, the more \PYGZdq{}grayness\PYGZdq{} is present}
\PYG{c+c1}{// and the more faded the color will appear.}
\PYG{c+c1}{// Value, the brightness of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{colorhsv}\PYG{o}{=}\PYG{p}{[} \PYG{c+c1}{// color hsv model}
   \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{c+c1}{// dark blue}
   \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// blue}
   \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// magenta}
   \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// red}
   \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.5} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{c+c1}{// light red}
   \PYG{p}{]}\PYG{p}{;}
 \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}\PYG{p}{;}

 \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}

 \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{colorhsv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_HSV_Space}.png}
\caption{HSV color cylinder}\label{\detokenize{documentation/visualization:id6}}\label{\detokenize{documentation/visualization:figvisuhsv}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_HSV}.png}
\caption{Isovalue with an other color table}\label{\detokenize{documentation/visualization:id7}}\label{\detokenize{documentation/visualization:figvisuisocolortable}}\end{subfigure}
\caption{HSV}\phantomsection\label{\detokenize{documentation/visualization:HSV}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:examplehsv}]{\sphinxcrossref{\DUrole{std,std-ref}{HSV example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with gnuplot}
\label{\detokenize{documentation/visualization:link-with-gnuplot}}\label{\detokenize{documentation/visualization:gnuplot}}
Example \DUrole{xref,std,std-ref}{Membrane} shows how to generate a gnuplot from a \sphinxstylestrong{FreeFEM} file.
Here is another technique which has the advantage of being online, i.e. one doesn’t need to quit \sphinxstylestrong{FreeFEM} to generate a gnuplot.

However, this works only if \sphinxhref{http://www.gnuplot.info}{gnuplot} is installed, and only on an Unix-like computer.

Add to the previous example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}\PYG{c+c1}{// file for gnuplot}
   \PYG{k+kt}{ofstream} \PYG{n}{gnu}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{gnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// to call gnuplot command and wait 5 second (due to the Unix command)}
\PYG{c+c1}{// and make postscript plot}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{echo \PYGZsq{}plot }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ w l }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ pause 5 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set term postscript }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set output }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{gnuplot.eps}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ replot }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ quit\PYGZsq{} \textbar{} gnuplot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Gnuplot}.png}
\caption{Plots a cut of uh with gnuplot}\label{\detokenize{documentation/visualization:figvisugnuplot}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:exampleplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with medit}
\label{\detokenize{documentation/visualization:link-with-medit}}\label{\detokenize{documentation/visualization:medit}}
As said above, \sphinxcode{\sphinxupquote{medit}} is a freeware display package by Pascal Frey using OpenGL. Then you may run the following example.

Now \sphinxcode{\sphinxupquote{medit}} software is included in \sphinxstylestrong{FreeFEM} under \sphinxcode{\sphinxupquote{ffmedit}} name.

The \sphinxcode{\sphinxupquote{medit}} command parameters are listed in the \DUrole{xref,std,std-ref}{Reference part}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Medit}.png}
\caption{:freefem:medit{}` plot}\label{\detokenize{documentation/visualization:figvisumedit}}\end{figure}

With version 3.2 or later

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Before:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u}\PYG{o}{*}\PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//save u.points and u.faces file}
\PYG{c+c1}{// build a u.bb file for medit}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.bb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 1 1 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//call medit command}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmedit u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//clean files on unix\PYGZhy{}like OS}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rm u.bb u.faces u.points}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:examplemedit}]{\sphinxcrossref{\DUrole{std,std-ref}{Medit example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with Paraview}
\label{\detokenize{documentation/visualization:link-with-paraview}}\label{\detokenize{documentation/visualization:paraview}}
One can also export mesh or results in the \sphinxcode{\sphinxupquote{.vtk}} format in order to post-process data using \sphinxhref{https://www.paraview.org/}{Paraview}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Order} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{DataName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.vtu}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Paraview}.png}
\caption{Paraview plot}\label{\detokenize{documentation/visualization:figvisuparaview}}\end{figure}

\begin{sphinxadmonition}{warning}{Warning:}
Finite element variables saved using paraview \sphinxstylestrong{must be in P0 or P1}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
See {\hyperref[\detokenize{example/visualization:exampleparaview}]{\sphinxcrossref{\DUrole{std,std-ref}{Paraview example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with Matlab© and Octave}
\label{\detokenize{documentation/visualization:link-with-matlab-and-octave}}\label{\detokenize{documentation/visualization:matlab}}
In order to create a plot from a \sphinxstylestrong{FreeFEM} simulation in \sphinxhref{https://www.gnu.org/software/octave/}{Octave} and \sphinxhref{https://www.mathworks.com/}{Matlab} the mesh, the finite element space connectivity and the simulation data must be written to files:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmatlib.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}mesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffSaveVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}vh.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffSaveData}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}data.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Within Matlab or Octave the files can be plot with the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib library}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{addpath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path to ffmatlib\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{]}\PYG{p}{=}\PYG{n}{ffreadmesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}mesh.msh\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vh}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}vh.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}data.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ZStyle\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{continuous\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{grid}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Matlab_Octave}.png}
\caption{Matlab / Octave plot}\label{\detokenize{documentation/visualization:figvisumatlab}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
For more Matlab / Octave plot examples have a look at the tutorial section \DUrole{xref,std,std-ref}{Matlab / Octave Examples} or visit the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib library} on github.
\end{sphinxadmonition}


\section{Algorithms \& Optimization}
\label{\detokenize{documentation/algorithmsOptimization:algorithms-optimization}}\label{\detokenize{documentation/algorithmsOptimization::doc}}

\subsection{Conjugate Gradient/GMRES}
\label{\detokenize{documentation/algorithmsOptimization:conjugate-gradient-gmres}}
Suppose we want to solve the Euler problem (here \(x\) has nothing to do with the reserved variable for the first coordinate in \sphinxstylestrong{FreeFEM}):

find \(x\in \mathbb{R}^n\) such that
\begin{equation}\label{equation:documentation/algorithmsOptimization:eqndJ}
\begin{split}\nabla J(x) = \left(\frac{\partial J}{\partial x_i} (\mathbf{x})\right) = 0\end{split}
\end{equation}
where \(J\) is a function (to minimize for example) from \(\mathbb{R}^n\) to \(\mathbb{R}\).

If the function is convex we can use the conjugate gradient algorithm to solve the problem, and we just need the function (named \sphinxcode{\sphinxupquote{dJ}} for example) which computes \(\nabla J\), so the parameters are the name of that function with prototype \sphinxcode{\sphinxupquote{func real{[}int{]} dJ(real{[}int{]} \&xx);}} which computes \(\nabla J\), and a vector \sphinxcode{\sphinxupquote{x}} of type (of course the number 20 can be changed) \sphinxcode{\sphinxupquote{real{[}int{]} x(20);}} to initialize the process and get the result.

Given an initial value \(\mathbf{x}^{(0)}\), a maximum number \(i_{\max}\) of iterations, and an error tolerance \(0<\epsilon<1\):

Put \(\mathbf{x}=\mathbf{x}^{(0)}\) and write

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{stopfunc}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will give the solution of \(\mathbf{x}\) of \(\nabla J(\mathbf{x})=0\).
We can omit parameters \sphinxcode{\sphinxupquote{precon, nbiter, eps, stop}}.
Here \(M\) is the preconditioner whose default is the identity matrix.

The stopping test is
\begin{equation*}
\begin{split}\|\nabla J(\mathbf{x})\|_P\le \epsilon\| \nabla J(\mathbf{x}^{(0)})\|_P\end{split}
\end{equation*}
Writing the minus value in \sphinxcode{\sphinxupquote{eps=}}, i.e.,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We can use the stopping test:
\begin{equation*}
\begin{split}\| \nabla J(\mathbf{x})\|_P^2\le \epsilon\end{split}
\end{equation*}
The parameters of these three functions are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbiter=}} set the number of iteration (by default 100)

\item {} 
\sphinxcode{\sphinxupquote{precon=}} set the preconditioner function (\sphinxcode{\sphinxupquote{P}} for example) by default it is the identity, note the prototype is \sphinxcode{\sphinxupquote{func real{[}int{]} P(real{[}int{]} \&x)}}.

\item {} 
\sphinxcode{\sphinxupquote{eps=}} set the value of the stop test \(\varepsilon\) (\(=10^{-6}\) by default) if positive then relative test \(||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P\), otherwise the absolute test is \(||\nabla J(x)||_P^2\leq |\varepsilon|\).

\item {} 
\sphinxcode{\sphinxupquote{veps=}} set and return the value of the stop test, if positive, then relative test is \(||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P\), otherwise the absolute test is \(||\nabla J(x)||_P^2\leq |\varepsilon|\).
The return value is minus the real stop test (remark: it is useful in loop).

\item {} 
\sphinxcode{\sphinxupquote{stop=}} \sphinxcode{\sphinxupquote{stopfunc}} add your test function to stop before the \sphinxcode{\sphinxupquote{eps}} criterion. The prototype for the function \sphinxcode{\sphinxupquote{stopfunc}} is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n}{stopfunc}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{u}} is the current solution, and \sphinxcode{\sphinxupquote{g}}, the current gradient, is not preconditioned.

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
{\hyperref[\detokenize{example/algoOptimizations:examplealgorithms}]{\sphinxcrossref{\DUrole{std,std-ref}{Algorithms.edp}}}}

For a given function \(b\), let us find the minimizer \(u\) of the function
\begin{equation*}
\begin{split}\begin{array}{rcl}
   J(u) &=& \frac{1}{2}\int_{\Omega} f(|\nabla u|^2) - \int_{\Omega} u b \\
   f(x) &=& ax + x-\ln(1+x), \quad f'(x) = a+\frac{x}{1+x}, \quad f''(x) = \frac{1}{(1+x)^2}
\end{array}\end{split}
\end{equation*}
under the boundary condition \(u=0\) on \(\partial\Omega\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//store df(\textbar{}nabla u\textbar{}\PYGZca{}2)}

\PYG{c+c1}{// The functionn J}
\PYG{c+c1}{//J(u) = 1/2 int\PYGZus{}Omega f(\textbar{}nabla u\textbar{}\PYGZca{}2) \PYGZhy{} int\PYGZus{}Omega u b}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
   \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// The gradiant of J}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
   \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{au} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
         \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
      \PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
      \PYG{p}{;}

   \PYG{n}{u} \PYG{o}{=} \PYG{n}{au}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

We also want to construct a preconditioner \(C\) with solving the problem:

find \(u_h \in V_{0h}\) such that:
\begin{equation*}
\begin{split}\forall v_h \in V_{0h}, \quad \int_\Omega \alpha \nabla u_h . \nabla v_h = \int_\Omega b v_h\end{split}
\end{equation*}
where \(\alpha=f'(|\nabla u|^2)\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{alap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{amass}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Amass} \PYG{o}{=} \PYG{n}{amass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Alap}\PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Preconditionner}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{w} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{=} \PYG{n}{Alap}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array variable}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

To solve the problem, we make 10 iterations of the conjugate gradient, recompute the preconditioner and restart the conjugate gradient:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{conv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{conv} \PYG{o}{=} \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{C}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{conv}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Alap} \PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Restart with new preconditionner }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{conv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, eps =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution with NLCG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

For a given symmetric positive matrix \(A\), consider the quadratic form
\begin{equation*}
\begin{split}J(\mathbf{x})=\frac{1}{2}\mathbf{x}^TA\mathbf{x}-\mathbf{b}^T\mathbf{x}\end{split}
\end{equation*}
then \(J(\mathbf{x})\) is minimized by the solution \(\mathbf{x}\) of \(A\mathbf{x}=\mathbf{b}\).
In this case, we can use the function \sphinxcode{\sphinxupquote{AffineCG}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineCG}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{stp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If \(A\) is not symmetric, we can use GMRES(Generalized Minimum Residual) algorithm by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Also, we can use the non-linear version of GMRES algorithm (the function \(J\) is just convex)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

For the details of these algorithms, refer to \sphinxcite{references:pironneau1998}, Chapter IV, 1.3.


\subsection{Algorithms for Unconstrained Optimization}
\label{\detokenize{documentation/algorithmsOptimization:algorithms-for-unconstrained-optimization}}
Two algorithms of COOOL package are interfaced with the Newton Raphson method (called \sphinxcode{\sphinxupquote{Newton}}) and the \sphinxcode{\sphinxupquote{BFGS}} method.
These two are directly available in \sphinxstylestrong{FreeFEM} (no dynamical link to load).
Be careful with these algorithms, because their implementation uses full matrices.
We also provide several optimization algorithms from the \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt library} as well as an interface for Hansen’s implementation of CMAES (a MPI version of this one is also available).


\subsubsection{Example of usage for BFGS or CMAES}
\label{\detokenize{documentation/algorithmsOptimization:example-of-usage-for-bfgs-or-cmaes}}
\begin{sphinxadmonition}{tip}{Tip:}
BFGS

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//J}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//the gradiant of J (this is a affine version (the RHS is in)}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ\PYGZhy{}b: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
\PYG{p}{\PYGZcb{}}

\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

It is almost the same a using the CMA evolution strategy except, that since it is a derivative free optimizer, the \sphinxcode{\sphinxupquote{dJ}} argument is omitted and there are some other named parameters to control the behavior of the algorithm.
With the same objective function as above, an example of utilization would be (see {\hyperref[\detokenize{example/algoOptimizations:examplecmaesvariationalinequality}]{\sphinxcrossref{\DUrole{std,std-ref}{CMAES Variational inequality}}}} for a complete example):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//define J, u, ...}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n+nf}{cmaes}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{stopTolFun}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{stopMaxIter}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{minimum value is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ for u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

This algorithm works with a normal multivariate distribution in the parameters space and tries to adapt its covariance matrix using the information provided by the successive function evaluations (see \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation} for more details).
Therefore, some specific parameters can be passed to control the starting distribution, size of the sample generations, etc…
Named parameters for this are the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{seed=}} Seed for random number generator (\sphinxcode{\sphinxupquote{val}} is an integer).
No specified value will lead to a clock based seed initialization.

\item {} 
\sphinxcode{\sphinxupquote{initialStdDev=}} Value for the standard deviations of the initial covariance matrix ( \sphinxcode{\sphinxupquote{val}} is a real).
If the value \(\sigma\) is passed, the initial covariance matrix will be set to \(\sigma I\).
The expected initial distance between initial \(X\) and the \(argmin\) should be roughly initialStdDev. Default is 0.3.

\item {} 
\sphinxcode{\sphinxupquote{initialStdDevs=}} Same as above except that the argument is an array allowing to set a value of the initial standard deviation for each parameter.
Entries differing by several orders of magnitude should be avoided (if it can’t be, try rescaling the problem).

\item {} 
\sphinxcode{\sphinxupquote{stopTolFun=}} Stops the algorithm if function value differences are smaller than the passed one, default is \(10^{-12}\).

\item {} 
\sphinxcode{\sphinxupquote{stopTolFunHist=}} Stops the algorithm if function value differences from the best values are smaller than the passed one, default is 0 (unused).

\item {} 
\sphinxcode{\sphinxupquote{stopTolX=}} Stopping criteria is triggered if step sizes in the parameters space are smaller than this real value, default is 0.

\item {} 
\sphinxcode{\sphinxupquote{stopTolXFactor=}} Stopping criteria is triggered when the standard deviation increases more than this value. The default value is \(10^{3}\).

\item {} 
\sphinxcode{\sphinxupquote{stopMaxFunEval=}} Stops the algorithm when \sphinxcode{\sphinxupquote{stopMaxFunEval}} function evaluations have been done.
Set to \(900(n+3)^{2}\) by default, where \(n\) is the parameters space dimension.

\item {} 
\sphinxcode{\sphinxupquote{stopMaxIter=}} Integer stopping the search when \sphinxcode{\sphinxupquote{stopMaxIter}} generations have been sampled.
Unused by default.

\item {} 
\sphinxcode{\sphinxupquote{popsize=}} Integer value used to change the sample size.
The default value is \(4+ \lfloor 3\ln (n) \rfloor\).
Increasing the population size usually improves the global search capabilities at the cost of, at most, a linear reduction of the convergence speed with respect to \sphinxcode{\sphinxupquote{popsize}}.

\item {} 
\sphinxcode{\sphinxupquote{paramFile=}} This \sphinxcode{\sphinxupquote{string}} type parameter allows the user to pass all the parameters using an extern file, as in Hansen’s original code.
More parameters related to the CMA-ES algorithm can be changed with this file.
Note that the parameters passed to the CMAES function in the \sphinxstylestrong{FreeFEM} script will be ignored if an input parameters file is given.

\end{itemize}


\subsection{IPOPT}
\label{\detokenize{documentation/algorithmsOptimization:ipopt}}
The \sphinxcode{\sphinxupquote{ff-Ipopt}} package is an interface for the \sphinxhref{https://projects.coin-or.org/Ipopt}{IPOPT} \sphinxcite{references:wachter2006} optimizer.
IPOPT is a software library for large scale, non-linear, constrained optimization.
It implements a primal-dual interior point method along with filter method based line searches.

IPOPT needs a direct sparse symmetric linear solver.
If your version of \sphinxstylestrong{FreeFEM} has been compiled with the \sphinxcode{\sphinxupquote{-{-}enable-downlad}} tag, it will automatically be linked with a sequential version of MUMPS.
An alternative to MUMPS would be to download the HSL subroutines (see \sphinxhref{https://www.coin-or.org/Ipopt/documentation/node16.html}{Compiling and Installing the Java Interface JIPOPT}) and place them in the \sphinxcode{\sphinxupquote{/ipopt/Ipopt-3.10.2/ThirdParty/HSL}} directory of the \sphinxstylestrong{FreeFEM} downloads folder before compiling.


\subsubsection{Short description of the algorithm}
\label{\detokenize{documentation/algorithmsOptimization:short-description-of-the-algorithm}}
In this section, we give a very brief glimpse at the underlying mathematics of IPOPT.
For a deeper introduction on interior methods for nonlinear smooth optimization, one may consult \sphinxcite{references:forsgren2002}, or \sphinxcite{references:wachter2006} for more IPOPT specific elements.
IPOPT is designed to perform optimization for both equality and inequality constrained problems.
However, nonlinear inequalities are rearranged before the beginning of the optimization process in order to restrict the panel of nonlinear constraints to those of the equality kind.
Each nonlinear inequality is transformed into a pair of simple bound inequalities and nonlinear equality constraints by the introduction of as many slack variables as is needed : \(c_{i}(x)\leq 0\) becomes \(c_{i}(x) + s_{i} = 0\) and \(s_{i}\leq 0\), where \(s_{i}\) is added to the initial variables of the problems \(x_{i}\).
Thus, for convenience, we will assume that the minimization problem does not contain any nonlinear inequality constraint.
It means that, given a function \(f:\mathbb{R}^{n}\mapsto\mathbb{R}\), we want to find:
\begin{equation}\label{equation:documentation/algorithmsOptimization:minimproblem}
\begin{split}x_{0} = \underset{x\in V}{\operatorname{argmin}} f(x) \\
\mathrm{with}\ V = \left\lbrace x\in\mathbb{R}^{n}\ \vert\ c(x)= 0 \ \text{and}\ x_{l}\leq x\leq x_{u}\right\rbrace\end{split}
\end{equation}
Where \(c:\mathbb{R}^{n}\rightarrow\mathbb{R}^{m}\) and \(x_{l},x_{u}\in\mathbb{R}^{n}\) and inequalities hold componentwise.
The \(f\) function as well as the constraints \(c\) should be twice-continuously differentiable.

As a barrier method, interior points algorithms try to find a Karush-Kuhn-Tucker point for \eqref{equation:documentation/algorithmsOptimization:minimproblem} by solving a sequence of problems, unconstrained with respect to the inequality constraints, of the form:
\begin{equation}\label{equation:documentation/algorithmsOptimization:barrier}
\begin{split}\mathrm{for\ a\ given\ }\mu > 0,\ \mathrm{find}\ x_{\mu} = \underset{x\in\mathbb{R}^{n}\ \vert\ c(x)=0}{\operatorname{argmin}}\ B(x,\mu)\end{split}
\end{equation}
Where \(\mu\) is a positive real number and
\begin{equation*}
\begin{split}B(x,\mu) = f(x) - \displaystyle{\mu\sum_{i=1}^{n} \ln (x_{u,i}-x_{i})} - \displaystyle{\mu\sum_{i=1}^{m} \ln(x_{i}-x_{l,i})}\end{split}
\end{equation*}
The remaining equality constraints are handled with the usual Lagrange multipliers method.
If the sequence of barrier parameters \(\mu\) converge to 0, intuition suggests that the sequence of minimizers of \eqref{equation:documentation/algorithmsOptimization:barrier} converge to a local constrained minimizer of \eqref{equation:documentation/algorithmsOptimization:minimproblem}.
For a given \(\mu\), \eqref{equation:documentation/algorithmsOptimization:barrier} is solved by finding \((x_{\mu},\lambda_{\mu})\in\mathbb{R}^{n}\times\mathbb{R}^{m}\) such that:
\begin{equation}\label{equation:documentation/algorithmsOptimization:muproblem}
\begin{split}\nabla B(x_{\mu},\mu) + \displaystyle{\sum_{i=1}^{m}\lambda_{\mu,i}\nabla c_{i}(x_{\mu})}= \nabla B(x_{\mu},\mu) + J_{c}(x_{\mu})^{T}\lambda_{\mu}&= 0\\
c(x_{\mu}) &= 0\end{split}
\end{equation}
The derivations for \(\nabla B\) only holds for the \(x\) variables, so that:
\begin{equation*}
\begin{split}\nabla B(x,\mu) = \nabla f(x) + \left(\begin{matrix}\mu/(x_{u,1}-x_{1}) \\ \vdots \\ \mu/(x_{u,n}-x_{n})\end{matrix}\right) - \left(\begin{matrix}\mu/(x_{1}-x_{l,1}) \\ \vdots \\ \mu/(x_{n}-x_{l,n})\end{matrix}\right)\end{split}
\end{equation*}
If we respectively call \(z_{u}(x,\mu) = \left(\mu/(x_{u,1}-x_{1}),\dots, \mu/(x_{u,n}-x_{n})\right)\) and \(z_{l}(x,\mu)\) the other vector appearing in the above equation, then the optimum \((x_{\mu},\lambda_{\mu})\) satisfies:
\begin{equation}\label{equation:documentation/algorithmsOptimization:muproblemlambda}
\begin{split}\nabla f(x_{\mu}) + J_{c}(x_{\mu})^{T}\lambda_{\mu}+ z_{u}(x_{\mu},\mu) - z_{l}(x_{\mu},\mu) = 0 \quad \text{and} \quad c(x_{\mu}) = 0\end{split}
\end{equation}
In this equation, the \(z_l\) and \(z_u\) vectors seem to play the role of Lagrange multipliers for the simple bound inequalities, and indeed, when \(\mu\rightarrow 0\), they converge toward some suitable Lagrange multipliers for the KKT conditions, provided some technical assumptions are fulfilled (see \sphinxcite{references:forsgren2002}).

Equation \eqref{equation:documentation/algorithmsOptimization:muproblemlambda} is solved by performing a Newton method in order to find a solution of \eqref{equation:documentation/algorithmsOptimization:muproblem} for each of the decreasing values of \(\mu\).
Some order 2 conditions are also taken into account to avoid convergence to local maximizers, see \sphinxcite{references:forsgren2002} for details about them.
In the most classic IP algorithms, the Newton method is directly applied to \eqref{equation:documentation/algorithmsOptimization:muproblem}.
This is in most case inefficient due to frequent computation of infeasible points.
These difficulties are avoided in Primal-Dual interior point methods where \eqref{equation:documentation/algorithmsOptimization:muproblem} is transformed into an extended system where \(z_u\) and \(z_l\) are treated as unknowns and the barrier problems are finding \((x,\lambda,z_u,z_l)\in\mathbb{R}^n\times\mathbb{R}^m\times\mathbb{R}^n\times\mathbb{R}^n\) such that:
\begin{equation}\label{equation:documentation/algorithmsOptimization:PrimalDualIPBarrierProblem}
\begin{split}\left\lbrace
\begin{array}{rcl}
   \nabla f(x) + J_{c}(x)^{T}\lambda+ z_{u} - z_{l} & = & 0 \\
   c(x) & = & 0 \\
   (X_u - X) z_u - \mu e & = & 0 \\
   (X - X_l) z_l - \mu e & = & 0
\end{array}
\right.\end{split}
\end{equation}
Where if \(a\) is a vector of \(\mathbb{R}^n\), \(A\) denotes the diagonal matrix \(A=(a_i \delta_{ij})_{1\leq i,j\leq n}\) and \(e\in\mathbb{R}^{n} = (1,1,\dots,1)\).
Solving this nonlinear system by the Newton method is known as being the \sphinxstyleemphasis{primal-dual} interior point method.
Here again, more details are available in \sphinxcite{references:forsgren2002}.
Most actual implementations introduce features in order to globalize the convergence capability of the method, essentially by adding some line-search steps to the Newton algorithm, or by using trust regions.
For the purpose of IPOPT, this is achieved by a \sphinxstyleemphasis{filter line search} methods, the details of which can be found in \sphinxcite{references:wachter2006}.

More IPOPT specific features or implementation details can be found in \sphinxcite{references:wachter2006}.
We will just retain that IPOPT is a smart Newton method for solving constrained optimization problems, with global convergence capabilities due to a robust line search method (in the sense that the algorithm will converge no matter the initializer).
Due to the underlying Newton method, the optimization process requires expressions of all derivatives up to the order 2 of the fitness function as well as those of the constraints.
For problems whose Hessian matrices are difficult to compute or lead to high dimensional dense matrices, it is possible to use a BFGS approximation of these objects at the cost of a much slower convergence rate.


\subsubsection{IPOPT in \sphinxstylestrong{FreeFEM}}
\label{\detokenize{documentation/algorithmsOptimization:ipopt-in-freefem}}
Calling the IPOPT optimizer in a \sphinxstylestrong{FreeFEM} script is done with the \sphinxcode{\sphinxupquote{IPOPT}} function included in the \sphinxcode{\sphinxupquote{ff-Ipopt}} dynamic library.
IPOPT is designed to solve constrained minimization problems in the form:
\begin{equation*}
\begin{split}\mathrm{find} & x_{0} = \underset{x\in\mathbb{R}^{n}}{\operatorname{argmin}} f(x) \\
\mathrm{s.t.} & \left\lbrace
\begin{array}{l r}
   \forall i\leq n,\ x_{i}^{\mathrm{lb}}\leq x_{i}\leq x_{i}^{\mathrm{ub}} & \mathrm{\ (simple\ bounds)} \\
   \forall i\leq m,\ c_{i}^{\mathrm{lb}}\leq c_{i}(x)\leq c_{i}^{\mathrm{ub}} & \mathrm{(constraints\ functions)}
\end{array}
\right.\end{split}
\end{equation*}
Where \(\mathrm{ub}\) and \(\mathrm{lb}\) stand for “upper bound” and “lower bound”.
If for some \(i, 1\leq i\leq m\) we have \(c_{i}^{\mathrm{lb}} = c_{i}^{\mathrm{ub}}\), it means that \(c_{i}\) is an equality constraint, and an inequality one if \(c_{i}^{\mathrm{lb}} < c_{i}^{\mathrm{ub}}\).

There are different ways to pass the fitness function and constraints.
The more general one is to define the functions using the keyword \sphinxcode{\sphinxupquote{func}}.
Any returned matrix must be a sparse one (type \sphinxcode{\sphinxupquote{matrix}}, not a \sphinxcode{\sphinxupquote{real{[}int,int{]}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Fitness Function, returns a scalar}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gradJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Gradient is a vector}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Constraints}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n}{jacC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Constraints Jacobian}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
In the current version of \sphinxstylestrong{FreeFEM}, returning a \sphinxcode{\sphinxupquote{matrix}} object that is local to a function block leads to undefined results.
For each sparse matrix returning function you define, an extern matrix object has to be declared, whose associated function will overwrite and return on each call.
Here is an example for \sphinxcode{\sphinxupquote{jacC}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{jacCBuffer}\PYG{p}{;} \PYG{c+c1}{//just declare, no need to define yet}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{jacC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{c+c1}{//fill jacCBuffer}
   \PYG{k}{return} \PYG{n}{jacCBuffer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
IPOPT requires the structure of each matrix at the initialization of the algorithm.
Some errors may occur if the matrices are not constant and are built with the \sphinxcode{\sphinxupquote{matrix A = {[}I,J,C{]}}} syntax, or with an intermediary full matrix (\sphinxcode{\sphinxupquote{real{[}int,int{]}}}), because any null coefficient is discarded during the construction of the sparse matrix.
It is also the case when making matrices linear combinations, for which any zero coefficient will result in the suppression of the matrix from the combination.
Some controls are available to avoid such problems.
Check the named parameter descriptions (\sphinxcode{\sphinxupquote{checkindex}}, \sphinxcode{\sphinxupquote{structhess}} and \sphinxcode{\sphinxupquote{structjac}} can help).
We strongly advice to use \sphinxcode{\sphinxupquote{varf}} as much as possible for the matrix forging.
\end{sphinxadmonition}

The Hessian returning function is somewhat different because it has to
be the Hessian of the Lagrangian function:
\begin{equation*}
\begin{split}(x,\sigma_{f},\lambda)\mapsto\sigma_{f}\nabla^{2}f(x)+\displaystyle{\sum_{i=1}^{m}\lambda_{i}\nabla^{2}c_{i}(x)}\ \mathrm{ where }\ \lambda\in\mathbb{R}^{m}\ \mathrm{ and }\ \sigma\in\mathbb{R}\end{split}
\end{equation*}
Your Hessian function should then have the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianLBuffer}\PYG{p}{;} \PYG{c+c1}{//Just to keep it in mind}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{hessianL} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If the constraints functions are all affine, or if there are only simple bound constraints, or no constraint at all, the Lagrangian Hessian is equal to the fitness function Hessian, one can then omit the \sphinxcode{\sphinxupquote{sigma}} and \sphinxcode{\sphinxupquote{lambda}} parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianJBuffer}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{hessianJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Hessian prototype when constraints are affine}
\end{sphinxVerbatim}

When these functions are defined, IPOPT is called this way:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Xi} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//starting point}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianL}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*some named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If the Hessian is omitted, the interface will tell IPOPT to use the (L)BFGS approximation (it can also be enabled with a named parameter, see further).
Simple bound or unconstrained problems do not require the constraints part, so the following expressions are valid:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//IPOPT with BFGS}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianJ}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Newton IPOPT without constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//BFGS, no constraints}
\end{sphinxVerbatim}

Simple bounds are passed using the \sphinxcode{\sphinxupquote{lb}} and \sphinxcode{\sphinxupquote{ub}} named parameters, while constraint bounds are passed with the \sphinxcode{\sphinxupquote{clb}} and \sphinxcode{\sphinxupquote{cub}} ones.
Unboundedness in some directions can be achieved by using the \(1e^{19}\) and \(-1e^{19}\) values that IPOPT recognizes as \(+\infty\) and \(-\infty\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xlb}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xub}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{clb}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cub}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//fill the arrays...}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianL}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{xlb}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{xub}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{c+cm}{/*some other named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{P2 fitness function and affine constraints function :} In the case where the fitness function or constraints function can be expressed respectively in the following forms:
\begin{equation*}
\begin{split}\begin{array}{c c}
    \forall x\in\mathbb{R}^{n},\ f(x) = \frac{1}{2}\left\langle Ax,x \right\rangle + \left\langle b,x\right\rangle & (A,b)\in\mathcal{M}_{n,n}(\mathbb{R})\times\mathbb{R}^{n} \\
    \mathrm{or} ,\ C(x) = Ax + b & (A,b)\in\mathcal{M}_{n,m}(\mathbb{R})\times\mathbb{R}^{m}
\end{array}\end{split}
\end{equation*}
where \(A\) and \(b\) are constant, it is possible to directly pass the \((A,b)\) pair instead of defining 3 (or 2) functions.
It also indicates to IPOPT that some objects are constant and that they have to be evaluated only once, thus avoiding multiple copies of the same matrix.
The syntax is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Affine constraints with \PYGZdq{}standard\PYGZdq{} fitness function}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear part of the constraints}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//constant part of constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianJ}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//[b, A] would work as well.}
\end{sphinxVerbatim}

Note that if you define the constraints in this way, they don’t contribute to the Hessian, so the Hessian should only take one \sphinxcode{\sphinxupquote{real{[}int{]}}} as an argument.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Affine constraints and P2 fitness func}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//bilinear form matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear contribution to f}
\PYG{k+kt}{matrix} \PYG{n}{Ac} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear part of the constraints}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bc} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//constant part of constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Ac}\PYG{p}{,} \PYG{n}{bc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

If both objective and constraint functions are given this way, it automatically activates the IPOPT \sphinxcode{\sphinxupquote{mehrotra\_algorithm}} option (better for linear and quadratic programming according to the documentation).
Otherwise, this option can only be set through the option file (see the named parameters section).

A false case is the one of defining \(f\) in this manner while using standard functions for the constraints:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//bilinear form matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear contribution to f}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//constraints}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n}{jacC}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//constraints Jacobian}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Indeed, when passing \sphinxcode{\sphinxupquote{{[}A, b{]}}} in order to define \(f\), the Lagrangian Hessian is automatically built and has the constant \(x \mapsto A\) function, with no way to add possible constraint contributions, leading to incorrect second order derivatives.
So, a problem should be defined like that in only two cases:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
constraints are nonlinear but you want to use the BFGS mode (then add \sphinxcode{\sphinxupquote{bfgs=1}} to the named parameter),

\item {} 
constraints are affine, but in this case, compatible to pass in the same way

\end{enumerate}

Here are some other valid definitions of the problem (cases when \(f\) is a pure quadratic or linear form, or \(C\) a pure linear function, etc…):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Pure quadratic f \PYGZhy{} A is a matrix}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{c+cm}{/*constraints arguments*/}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Pure linear f \PYGZhy{} b is a real[int]}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{c+cm}{/*constraints arguments*/}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Linear constraints \PYGZhy{} Ac is a matrix}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{c+cm}{/*fitness function arguments*/}\PYG{p}{,} \PYG{n}{Ac}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxstylestrong{Returned Value :} The \sphinxcode{\sphinxupquote{IPOPT}} function returns an error code of type \sphinxcode{\sphinxupquote{int}}.
A zero value is obtained when the algorithm succeeds and positive values reflect the fact that IPOPT encounters minor troubles.
Negative values reveal more problematic cases.
The associated IPOPT return tags are listed in the table below.
The \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{IPOPT pdf documentation} provides a more accurate description of these return statuses:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Success
&\sphinxstyletheadfamily 
Failures
\\
\hline
0 \sphinxcode{\sphinxupquote{Solve\_Succeeded}}
&\\
\hline
1 \sphinxcode{\sphinxupquote{Solved\_To\_Acceptable\_Level}}
&
-1 \sphinxcode{\sphinxupquote{Maximum\_Iterations\_Exceeded}}
\\
\hline
2 \sphinxcode{\sphinxupquote{Infeasible\_Problem\_Detected}}
&
-2 \sphinxcode{\sphinxupquote{Restoration\_Failed}}
\\
\hline
3 \sphinxcode{\sphinxupquote{Search\_Direction\_Becomes\_Too\_Small}}
&
-3 \sphinxcode{\sphinxupquote{Error\_In\_Step\_Computation}}
\\
\hline
4 \sphinxcode{\sphinxupquote{Diverging\_Iterates}}
&
-4 \sphinxcode{\sphinxupquote{Maximum\_CpuTime\_Exceeded}}
\\
\hline
5 \sphinxcode{\sphinxupquote{User\_Requested\_Stop}}
&\\
\hline
6 \sphinxcode{\sphinxupquote{Feasible\_Point\_Found}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Problem definition issues
&\sphinxstyletheadfamily 
Critical errors
\\
\hline
-10 \sphinxcode{\sphinxupquote{Not\_Enough\_Degrees\_Of\_Freedom}}
&
-100 \sphinxcode{\sphinxupquote{Unrecoverable\_Exception}}
\\
\hline
-11 \sphinxcode{\sphinxupquote{Invalid\_Problem\_Definition}}
&
-101 \sphinxcode{\sphinxupquote{NonIpopt\_Exception\_Thrown}}
\\
\hline
-12 \sphinxcode{\sphinxupquote{Invalid\_Option}}
&
-102 \sphinxcode{\sphinxupquote{Insufficient\_Memory}}
\\
\hline
-13 \sphinxcode{\sphinxupquote{Invalid\_Number\_Detected}}
&
-199 \sphinxcode{\sphinxupquote{Internal\_Error}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxstylestrong{Named Parameters :} The available named parameters in this interface are those we thought to be the most subject to variations from one optimization to another, plus a few that are interface specific.
Though, as one could see at \sphinxhref{https://www.coin-or.org/Ipopt/documentation/node59.html}{IPOPT Linear solver}, there are many parameters that can be changed within IPOPT, affecting the algorithm behavior.
These parameters can still be controlled by placing an option file in the execution directory.
Note that \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{IPOPT’s pdf documentation} may provides more information than the previously mentioned online version for certain parameters.
The in-script available parameters are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lb}}, \sphinxcode{\sphinxupquote{ub}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} for lower and upper simple bounds upon the search variables must be of size \(n\) (search space dimension).
If two components of the same index in these arrays are equal then the corresponding search variable is fixed.
By default IPOPT will remove any fixed variable from the optimization process and always use the fixed value when calling functions.
It can be changed using the \sphinxcode{\sphinxupquote{fixedvar}} parameter.

\item {} 
\sphinxcode{\sphinxupquote{clb}}, \sphinxcode{\sphinxupquote{cub}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(m\) (number of constraints) for lower and upper constraints bounds.
Equality between two components of the same index \(i\) in \sphinxcode{\sphinxupquote{clb}} and \sphinxcode{\sphinxupquote{cub}} reflect an equality constraint.

\item {} 
\sphinxcode{\sphinxupquote{structjacc}} : To pass the greatest possible structure (indexes of non null coefficients) of the constraint Jacobians under the form \sphinxcode{\sphinxupquote{{[}I,J{]}}} where \sphinxcode{\sphinxupquote{I}} and \sphinxcode{\sphinxupquote{J}} are two integer arrays.
If not defined, the structure of the constraint Jacobians, evaluated in \sphinxcode{\sphinxupquote{Xi}}, is used (no issue if the Jacobian is constant or always defined with the same \sphinxcode{\sphinxupquote{varf}}, hazardous if it is with a triplet array or if a full matrix is involved).

\item {} 
\sphinxcode{\sphinxupquote{structhess}} : Same as above but for the Hessian function (unused if \(f\) is P2 or less and constraints are affine).
Here again, keep in mind that it is the Hessian of the Lagrangian function (which is equal to the Hessian of \(f\) only if constraints are affine).
If no structure is given with this parameter, the Lagrangian Hessian is evaluated on the starting point, with \(\sigma=1\) and \(\lambda = (1,1,\dots,1)\) (it is safe if all the constraints and fitness function Hessians are constant or build with \sphinxcode{\sphinxupquote{varf}}, and here again it is less reliable if built with a triplet array or a full matrix).

\item {} 
\sphinxcode{\sphinxupquote{checkindex}} : A \sphinxcode{\sphinxupquote{bool}} that triggers a dichotomic index search when matrices are copied from \sphinxstylestrong{FreeFEM} functions to IPOPT arrays.
It is used to avoid wrong index matching when some null coefficients are removed from the matrices by \sphinxstylestrong{FreeFEM}.
It will not solve the problems arising when a too small structure has been given at the initialization of the algorithm.
Enabled by default (except in cases where all matrices are obviously constant).

\item {} 
\sphinxcode{\sphinxupquote{warmstart}} : If set to \sphinxcode{\sphinxupquote{true}}, the constraints dual variables \(\lambda\), and simple bound dual variables are initialized with the values of the arrays passed to \sphinxcode{\sphinxupquote{lm}}, \sphinxcode{\sphinxupquote{lz}} and \sphinxcode{\sphinxupquote{uz}} named parameters (see below).

\item {} 
\sphinxcode{\sphinxupquote{lm}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(m\), which is used to get the final values of the constraints dual variables \(\lambda\) and/or initialize them in case of a warm start (the passed array is also updated to the last dual variables values at the end of the algorithm).

\item {} 
\sphinxcode{\sphinxupquote{lz}}, \sphinxcode{\sphinxupquote{uz}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(n\) to get the final values and/or initialize (in case of a warm start) the dual variables associated to simple bounds.

\item {} 
\sphinxcode{\sphinxupquote{tol}} : \sphinxcode{\sphinxupquote{real}}, convergence tolerance for the algorithm, the default value is \(10^{-8}\).

\item {} 
\sphinxcode{\sphinxupquote{maxiter}} : \sphinxcode{\sphinxupquote{int}}, maximum number of iterations with 3000 as default value.

\item {} 
\sphinxcode{\sphinxupquote{maxcputime}} : \sphinxcode{\sphinxupquote{real}} value, maximum runtime duration. Default is \(10^{6}\) (almost 11 and a halfdays).

\item {} 
\sphinxcode{\sphinxupquote{bfgs}} : \sphinxcode{\sphinxupquote{bool}} enabling or not the (low-storage) BFGS approximation of the Lagrangian Hessian.
It is set to false by default, unless there is no way to compute the Hessian with the functions that have been passed to IPOPT.

\item {} 
\sphinxcode{\sphinxupquote{derivativetest}} : Used to perform a comparison of the derivatives given to IPOPT with finite differences computation.
The possible \sphinxcode{\sphinxupquote{string}} values are : \sphinxcode{\sphinxupquote{"none"}} (default), \sphinxcode{\sphinxupquote{"first-order"}}, \sphinxcode{\sphinxupquote{"second-order"}} and \sphinxcode{\sphinxupquote{"only-second-order"}}.
The associated derivative error tolerance can be changed via the option file.
One should not care about any error given by it before having tried, and failed, to perform a first optimization.

\item {} 
\sphinxcode{\sphinxupquote{dth}} : Perturbation parameter for the derivative test computations with finite differences.
Set by default to \(10^{-8}\).

\item {} 
\sphinxcode{\sphinxupquote{dttol}} : Tolerance value for the derivative test error detection (default value unknown yet, maybe \(10^{-5}\)).

\item {} 
\sphinxcode{\sphinxupquote{optfile}} : \sphinxcode{\sphinxupquote{string}} parameter to specify the IPOPT option file name.
IPOPT will look for a \sphinxcode{\sphinxupquote{ipopt.opt}} file by default.
Options set in the file will overwrite those defined in the \sphinxstylestrong{FreeFEM} script.

\item {} 
\sphinxcode{\sphinxupquote{printlevel}} : An \sphinxcode{\sphinxupquote{int}} to control IPOPT output print level, set to 5 by default, the possible values are from 0 to 12.
A description of the output information is available in the \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{PDF documentation} of IPOPT.

\item {} 
\sphinxcode{\sphinxupquote{fixedvar}} : \sphinxcode{\sphinxupquote{string}} for the definition of simple bound equality constraints treatment : use \sphinxcode{\sphinxupquote{"make\_parameter"}} (default value) to simply remove them from the optimization process (the functions will always be evaluated with the fixed value for those variables), \sphinxcode{\sphinxupquote{"make\_constraint"}} to treat them as any other constraint or \sphinxcode{\sphinxupquote{"relax\_bounds"}} to relax fixing bound constraints.

\item {} 
\sphinxcode{\sphinxupquote{mustrategy}} : a \sphinxcode{\sphinxupquote{string}} to choose the update strategy for the barrier parameter \(\mu\).
The two possible tags are \sphinxcode{\sphinxupquote{"monotone"}}, to use the monotone (Fiacco-McCormick) strategy, or \sphinxcode{\sphinxupquote{"adaptive"}} (default setting).

\item {} 
\sphinxcode{\sphinxupquote{muinit}} : \sphinxcode{\sphinxupquote{real}} positive value for the barrier parameter initialization.
It is only relevant when \sphinxcode{\sphinxupquote{mustrategy}} has been set to \sphinxcode{\sphinxupquote{monotone}}.

\item {} 
\sphinxcode{\sphinxupquote{pivtol}} : \sphinxcode{\sphinxupquote{real}} value to set the pivot tolerance for the linear solver. A smaller number pivots for sparsity, a larger number pivots for stability.
The value has to be in the \([0,1]\) interval and is set to \(10^{-6}\) by default.

\item {} 
\sphinxcode{\sphinxupquote{brf}} : Bound relax factor: before starting the optimization, the bounds given by the user are relaxed.
This option sets the factor for this relaxation.
If it is set to zero, then the bound relaxation is disabled.
This \sphinxcode{\sphinxupquote{real}} has to be positive and its default value is \(10^{-8}\).

\item {} 
\sphinxcode{\sphinxupquote{objvalue}} : An identifier to a \sphinxcode{\sphinxupquote{real}} type variable to get the last value of the objective function (best value in case of success).

\item {} 
\sphinxcode{\sphinxupquote{mumin}} : minimum value for the barrier parameter \(\mu\), a \sphinxcode{\sphinxupquote{real}} with \(10^{-11}\) as default value.

\item {} 
\sphinxcode{\sphinxupquote{linesearch}} : A boolean which disables the line search when set to \sphinxcode{\sphinxupquote{false}}.
The line search is activated by default.
When disabled, the method becomes a standard Newton algorithm instead of a primal-dual system.
The global convergence is then no longer assured, meaning that many initializers could lead to diverging iterates.
But on the other hand, it can be useful when trying to catch a precise local minimum without having some out of control process making the iterate caught by some other near optimum.

\end{itemize}


\subsection{Some short examples using IPOPT}
\label{\detokenize{documentation/algorithmsOptimization:some-short-examples-using-ipopt}}
\begin{sphinxadmonition}{tip}{Tip:}
Ipopt variational inequality
A very simple example consisting of, given two functions \(f\) and \(g\) (defined on \(\Omega\subset\mathbb{R}^{2}\)), minimizing \(J(u) = \displaystyle{\frac{1}{2}\int_{\Omega} \vert\nabla u\vert^{2} - \int_{\Omega}fu}\ \), with \(u\leq g\) almost everywhere:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve}
\PYG{c+c1}{//\PYGZhy{} Delta u = f}
\PYG{c+c1}{//u \PYGZlt{} g}
\PYG{c+c1}{//u = 0 on Gamma}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//rhs function}
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.03}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n}{r}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{lb} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.e19}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ub} \PYG{o}{=} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{vP} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{p}{;}
\end{sphinxVerbatim}

Here we build the matrix and second member associated to the function to fully and finally minimize it.
The \sphinxcode{\sphinxupquote{{[}A,b{]}}} syntax for the fitness function is then used to pass it to IPOPT.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We use simple bounds to impose the boundary condition \(u=0\) on \(\partial\Omega\), as well as the \(u\leq g\) condition.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vGamma} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onGamma} \PYG{o}{=} \PYG{n}{vGamma}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//warning: the boundary conditions are given with lb and ub on border}
\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
Ipopt variational inequality 2

Let \(\Omega\) be a domain of \(\mathbb{R}^{2}\).
\(f_{1}, f_{2}\in L^{2}(\Omega)\) and \(g_{1}, g_{2} \in L^{2}(\partial\Omega)\) four given functions with \(g_{1}\leq g_{2}\) almost everywhere.
We define the space:
\begin{equation*}
\begin{split}V = \left\lbrace (v_{1},v_{2})\in H^{1}(\Omega)^{2} ; v_{1}\vert_{\partial\Omega}=g_{1}, v_{2}\vert_{\partial\Omega}=g_{2}, v_{1}\leq v_{2}\ \mathrm{a.e.}\ \right\rbrace\end{split}
\end{equation*}
as well as the function \(J:H^{1}(\Omega)^{2}\longrightarrow \mathbb{R}\):
\begin{equation*}
\begin{split}J(v_{1},v_{2}) = \displaystyle{\frac{1}{2}\int_{\Omega}\vert\nabla v_{1}\vert^{2} - \int_{\Omega} f_{1}v_{1} + \frac{1}{2}\int_{\Omega}\vert\nabla v_{2}\vert^{2} - \int_{\Omega} f_{2}v_{2}}\end{split}
\end{equation*}
The problem entails finding (numerically) two functions \((u_{1},u_{2}) = \underset{(v_{1},v_{2})\in V}{\operatorname{argmin}} J(v_{1},v_{2})\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}\PYG{c+c1}{//right hand side}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{;}\PYG{c+c1}{//Boundary condition functions}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//starting point}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{lm}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Problem}
   \PYG{k+kt}{varf} \PYG{n}{vP} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
         \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
      \PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{f1}\PYG{o}{*}\PYG{n}{v1}
         \PYG{o}{+} \PYG{n}{f2}\PYG{o}{*}\PYG{n}{v2}
      \PYG{p}{)}
      \PYG{p}{;}

   \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//fitness function matrix}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//and linear form}

   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{II1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{II2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//Constraints matrix}
   \PYG{k+kt}{matrix} \PYG{n}{C1} \PYG{o}{=} \PYG{n+nf}{interpolate} \PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{II1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{C2} \PYG{o}{=} \PYG{n+nf}{interpolate} \PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{II2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{CC} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{C1} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{;} \PYG{c+c1}{// u2 \PYGZhy{} u1 \PYGZgt{} 0}
   \PYG{n}{Wh} \PYG{n}{cl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//constraints lower bounds (no upper bounds)}

   \PYG{c+c1}{//Boundary conditions}
   \PYG{k+kt}{varf} \PYG{n+nf}{vGamma} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onGamma} \PYG{o}{=} \PYG{n}{vGamma}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ub1}\PYG{p}{,} \PYG{n}{ub2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{g2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{lb2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{g2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{:} \PYG{l+m+mf}{1e19}\PYG{p}{;} \PYG{c+c1}{//Unbounded in interior}
   \PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e19}\PYG{p}{;}

   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uzi}\PYG{p}{,} \PYG{n}{uzi2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lzi}\PYG{p}{,} \PYG{n}{lzi2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{Wh} \PYG{n}{lmi} \PYG{o}{=} \PYG{n}{lm}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{;}

   \PYG{c+c1}{// Solve}
   \PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{]}\PYG{p}{,} \PYG{n}{CC}\PYG{p}{,} \PYG{n}{ui1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{cl}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{iter}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uzi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lzi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lmi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{iter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Mesh adpatation}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.004}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uzi}\PYG{p}{,} \PYG{n}{uzi2}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{lzi}\PYG{p}{,} \PYG{n}{lzi2}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{lm} \PYG{o}{=} \PYG{n}{lmi}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{VarIneqFill}.jpg}
\caption{Numerical Approximation of the Variational Inequality}\label{\detokenize{documentation/algorithmsOptimization:id10}}\label{\detokenize{documentation/algorithmsOptimization:figalgovarineqfill}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{VarIneqIso}.jpg}
\caption{Numerical Approximation of the Variational Inequality}\label{\detokenize{documentation/algorithmsOptimization:id11}}\label{\detokenize{documentation/algorithmsOptimization:figalgovarineqiso}}\end{subfigure}
\caption{Variational inequality}

\end{figure}

\end{sphinxadmonition}


\subsection{3D constrained minimum surface with IPOPT}
\label{\detokenize{documentation/algorithmsOptimization:d-constrained-minimum-surface-with-ipopt}}\label{\detokenize{documentation/algorithmsOptimization:VariationalInequality}}

\subsubsection{Area and volume expressions}
\label{\detokenize{documentation/algorithmsOptimization:area-and-volume-expressions}}
This example is aimed at numerically solving some constrained minimum surface problems with the IPOPT algorithm.
We restrain to \(C^{k}\) (\(k\geq 1\)), closed, spherically parametrizable surfaces, i.e. surfaces \(S\) such that:
\begin{equation*}
\begin{split}\exists \rho \in C^{k}([0,2\pi ]\times[0,\pi] ) \vert
S = \left\lbrace
X = \left(
\begin{array} {c}
 \rho(\theta,\phi) \\
 0 \\
 0
\end{array}
\right)
, (\theta,\phi) \in [0,2\pi ]\times[0,\pi]
 \right\rbrace\end{split}
\end{equation*}
Where the components are expressed in the spherical coordinate system.
Let’s call \(\Omega\) the \([0,2\pi ]\times[0,\pi]\) angular parameters set.
In order to exclude self crossing and opened shapes, the following assumptions upon \(\rho\) are made:
\begin{equation*}
\begin{split}\rho \geq 0\ \ \mathrm{and}\ \ \forall \phi, \rho(0,\phi) = \rho(2\pi,\phi)\end{split}
\end{equation*}
For a given function \(\rho\) the first fundamental form (the metric) of the defined surface has the following matrix representation:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msfff}
\begin{split}G =
\left(
\begin{array}{c c}
    \rho^{2}\sin^{2}(\phi) + (\partial_{\theta}\rho)^{2} &\partial_{\theta}\rho\partial_{\phi}\rho \\
    \partial_{\theta}\rho\partial_{\phi}\rho & \rho^{2} + (\partial_{\phi}\rho)^{2} \\
\end{array}
\right)\end{split}
\end{equation}
This metric is used to express the area of the surface.
Let \(g=\det(G)\), then we have:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msarea}
\begin{split}\begin{array}{ll}
    \mathcal{A}(\rho) &= \int{\Omega}{\left\| \partial_{\theta} X \wedge \partial_{\phi} X \right\|} =\int{\Omega}{\sqrt{g}}\\
        &=\int{\Omega}{\sqrt{ \rho^{2}(\partial_{\theta}\rho)^{2} + \rho^{4}\sin^{2}(\phi) + \rho^{2}(\partial_{\phi}\rho)^{2}\sin^{2}(\phi)}d\theta d\phi}
\end{array}\end{split}
\end{equation}
The volume of the space enclosed within the shape is easier to express:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msvolume}
\begin{split}\mathcal{V}(\rho)
= \int{\Omega}{\int_{0}^{\rho(\theta,\phi)} r^{2}\sin(\phi) dr d\theta d\phi}
= \frac{1}{3}\int{\Omega}{\rho^{3} \sin(\phi) d\theta d\phi}\end{split}
\end{equation}

\subsubsection{Derivatives}
\label{\detokenize{documentation/algorithmsOptimization:derivatives}}
In order to use a Newton based interior point optimization algorithm, one must be able to evaluate the derivatives of \(\mathcal{A}\) and \(\mathcal{V}\) with respect to \(rho\).
Concerning the area, we have the following result:
\begin{equation*}
\begin{split}\forall v\in C^{1}(\Omega) \ , \ \langle d\mathcal{A}(\rho),v\rangle
= \int{\Omega}{\frac{1}{2} \frac{ d\bar{g}(\rho)(v)}{\sqrt{g}}d\theta d\phi }\end{split}
\end{equation*}
Where \(\bar{g}\) is the application mapping the \((\theta,\phi) \mapsto g(\theta,\phi)\) scalar field to \(\rho\).
This leads to the following expression, easy to transpose in a freefem script using:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msdarea}
\begin{split}\begin{array}{r c l}
    \forall v\in C^{1}(\Omega)& &\\
    \langle d\mathcal{A}(\rho),v\rangle &=& \int{\Omega}{ \left(2\rho^{3}\sin^{2}(\phi) + \rho(\partial_{\theta}\rho)^{2} + \rho(\partial_{\phi}\rho)^{2}\sin^{2}(\phi) \right) v} \\
    & & +\int{\Omega}{\ \rho^{2}\partial_{\theta}\rho\partial_{\theta} v\ + \ \rho^{2}\partial_{\phi}\rho\sin^{2}(\phi)\partial_{\phi} v }
\end{array}\end{split}
\end{equation}
With a similar approach, one can derive an expression for second order derivatives.
However, comporting no specific difficulties, the detailed calculus are tedious, the result is that these derivatives can be written using a \(3\times 3\) matrix \(\mathbf{B}\) whose coefficients are expressed in term of \(\rho\) and its derivatives with respect to \(\theta\) and \(\phi\), such that:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msd2area}
\begin{split}\forall (w,v)\in C^{1}(\Omega)\ ,\ d^{2}\mathcal{A}(\rho)(w,v) = \int{\Omega}
{
   \left(\begin{array}{c c c} w & \partial_{\theta} w & \partial_{\phi} w \end{array}\right)
   \mathbf{B}
} \left( \begin{array}{c} v \\ \partial_{\theta} v \\ \partial_{\phi} v \end{array} \right) d\theta d\phi\end{split}
\end{equation}
Deriving the volume function derivatives is again an easier task.
We immediately get the following expressions:
\begin{equation}\label{equation:documentation/algorithmsOptimization:msdvolume}
\begin{split}\begin{array}{r c l}
   \forall v\ ,\ \langle d\mathcal{V}(\rho),v\rangle & = & \int{\Omega}{\rho^{2}\sin(\phi)v\ d\theta d\phi} \\
   \forall w,v\ , d^{2}\mathcal{V}(\rho)(w,v) & = & \int{\Omega}{2\rho\sin(\phi)wv\ d\theta d\phi}
\end{array}\end{split}
\end{equation}

\subsubsection{The problem and its script}
\label{\detokenize{documentation/algorithmsOptimization:the-problem-and-its-script}}
The whole code is available in {\hyperref[\detokenize{example/algoOptimizations:exampleipoptminimalsurfacevolume}]{\sphinxcrossref{\DUrole{std,std-ref}{IPOPT minimal surface \& volume example}}}}.
We propose to solve the following problem:

\begin{sphinxadmonition}{tip}{Tip:}
Given a positive function \(\rho_{\mathrm{object}}\) piecewise continuous, and a scalar \(\mathcal{V}_{\mathrm{max}} > \mathcal{V}(\rho_{\mathrm{object}})\), find \(\rho_{0}\) such that:
\begin{equation*}
\begin{split}\rho_{0} = \underset{\rho\in C^{1}(\Omega)}{\operatorname{argmin}}\ \mathcal{A}(\rho)\ ,\ \mathrm{s.t.}\ \rho_{0}\geq\rho_{\mathrm{object}} \ \mathrm{and\ } \mathcal{V}(\rho_{0})\leq \mathcal{V}_{\mathrm{max}}\end{split}
\end{equation*}
If \(\rho_{\mathrm{object}}\) is the spherical parametrization of the surface of a 3-dimensional object (domain) \(\mathcal{O}\), it can be interpreted as finding the surface with minimum area enclosing the object with a given maximum volume. If \(\mathcal{V}_{\mathrm{max}}\) is close to \(\mathcal{V}(\rho_{\mathrm{object}})\), so should be \(\rho_{0}\) and \(\rho_{\mathrm{object}}\). With higher values of \(\mathcal{V}_{\mathrm{max}}\), \(\rho\) should be closer to the unconstrained minimum surface surrounding \(\mathcal{O}\) which is obtained as soon as \(\mathcal{V}_{\mathrm{max}} \geq \frac{4}{3}\pi \|\rho_{\mathrm{object}}\|_{\infty}^{3}\) (sufficient but not necessary).

It also could be interesting to solve the same problem with the constraint \(\mathcal{V}(\rho_{0})\geq \mathcal{V}_{\mathrm{min}}\) which leads to a sphere when \(\mathcal{V}_{\mathrm{min}} \geq \frac{1}{6}\pi \mathrm{diam}(\mathcal{O})^{3}\) and moves toward the solution of the unconstrained problem as \(\mathcal{V}_{\mathrm{min}}\) decreases.

We start by meshing the domain \([0,2\pi]\times\ [0,\pi]\), then a periodic P1 finite elements space is defined.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{regtest}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{shapeswitch} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{40.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{treshold} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r0} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{r0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{e}\PYG{o}{*}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{rr}\PYG{o}{*}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Initial shape definition}
\PYG{c+c1}{//outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations}
\PYG{n}{Vh} \PYG{n}{startshape} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\end{sphinxVerbatim}

We create some finite element functions whose underlying arrays will be used to store the values of dual variables associated to all the constraints in order to reinitialize the algorithm with it in the case where we use mesh adaptation. Doing so, the algorithm will almost restart at the accuracy level it reached before mesh adaptation, thus saving many iterations.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{uz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{lz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{n}{rreal}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{lm} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Then, follows the mesh adaptation loop, and a rendering function, \sphinxcode{\sphinxupquote{Plot3D}}, using 3D mesh to display the shape it is passed with \sphinxcode{\sphinxupquote{medit}} (the \sphinxcode{\sphinxupquote{movemesh23}} procedure often crashes when called with ragged shapes).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{kkk} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k+kt}{func} \PYG{n}{sin2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// A function which transform Th in 3d mesh (r=rho)}
   \PYG{c+c1}{//a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )}
   \PYG{c+c1}{//then displays the resulting mesh with medit}
   \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{Plot3D} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kt}{string} \PYG{k+kp}{cmm}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{ffplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{rhoo}\PYG{p}{;}
      \PYG{n}{rhoo}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
      \PYG{c+c1}{//mesh sTh = square(np, np/2, [2*pi*x, pi*y]);}
      \PYG{c+c1}{//fespace sVh(sTh, P1);}
      \PYG{c+c1}{//Vh rhoplot = rhoo;}
      \PYG{k}{try}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{mesh3} \PYG{n}{Sphere} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{ffplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{else}
            \PYG{n+nf}{medit}\PYG{p}{(}\PYG{k+kp}{cmm}\PYG{p}{,} \PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PLOT ERROR}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here are the functions related to the area computation and its shape derivative, according to equations \eqref{equation:documentation/algorithmsOptimization:msarea} and \eqref{equation:documentation/algorithmsOptimization:msdarea}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Surface computation}
\PYG{c+c1}{//Maybe is it possible to use movemesh23 to have the surface function less complicated}
\PYG{c+c1}{//However, it would not simplify the gradient and the hessian}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Area} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho4}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho(theta,phi) on [0,2pi]x[0,pi] \PYGZhy{} S=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{res}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else}
      \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shape\PYGZus{}evolution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{rho2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{;}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{varf} \PYG{n}{dArea} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{alpha}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
      \PYG{p}{)}
      \PYG{p}{;}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dArea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The function returning the hessian of the area for a given shape is a bit blurry, thus we won’t show here all of equation \eqref{equation:documentation/algorithmsOptimization:msd2area} coefficients definition, they can be found in the \sphinxcode{\sphinxupquote{edp}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianA}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{sqrtPsi3}\PYG{p}{,} \PYG{n}{C00}\PYG{p}{,} \PYG{n}{C01}\PYG{p}{,} \PYG{n}{C02}\PYG{p}{,} \PYG{n}{C11}\PYG{p}{,} \PYG{n}{C12}\PYG{p}{,} \PYG{n}{C22}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{;}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{C0}\PYG{p}{,} \PYG{n}{C1}\PYG{p}{,} \PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sqrtPsi}\PYG{p}{;}
      \PYG{n}{C0} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
      \PYG{n}{C1} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C2} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C00} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C01} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C1}\PYG{p}{;}
      \PYG{n}{C02} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{C11} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C12} \PYG{o}{=} \PYG{n}{C1}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{C22} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{varf} \PYG{n}{d2Area} \PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
      \PYG{o}{=}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}
              \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
         \PYG{p}{)}
         \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi3} \PYG{o}{*} \PYG{p}{(}
              \PYG{n}{C00}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C11}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C22}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
         \PYG{p}{)}
      \PYG{p}{)}
      \PYG{p}{;}
   \PYG{n}{hessianA} \PYG{o}{=} \PYG{n}{d2Area}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{hessianA}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

And the volume related functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Volume computation}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Volume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho3} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{dVolume}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dVolume}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{matrix} \PYG{n}{hessianV}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianVolume}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{hessianV} \PYG{o}{=} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{hessianV}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

If we want to use the volume as a constraint function we must wrap it and its derivatives in some \sphinxstylestrong{FreeFEM} functions returning the appropriate types.
It is not done in the above functions in cases where one wants to use it as a fitness function.
The lagrangian hessian also has to be wrapped since the Volume is not linear with respect to \(\rho\), it has some non-null second order derivatives.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ipVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vol} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Volume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{k}{return} \PYG{n}{vol}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{matrix} \PYG{n}{mdV}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipGradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{GradVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mdV} \PYG{o}{=} \PYG{n}{dvol}\PYG{p}{;} \PYG{k}{return} \PYG{n}{mdV}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{matrix} \PYG{n}{HLagrangian}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipHessianLag} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{objfact}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{HLagrangian} \PYG{o}{=} \PYG{n}{objfact}\PYG{o}{*}\PYG{n}{HessianArea}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{HessianVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{HLagrangian}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{ipGradVolume}} function could pose some troubles during the optimization process because the gradient vector is transformed in a sparse matrix, so any null coefficient will be discarded.
Here we create the IPOPT structure manually and use the \sphinxcode{\sphinxupquote{checkindex}} named-parameter to avoid bad indexing during copies.
This gradient is actually dense, there is no reason for some components to be constantly zero:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gvi}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{gvj}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{gvi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

These two arrays will be passed to IPOPT with \sphinxcode{\sphinxupquote{structjacc={[}gvi,gvj{]}}}.
The last remaining things are the bound definitions.
The simple lower bound must be equal to the components of the P1 projection of \(\rho_{object}\).
And we choose \(\alpha\in [0,1]\) to set \(\mathcal{V}_{\mathrm{max}}\) to \((1-\alpha) \mathcal{V}(\rho_{object}) + \alpha\frac{4}{3}\pi \|\rho_{\mathrm{object}}\|_{\infty}^{3}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{disc1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{disc2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{lb} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{q} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{disc1}\PYG{p}{,} \PYG{n}{disc2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Vobj} \PYG{o}{=} \PYG{n}{Volume}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Vnvc} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object\PYGZus{}inside}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{clb} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{cub} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{alpha}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vobj} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{Vnvc}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Calling IPOPT:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{Area}\PYG{p}{,} \PYG{n}{GradArea}\PYG{p}{,} \PYG{n}{ipHessianLag}\PYG{p}{,} \PYG{n}{ipVolume}\PYG{p}{,} \PYG{n}{ipGradVolume}\PYG{p}{,}
   \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{n}{checkindex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{kkk}\PYG{o}{\PYGZlt{}}\PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{?} \PYG{l+m+mi}{40}\PYG{o}{:}\PYG{l+m+mi}{150}\PYG{p}{,}
   \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{kkk}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lm}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{,} \PYG{n}{structjacc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{gvi}\PYG{p}{,}\PYG{n}{gvj}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IPOPT: res =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shape\PYGZus{}at\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{GradArea}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ShapeGradient}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Finally, before closing the mesh adaptation loop, we have to perform the said adaptation.
The mesh is adaptated with respect to the \(X=(\rho, 0, 0)\) (in spherical coordinates) vector field, not directly with respect to \(\rho\), otherwise the true curvature of the 3D-shape would not be well taken into account.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}
      \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{startshape} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{;}
   \PYG{n}{uz} \PYG{o}{=} \PYG{n}{uz}\PYG{p}{;}
   \PYG{n}{lz} \PYG{o}{=} \PYG{n}{lz}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here are some pictures of the resulting surfaces obtained for decreasing values of \(\alpha\) (and a slightly more complicated object than two orthogonal discs).
We return to the enclosed object when \(\alpha=0\):

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{minsurf3D}.jpg}
\end{figure}
\end{sphinxadmonition}


\subsection{The nlOpt optimizers}
\label{\detokenize{documentation/algorithmsOptimization:the-nlopt-optimizers}}
The \sphinxcode{\sphinxupquote{ff-NLopt}} package provides a \sphinxstylestrong{FreeFEM} interface to the free/open-source library for nonlinear optimization, easing the use of several different free optimization (constrained or not) routines available online along with the PDE solver.
All the algorithms are well documented in \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation}, therefore no exhaustive information concerning their mathematical specificities will be found here and we will focus on the way they are used in a \sphinxstylestrong{FreeFEM} script.
If needing detailed information about these algorithms, visit the website where a description of each of them is given, as well as many bibliographical links.

Most of the gradient based algorithms of NLopt uses a full matrix approximation of the Hessian, so if you’re planning to solve a large scale problem, use the IPOPT optimizer which definitely surpass them.

All the NLopt features are identified that way:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}NLopt}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//define J, u, and maybe grad(J), some constraints etc...}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n}{nloptXXXXXX}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{c+c1}{//Unavoidable part}
   \PYG{n}{grad}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{name} \PYG{n}{of} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{J}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{c+c1}{//if needed}
   \PYG{n}{lb}\PYG{o}{=} \PYG{c+c1}{//Lower bounds array}
   \PYG{n}{ub}\PYG{o}{=} \PYG{c+c1}{//Upper bounds array}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{//Some optional arguments:}
   \PYG{c+c1}{//Constraints functions names,}
   \PYG{c+c1}{//Stopping criteria,}
   \PYG{c+c1}{//Algorithm specific parameters,}
   \PYG{c+c1}{//Etc...}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxcode{\sphinxupquote{XXXXXX}} refers to the algorithm tag (not necessarily 6 characters long).
\sphinxcode{\sphinxupquote{u}} is the starting position (a \sphinxcode{\sphinxupquote{real{[}int{]}}} type array) which will be overwritten by the algorithm, the value at the end being the found \(argmin\).
And as usual, \sphinxcode{\sphinxupquote{J}} is a function taking a \sphinxcode{\sphinxupquote{real{[}int{]}}} type array as argument and returning a \sphinxcode{\sphinxupquote{real}}.
\sphinxcode{\sphinxupquote{grad}}, \sphinxcode{\sphinxupquote{lb}} and \sphinxcode{\sphinxupquote{ub}} are “half-optional” arguments, in the sense that they are obligatory for some routines but not all.

The possible optionally named parameters are the following, note that they are not used by all algorithms (some do not support constraints, or a type of constraints, some are gradient-based and others are derivative free, etc…).
One can refer to the table after the parameters description to check which are the named parameters supported by a specific algorithm.
Using an unsupported parameter will not stop the compiler work, seldom breaks runtime, and will just be ignored.
When it is obvious you are missing a routine, you will get a warning message at runtime (for example if you pass a gradient to a derivative free algorithm, or set the population of a non-genetic one, etc…).
In the following description, \(n\) stands for the dimension of the search space.

\sphinxstylestrong{Half-optional parameters :}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{grad=}} The name of the function which computes the gradient of the cost function (prototype should be \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int{]}}}, both argument and result should have the size \(n\)).
This is needed as soon as a gradient-based method is involved, which is ignored if defined in a derivative free context.

\item {} 
\sphinxcode{\sphinxupquote{lb}}/\sphinxcode{\sphinxupquote{ub}} = Lower and upper bounds arrays ( \sphinxcode{\sphinxupquote{real{[}int{]}}} type) of size \(n\).
Used to define the bounds within which the search variable is allowed to move.
Needed for some algorithms, optional, or unsupported for others.

\item {} 
\sphinxcode{\sphinxupquote{subOpt}} : Only enabled for the Augmented Lagrangian and MLSL methods who need a sub-optimizer in order to work.
Just pass the tag of the desired local algorithm with a \sphinxcode{\sphinxupquote{string}}.

\end{itemize}

\sphinxstylestrong{Constraints related parameters (optional - unused if not specified):}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{IConst}}/\sphinxcode{\sphinxupquote{EConst}} : Allows to pass the name of a function implementing some inequality (resp. equality) constraints on the search space.
The function type must be \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int{]}}} where the size of the returned array is equal to the number of constraints (of the same type - it means that all of the constraints are computed in one vectorial function).
In order to mix inequality and equality constraints in a same minimization attempt, two vectorial functions have to be defined and passed.
See example \eqref{equation:documentation/algorithmsOptimization:varineqex} for more details about how these constraints have to be implemented.

\item {} 
\sphinxcode{\sphinxupquote{gradIConst}}/\sphinxcode{\sphinxupquote{gradEConst}} : Use to provide the inequality (resp. equality) constraints gradient.
These are \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int,int{]}}} type functions.
Assuming we have defined a constraint function (either inequality or equality) with \(p\) constraints, the size of the matrix returned by its associated gradient must be \(p\times n\) (the \(i\)-th line of the matrix is the gradient of the \(i\)-th constraint).
It is needed in a gradient-based context as soon as an inequality or equality constraint function is passed to the optimizer and ignored in all other cases.

\item {} 
\sphinxcode{\sphinxupquote{tolIConst}}/\sphinxcode{\sphinxupquote{tolEConst}} : Tolerance values for each constraint.
This is an array of size equal to the number of inequality (resp. equality) constraints.
Default value is set to \(10^{-12}\) for each constraint of any type.

\end{itemize}

\sphinxstylestrong{Stopping criteria :}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{stopFuncValue}} : Makes the algorithm end when the objective function reaches this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopRelXTol}} : Stops the algorithm when the relative moves in each direction of the search space is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopAbsXTol}} : Stops the algorithm when the moves in each direction of the search space is smaller than the corresponding value in this \sphinxcode{\sphinxupquote{real{[}int{]}}} array.

\item {} 
\sphinxcode{\sphinxupquote{stopRelFTol}} : Stops the algorithm when the relative variation of the objective function is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopAbsFTol}} : Stops the algorithm when the variation of the objective function is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopMaxFEval}} : Stops the algorithm when the number of fitness evaluations reaches this \sphinxcode{\sphinxupquote{integer}} value.

\item {} 
\sphinxcode{\sphinxupquote{stopTime}} : Stops the algorithm when the optimization time in seconds exceeds this \sphinxcode{\sphinxupquote{real}} value.
This is not a strict maximum: the time may exceed it slightly, depending upon the algorithm and on how slow your function evaluation is.

Note that when an AUGLAG or MLSL method is used, the meta-algorithm and the sub-algorithm may have different termination criteria.
Thus, for algorithms of this kind, the following named parameters has been defined (just adding the SO prefix - for Sub-Optimizer) to set the ending condition of the sub-algorithm (the meta one uses the ones above): \sphinxcode{\sphinxupquote{SOStopFuncValue}}, \sphinxcode{\sphinxupquote{SOStopRelXTol}}, and so on… If these are not used, the sub-optimizer will use those of the master routine.

\end{itemize}

\sphinxstylestrong{Other named parameters :}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{popSize}} : \sphinxcode{\sphinxupquote{integer}} used to change the size of the sample for stochastic search methods.
Default value is a peculiar heuristic to the chosen algorithm.

\item {} 
\sphinxcode{\sphinxupquote{SOPopSize}} : Same as above, but when the stochastic search is passed to a meta-algorithm.

\item {} 
\sphinxcode{\sphinxupquote{nGradStored}} : The number (\sphinxcode{\sphinxupquote{integer}} type) of gradients to “remember” from previous optimization steps: increasing this increases the memory requirements but may speed convergence.
It is set to a heuristic value by default.
If used with AUGLAG or MLSL, it will only affect the given subsidiary algorithm.

\end{itemize}

The following table sums up the main characteristics of each algorithm, providing the more important information about which features are supported by which algorithm and what are the unavoidable arguments they need.
More details can be found in \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation}.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[height=22cm]{{nlopttab}.png}
\end{figure}

\begin{sphinxadmonition}{tip}{Tip:}
Variational inequality

Let \(\Omega\) be a domain of \(\mathbb{R}^{2}\), \(f_{1}, f_{2}\in L^{2}(\Omega)\) and \(g_{1}, g_{2} \in L^{2}(\partial\Omega)\) four given functions with \(g_{1}\leq g_{2}\) almost everywhere.

We define the space:
\begin{equation*}
\begin{split}V = \left\lbrace (v_{1},v_{2})\in H^{1}(\Omega)^{2} ; v_{1}\vert_{\partial\Omega}=g_{1}, v_{2}\vert_{\partial\Omega}=g_{2}, v_{1}\leq v_{2}\ \mathrm{a.e.}\ \right\rbrace\end{split}
\end{equation*}
as well as the function \(J:H^{1}(\Omega)^{2}\longrightarrow \mathbb{R}\):
\begin{equation}\label{equation:documentation/algorithmsOptimization:varineqex}
\begin{split}J(v_{1},v_{2}) = \displaystyle{\frac{1}{2}\int_{\Omega}\vert\nabla v_{1}\vert^{2} - \int_{\Omega} f_{1}v_{1} + \frac{1}{2}\int_{\Omega}\vert\nabla v_{2}\vert^{2} - \int_{\Omega} f_{2}v_{2}}\end{split}
\end{equation}
The problem consists in finding (numerically) two functions \((u_{1},u_{2}) = \underset{(v_{1},v_{2})\in V}{\operatorname{argmin}} J(v_{1},v_{2})\).

This can be interpreted as finding \(u_{1}, u_{2}\) as close as possible (in a certain sense) to the solutions of the Laplace equation with respectively \(f_{1}, f_{2}\) second members and \(g_{1}, g_{2}\) Dirichlet boundary conditions with the \(u_{1}\leq u_{2}\) almost everywhere constraint.

Here is the corresponding script to treat this variational inequality problem with one of the NLOpt algorithms.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//A brief script to demonstrate how to use the freefemm interfaced nlopt routines}
\PYG{c+c1}{//The problem consist in solving a simple variational inequality using one of the}
\PYG{c+c1}{//optimization algorithm of nlopt. We restart the algorithlm a few times after}
\PYG{c+c1}{//performing some mesh adaptation to get a more precise output}

\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}NLopt}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{kas} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//choose of the algorithm}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{oldu1}\PYG{p}{,} \PYG{n}{oldu2}\PYG{p}{;}

\PYG{c+c1}{// Adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
   \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

   \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
      \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
      \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
      \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{9}\PYG{p}{)}
         \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{val}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{varf} \PYG{n+nf}{dBFV} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{dA} \PYG{o}{=} \PYG{n}{dBFV}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
      \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad1} \PYG{o}{=} \PYG{n}{dA}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{grad2} \PYG{o}{=} \PYG{n}{dA}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{grad1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
      \PYG{n}{grad2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{X}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Grad}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{grad1}\PYG{p}{;}
      \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{grad2}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{Grad}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dIneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{dconst} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
         \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{dconst}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BordIndex}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Indexes of border d.f.}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Bord}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{k}{if} \PYG{p}{(}\PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{I} \PYG{o}{=} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{bc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{bc}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{I}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{bc}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dBC}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dbc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{dbc} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{I} \PYG{o}{=} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{dbc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{I}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
         \PYG{n}{dbc}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{,} \PYG{n}{I}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{dbc}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{up}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{al} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
      \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{else}\PYG{p}{\PYGZob{}}
      \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oldu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oldu2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{up} \PYG{o}{=} \PYG{l+m+mi}{1000000}\PYG{p}{;}
   \PYG{n}{lo} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1000000}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{up}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{lo}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{up}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{lo}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bctol}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{l+m+mf}{1e100}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptAUGLAG}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lo}\PYG{p}{,}
         \PYG{n}{ub}\PYG{o}{=}\PYG{n}{up}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,} \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,}
         \PYG{n}{subOpt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LBFGS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptMMA}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{up}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptAUGLAG}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,}
         \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,} \PYG{n}{EConst}\PYG{o}{=}\PYG{n}{BC}\PYG{p}{,} \PYG{n}{gradEConst}\PYG{o}{=}\PYG{n}{dBC}\PYG{p}{,}
         \PYG{n}{subOpt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LBFGS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{stopRelXTol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptSLSQP}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,}
         \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,} \PYG{n}{EConst}\PYG{o}{=}\PYG{n}{BC}\PYG{p}{,} \PYG{n}{gradEConst}\PYG{o}{=}\PYG{n}{dBC}\PYG{p}{,}
         \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
   \PYG{n}{best1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{oldu1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
   \PYG{n}{oldu2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Optimization with MPI}
\label{\detokenize{documentation/algorithmsOptimization:optimization-with-mpi}}
The only quick way to use the previously presented algorithms on a parallel architecture lies in parallelizing the used cost function (which is in most real life cases, the expensive part of the algorithm).
Somehow, we provide a parallel version of the CMA-ES algorithm.
The parallelization principle is the trivial one of evolving/genetic algorithms: at each iteration the cost function has to be evaluated \(N\) times without any dependence at all, these \(N\) calculus are then equally distributed to each process.
Calling the MPI version of CMA-ES is nearly the same as calling its sequential version (a complete example of use can be found in the {\hyperref[\detokenize{example/algoOptimizations:examplecmaesmpivariationalinequality}]{\sphinxcrossref{\DUrole{std,std-ref}{CMAES MPI variational inequality example}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mpi\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{// Define J, u and all here}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n}{cmaesMPI}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{stopTolFun}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{stopMaxIter}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{minimum value is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ for u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

If the population size is not changed using the \sphinxcode{\sphinxupquote{popsize}} parameter, it will use the heuristic value slightly changed to be equal to the closest greatest multiple of the size of the communicator used by the optimizer.
The \sphinxstylestrong{FreeFEM} \sphinxcode{\sphinxupquote{mpicommworld}} is used by default.
The user can specify his own MPI communicator with the named parameter \sphinxcode{\sphinxupquote{comm=}}, see the MPI section of this manual for more information about communicators in \sphinxstylestrong{FreeFEM}.


\section{Parallelization}
\label{\detokenize{documentation/parallelization:parallelization}}\label{\detokenize{documentation/parallelization::doc}}
A first attempt of parallelization of \sphinxstylestrong{FreeFEM} is made here with \sphinxstylestrong{MPI}.
An extended interface with MPI has been added to \sphinxstylestrong{FreeFEM} version 3.5, (see the \sphinxhref{https://www.mpi-forum.org/docs/}{MPI documentation} for the functionality of the language).


\subsection{MPI}
\label{\detokenize{documentation/parallelization:mpi}}

\subsubsection{MPI Keywords}
\label{\detokenize{documentation/parallelization:mpi-keywords}}
The following keywords and concepts are used:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{mpiComm}} to defined a \sphinxstyleemphasis{communication world}

\item {} 
\sphinxcode{\sphinxupquote{mpiGroup}} to defined a group of \sphinxstyleemphasis{processors} in the communication world

\item {} 
\sphinxcode{\sphinxupquote{mpiRequest}} to defined a request to wait for the end of the communication

\end{itemize}


\subsubsection{MPI Constants}
\label{\detokenize{documentation/parallelization:mpi-constants}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{mpisize}} The total number of \sphinxstyleemphasis{processes},

\item {} 
\sphinxcode{\sphinxupquote{mpirank}} the id-number of my current process in \sphinxcode{\sphinxupquote{\{0, ..., mpisize-1\}}},

\item {} 
\sphinxcode{\sphinxupquote{mpiUndefined}} The \sphinxcode{\sphinxupquote{MPI\_Undefined}} constant,

\item {} 
\sphinxcode{\sphinxupquote{mpiAnySource}} The \sphinxcode{\sphinxupquote{MPI\_ANY\_SOURCE}} constant,

\item {} 
\sphinxcode{\sphinxupquote{mpiCommWorld}} The \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}} constant,

\item {} 
{[} … {]} and all the keywords of \sphinxcode{\sphinxupquote{MPI\_Op}} for the \sphinxstyleemphasis{reduce} operator: \sphinxcode{\sphinxupquote{mpiMAX}}, \sphinxcode{\sphinxupquote{mpiMIN}}, \sphinxcode{\sphinxupquote{mpiSUM}}, \sphinxcode{\sphinxupquote{mpiPROD}}, \sphinxcode{\sphinxupquote{mpiLAND}}, \sphinxcode{\sphinxupquote{mpiLOR}}, \sphinxcode{\sphinxupquote{mpiLXOR}}, \sphinxcode{\sphinxupquote{mpiBAND}}, \sphinxcode{\sphinxupquote{mpiBXOR}}.

\end{itemize}


\subsubsection{MPI Constructor}
\label{\detokenize{documentation/parallelization:mpi-constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{proc1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{proc2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{key} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// MPI ranks}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI rank = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// MPI}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set a MPI\PYGZus{}Comm to MPI\PYGZus{}COMM\PYGZus{}WORLD}

\PYG{k+kt}{mpiGroup} \PYG{n+nf}{grp}\PYG{p}{(}\PYG{n}{proc1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set MPI\PYGZus{}Group to proc 1,2 in MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{k+kt}{mpiGroup} \PYG{n+nf}{grp1}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{proc1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set MPI\PYGZus{}Group to proc 1,2 in comm}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{ncomm1}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{n}{grp}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set the MPI\PYGZus{}Comm form grp}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{ncomm2}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{n}{key}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//MPI\PYGZus{}Comm\PYGZus{}split(MPI\PYGZus{}Comm comm, int color, int key, MPI\PYGZus{}Comm *ncomm)}

\PYG{k+kt}{mpiRequest} \PYG{n}{rq}\PYG{p}{;} \PYG{c+c1}{//defined an MPI\PYGZus{}Request}
\PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{arq}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//defined an array of 10 MPI\PYGZus{}Request}
\end{sphinxVerbatim}


\subsubsection{MPI Functions}
\label{\detokenize{documentation/parallelization:mpi-functions}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n+nf}{Comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{MPICommSize} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MPIRank} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{MPIRank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI Comm size = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{MPICommSize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI rank in Comm = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{mpiRequest} \PYG{n}{Req}\PYG{p}{;}
\PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ReqArray}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{MPICommSize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
     \PYG{c+c1}{//return processor i with no Resquest in MPI\PYGZus{}COMM\PYGZus{}WORLD}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor any source with no Resquest in MPI\PYGZus{}COMM\PYGZus{}WORLD}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{k+kr}{mpiAnySource}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with no Resquest in Comm}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with no Resquest in Comm}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with Resquest rq in Comm}
    \PYG{c+cm}{/* processor(i, Req, Comm);}
\PYG{c+cm}{    //return processor i with Resquest rq in MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{c+cm}{    processor(i, Req); */}
    \PYG{c+c1}{//return processor i in MPI\PYGZus{}COMM\PYGZus{}WORLD in block mode for synchronously communication}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor any source in MPI\PYGZus{}COMM\PYGZus{}WORLD in block mode for synchronously communication}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{k+kr}{mpiAnySource}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i in in Comm in block mode}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{mpiBarrier}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//do a MPI\PYGZus{}Barrier on communicator Comm}
\PYG{n+nf}{mpiWaitAny}\PYG{p}{(}\PYG{n}{ReqArray}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait add of Request array,}
\PYG{n+nf}{mpiWait}\PYG{p}{(}\PYG{n}{Req}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait on a Request}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{n+nf}{mpiWtime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return MPIWtime in second}
\PYG{k+kt}{real} \PYG{n}{tick} \PYG{o}{=} \PYG{n+nf}{mpiWtick}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return MPIWTick in second}
\end{sphinxVerbatim}

where a \sphinxcode{\sphinxupquote{processor}} is just a integer rank, pointer to a \sphinxcode{\sphinxupquote{MPI\_comm}} and pointer to a \sphinxcode{\sphinxupquote{MPI\_Request}}, and \sphinxcode{\sphinxupquote{processorblock}} with a special \sphinxcode{\sphinxupquote{MPI\_Request}}.


\subsubsection{MPI Communicator operator}
\label{\detokenize{documentation/parallelization:mpi-communicator-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{status}\PYG{p}{;} \PYG{c+c1}{//to get the MPI status of send / recv}
\PYG{k+kt}{real} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{;}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiRequest} \PYG{n}{req}\PYG{p}{;}

\PYG{c+c1}{//send a,b asynchronously to the process 1}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{;}
\PYG{c+c1}{//receive a,b synchronously from the process 10}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{;}

\PYG{c+c1}{//broadcast from processor of comm to other comm processor}
\PYG{c+c1}{// broadcast(processor(10, comm), a);}
\PYG{c+c1}{//send synchronously to the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n}{Send}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//receive synchronously from the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Recv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//send asynchronously to the process 10 the data a without request}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//send asynchronously to the process 10 the data a with request}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//receive asynchronously from the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Irecv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Error asynchronously without request.}
\PYG{c+c1}{// status = Irecv(processor(10), a);}
\end{sphinxVerbatim}

where the data type of \sphinxcode{\sphinxupquote{a}} can be of type of \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{int{[}int,int{]}}}, \sphinxcode{\sphinxupquote{double{[}int,int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int,int{]}}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, \sphinxcode{\sphinxupquote{mesh{[}int{]}}}, \sphinxcode{\sphinxupquote{mesh3{[}int{]}}}, \sphinxcode{\sphinxupquote{matrix}}, \sphinxcode{\sphinxupquote{matrix\textless{}complex\textgreater{}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//send asynchronously to the process 10 the data a with request}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{p}{;}
\PYG{c+c1}{//receive asynchronously from the process 10 the data a with request}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a} \PYG{p}{;}
\end{sphinxVerbatim}

If \sphinxcode{\sphinxupquote{a, b}} are arrays or full matrices of \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, or \sphinxcode{\sphinxupquote{complex}}, we can use the following MPI functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{mpiAlltoall}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{n}{comm}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiAllgather}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{n}{comm}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiGather}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiScatter}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Thank you to Guy-Antoine Atenekeng Kahou for his help to code this interface.


\subsubsection{Schwarz example in parallel}
\label{\detokenize{documentation/parallelization:schwarz-example-in-parallel}}
This example is a rewritting of example \DUrole{xref,std,std-ref}{Schwarz overlapping}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{2} SchwarzParallel.edp
\PYG{c+c1}{\PYGZsh{} OR}
mpirun \PYGZhy{}np \PYG{l+m}{2} FreeFem++\PYGZhy{}mpi SchwarzParallel.edp
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpisize} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sorry, number of processors !=2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{interior} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{exterior} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{interior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{interior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{mpisize}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
    \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e1}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vhother}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhother} \PYG{n}{U} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{//Problem}
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{interior}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{exterior}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Loop }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{pb}\PYG{p}{;}
    \PYG{c+c1}{//send u to the other proc, receive in U}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{U}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{k+kt}{real} \PYG{n}{err0}\PYG{p}{,} \PYG{n}{err1}\PYG{p}{;}
    \PYG{n}{err0} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interior}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{U} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// send err0 to the other proc, receive in err1}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err0}\PYG{p}{;}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{err1}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{err0} \PYG{o}{+} \PYG{n}{err1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} err0 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} err1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{documentation/parallelization:index-0}Todo:}
script freeze in the loop
\end{sphinxadmonition}


\paragraph{True parallel Schwarz example}
\label{\detokenize{documentation/parallelization:true-parallel-schwarz-example}}
\sphinxstyleemphasis{Thank you to F. Nataf}

This is a explanation of the two examples {\hyperref[\detokenize{example/parallelization:examplempigmres2d}]{\sphinxcrossref{\DUrole{std,std-ref}{MPI-GMRES 2D}}}} and {\hyperref[\detokenize{example/parallelization:examplempigmres3d}]{\sphinxcrossref{\DUrole{std,std-ref}{MPI-GMRES 3D}}}}, a Schwarz parallel with a complexity almost independent of the number of process (with a coarse grid preconditioner).

To solve the following Poisson problem on domain \(\Omega\) with boundary \(\Gamma\) in \(L^2(\Omega)\) :
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta u &=& f & \mbox{ in } \Omega\\
    u &=& g & \mbox{ on } \Gamma
\end{array}\end{split}
\end{equation*}
where \(f\) and \(g\) are two given functions of \(L^2(\Omega)\) and of \(H^{\frac12}(\Gamma)\),

Lets introduce \((\pi_i)_{i=1,.., N_p}\) a regular partition of the unity of \(\Omega\), q-e-d:
\begin{equation*}
\begin{split}\pi_i \in \mathcal{C}^0(\Omega) : \quad \pi_i\ge 0 \mbox{ and } \sum_{i=1}^{N_p} \pi_i =1 .\end{split}
\end{equation*}
Denote \(\Omega_i\) the sub domain which is the support of \(\pi_i\) function and also denote \(\Gamma_i\) the boundary of \(\Omega_i\).

The parallel Schwarz method is:

Let \(\ell=0\) the iterator and a initial guest \(u^0\) respecting the boundary condition (i.e. \(u^0_{|\Gamma} = g\)).
\begin{equation}\label{equation:documentation/parallelization:eq:lapl}
\begin{split}\begin{array}{rcll}
    \forall i = 1 .., N_p:&\nonumber\\
    \displaystyle -\Delta u_i^\ell &=& f &\mbox{ in } \Omega_i\\
    u_i^\ell &=& u^\ell & \mbox{ on } \Gamma_i \setminus \Gamma\\
    u_i^\ell &=& g & \mbox{ on } \Gamma_i \cap \Gamma
\end{array}\end{split}
\end{equation}\begin{equation}\label{equation:documentation/parallelization:eq:pu1}
\begin{split}u^{\ell+1} = \sum_{i=1}^{N_p} \pi_i u_i^\ell\end{split}
\end{equation}
After discretization with the Lagrange finite element method, with a compatible mesh \({\mathcal{T}_h}_i\) of \(\Omega_i\), i. e., the exist a global mesh \({\mathcal{T}_h}\) such that \({\mathcal{T}_h}_i\) is include in \({\mathcal{T}_h}\).

Let us denote:
\begin{itemize}
\item {} 
\({V_h}_i\) the finite element space corresponding to domain \(\Omega_i\),

\item {} 
\({\mathcal{N}_h}_i\) is the set of the degree of freedom \(\sigma_i^k\),

\item {} 
\({\mathcal{N}^{\Gamma_i}_{hi}}\) is the set of the degree of freedom of \({V_h}_i\) on the boundary \(\Gamma_i\) of \(\Omega_i\),

\item {} 
\(\sigma_i^k({v_h})\) is the value the degree of freedom \(k\),

\item {} 
\({V_{0h}}_i= \{ {v_h} \in {V_h}_i :\forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}, \quad \sigma_i^k({v_h})=0 \}\),

\item {} 
The conditional expression \(a\;?\;b:c\) is defined like in :c{}`C{}` of \sphinxcode{\sphinxupquote{C++}} language by
\begin{equation*}
\begin{split}a?b: c \equiv
\left\{
\begin{array}{l}
\mbox{if } a \mbox{ is true then return b}\\
\mbox{else return } c\\
\end{array}
\right..\end{split}
\end{equation*}
\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
We never use finite element space associated to the full domain \(\Omega\) because it is too expensive.
\end{sphinxadmonition}

We have to defined to operator to build the previous algorithm:

We denote \({u_h^{\ell}}_{|i}\) the restriction of \(u_h^\ell\) on \({V_h}_i\), so the discrete problem on \(\Omega_i\) of problem \eqref{equation:documentation/parallelization:eq:lapl} is find \({u_h^{\ell}}_{i}\in {V_h}_i\) such that:
\begin{equation*}
\begin{split}\forall {v_h}_i\in V_{0i}:
\int_{\Omega_i} \nabla {v_h}_i \cdot \nabla {u_h}^{\ell}_{i}
= \int_{\Omega_i} f {v_h}_i ,\quad \forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}\;:\; \sigma_i^k({u_h}^\ell_i) = (k\in \Gamma) \; ? \; g_i^k : \sigma_i^k({u_h}^{\ell}_{|i})\end{split}
\end{equation*}
where \(g_i^k\) is the value of \(g\) associated to the degree of freedom \(k\in {\mathcal{N}^{\Gamma_i}_{hi}}\).

In \sphinxstylestrong{FreeFEM}, it can be written has with \sphinxcode{\sphinxupquote{U}} is the vector corresponding to \({u_h^{\ell}}_{|i}\) and the vector \sphinxcode{\sphinxupquote{U1}} is the vector corresponding to \({u_h^{\ell}}_{i}\) is the solution of:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{U1}\PYG{p}{(}\PYG{n}{Ui}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
\PYG{n}{U1} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

where \(\mathtt{onG}[i] =(i \in \Gamma_i\setminus\Gamma) ? 1 : 0\), and \(\mathtt{Bi}\) the right of side of the problem, are defined by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{F}\PYG{o}{*}\PYG{n}{V}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vPbon} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Ai} \PYG{o}{=} \PYG{n}{vPb} \PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG} \PYG{o}{=} \PYG{n}{vPbon}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bi}\PYG{o}{=}\PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the \sphinxstylestrong{FreeFEM} label of \(\Gamma\) is 1 and the label of \(\Gamma_i\setminus \Gamma\) is \(10\).

To build the transfer/update part corresponding to \eqref{equation:documentation/parallelization:eq:pu1} equation on process \(i\), let us call \sphinxcode{\sphinxupquote{njpart}} the number the neighborhood of domain of \(\Omega_i\) (i.e: \(\pi_j\) is none \(0\) of \(\Omega_i\)), we store in an array \sphinxcode{\sphinxupquote{jpart}} of size \sphinxcode{\sphinxupquote{njpart}} all this neighborhood.

Let us introduce two array of matrix, \sphinxcode{\sphinxupquote{Smj{[}j{]}}} to defined the vector to send from \(i\) to \(j\) a neighborhood process, and the matrix \(rMj[j]\) to after to reduce owith neighborhood \(j\) domain.

So the tranfert and update part compute \(v_i= \pi_i u_i + \sum_{j\in J_i} \pi_j u_j\) and can be write the \sphinxstylestrong{FreeFEM} function Update:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{Update} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ui}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{vi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{Usend}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rq}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n+nf}{Irecv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,}\PYG{n}{rq}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Ri}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{rq}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{k+kr}{n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Si}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{mpiWaitAny}\PYG{p}{(}\PYG{n}{rq}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// apply the unity local partition}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n}{Pii}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;} \PYG{c+c1}{//set to pi\PYGZus{}i u\PYGZus{}i}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{vi} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Vrecv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add pi\PYGZus{}j u\PYGZus{}j}
    \PYG{k}{return} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

where the buffer are defined by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{)} \PYG{c+c1}{//defined the send buffer}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)} \PYG{c+c1}{//defined the revc buffer}
\end{sphinxVerbatim}

with the following macro definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{InitU}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{aTh}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)} \PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{U}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{n}{Th} \PYG{o}{=} \PYG{n}{aTh}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;} \PYG{n}{U}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstyleemphasis{First GMRES algorithm:} you can easily accelerate the fixed point algorithm by using a parallel GMRES algorithm after the introduction the following affine \(\mathcal{A}_i\) operator sub domain \(\Omega_i\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{U}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Where the parallel \sphinxcode{\sphinxupquote{MPIGMRES}} or \sphinxcode{\sphinxupquote{MPICG}} algorithm is just a simple way to solve in parallel the following \(A_i x_i = b_i, i = 1, .., N_p\) by just changing the dot product by reduce the local dot product of all process with the following MPI code:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{template}\PYG{p}{\PYGZlt{}}\PYG{n}{class} \PYG{n}{R}\PYG{p}{\PYGZgt{}} \PYG{n+nb}{R }\PYG{n}{ReduceSum1}\PYG{p}{(}\PYG{n+nb}{R }\PYG{n}{s}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}Comm} \PYG{p}{*}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n+nb}{R }\PYG{n+nb}{r }\PYG{p}{=} \PYG{n}{0}\PYG{p}{;}
    \PYG{n}{MPI\PYGZus{}Allreduce}\PYG{p}{(}\PYG{p}{\PYGZam{}}\PYG{n}{s}\PYG{p}{,} \PYG{p}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{n}{1}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}TYPE}\PYG{p}{\PYGZlt{}}\PYG{n}{R}\PYG{p}{\PYGZgt{}}\PYG{p}{::}\PYG{n}{TYPE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}SUM}\PYG{p}{,} \PYG{p}{*}\PYG{n}{comm} \PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This is done in \sphinxcode{\sphinxupquote{MPIGC}} dynamics library tool.

\sphinxstyleemphasis{Second GMRES algorithm:} Use scharwz algorithm as a preconditioner of basic GMRES method to solving the parallel problem.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//the original problem}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{onGi} \PYG{o}{?} \PYG{l+m+mf}{0.}\PYG{o}{:} \PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//remove boundary term}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//the preconditioner}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstyleemphasis{Third GMRES algorithm:} Add a coarse solver to the previous algorithm

First build a coarse grid on processor 0, and the

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{AC}\PYG{p}{,} \PYG{n}{Rci}\PYG{p}{,} \PYG{n}{Pci}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{AC} \PYG{o}{=} \PYG{n}{vPbC}\PYG{p}{(}\PYG{n}{VhC}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the coarse problem}

\PYG{n}{Pci} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the projection on coarse grid}
\PYG{n}{Rci} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//the restriction on Process i grid with the partition pi\PYGZus{}i}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{CoarseSolve} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{V}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{,} \PYG{k+kt}{mpiComm}\PYG{o}{\PYGZam{}} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// solving the coarse problem}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uc}\PYG{p}{(}\PYG{n}{Rci}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{Rci}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiSUM}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{AC}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{Bc}\PYG{p}{;}
    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Uc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{*}\PYG{n}{Uc}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The New preconditionner

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Idea: F. Nataf.}
    \PYG{c+c1}{// 0 \PYGZti{} (I C1A)(I\PYGZhy{}C2A) =\PYGZgt{} I \PYGZti{} \PYGZhy{} C1AC2A +C1A +C2A}
    \PYG{c+c1}{// New Prec P= C1+C2 \PYGZhy{} C1AC2 = C1(I\PYGZhy{} A C2) +C2}
    \PYG{c+c1}{// ( C1(I\PYGZhy{} A C2) +C2 ) Uo}
    \PYG{c+c1}{// V = \PYGZhy{} C2*Uo}
    \PYG{c+c1}{// ....}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CoarseSolve}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}C2*Uo}
    \PYG{n}{U} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//U = (I\PYGZhy{}A C2) Uo}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{U} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//C1( I \PYGZhy{}A C2) Uo}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{U} \PYG{o}{\PYGZhy{}} \PYG{n}{V}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The code of the 4 algorithms:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{epss} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rgmres} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPIAffineGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,}
        \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,}
        \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJC}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,}
        \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{c+c1}{//algo Shwarz for demo}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

We have all ingredient to solve in parallel if we have et the partitions of the unity.
To build this partition we do:

The initial step on process \(1\) to build a coarse mesh, \({\mathcal{T}_h}^*\) of the full domain, and build the partition \(\pi\) function constant equal to \(i\) on each sub domain \(\mathcal{O}_i, i =1 ,.., N_p\), of the grid with the \sphinxcode{\sphinxupquote{metis}} graph partitioner \sphinxcite{references:karypis1995} and on each process \(i\) in \(1..,N_p\) do
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Broadcast from process \(1\), the mesh \({\mathcal{T}_h}^*\) (call \sphinxcode{\sphinxupquote{Thii}} in \sphinxstylestrong{FreeFEM} script), and \(\pi\) function,

\item {} 
remark that the characteristic function \(\mathrm{1\!\!I}_{\mathcal{O}_i}\) of domain \(\mathcal{O}_i\), is defined by \((\pi=i)?1:0\),

\item {} 
Let us call \(\Pi^2_P\) (resp. \(\Pi^2_V\)) the \(L^2\) on \(P_h^*\) the space of the constant finite element function per element on \({\mathcal{T}_h}^*\) (resp. \(V_h^*\) the space of the affine continuous finite element per element on \({\mathcal{T}_h}^*\)) and build in parallel the \(\pi_i\) and \(\Omega_i\), such that \(\mathcal{O}_i\ \subset \Omega_i\) where \(\mathcal{O}_i= supp ((\Pi^2_V \Pi^2_C)^m \mathrm{1\!\!I}_{O_i})\), and \(m\) is a the overlaps size on the coarse mesh (generally one), (this is done in function \sphinxcode{\sphinxupquote{AddLayers(Thii,suppii{[}{]},nlayer,phii{[}{]});}} We choose a function \(\pi^*_i = (\Pi^2_1 \Pi^2_0)^m \mathrm{1\!\!I}_{\mathcal{O}_i}\) so the partition of the unity is simply defined by
\begin{quote}
\begin{equation*}
\begin{split}\pi_i = \frac{\pi_i^*}{\sum_{j=1}^{N_p} \pi_j^*}\end{split}
\end{equation*}
The set \(J_i\) of neighborhood of the domain \(\Omega_i\), and the local version on \(V_{hi}\) can be defined the array \sphinxcode{\sphinxupquote{jpart}} and \sphinxcode{\sphinxupquote{njpart}} with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vhi} \PYG{n}{pii} \PYG{o}{=} \PYG{n}{piistar}\PYG{p}{;}
\PYG{n}{Vhi}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pij}\PYG{p}{(}\PYG{n}{npij}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local partition of 1 = pii + sum\PYGZus{}j pij[j]}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{jpart}\PYG{p}{(}\PYG{n}{npart}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vhi} \PYG{n}{sumphi} \PYG{o}{=} \PYG{n}{piistar}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{npart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ipart}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{pijstar}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pijstar}\PYG{p}{;}
            \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{njpart}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{jpart}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
We call \({\mathcal{T}_h}^*_{ij}\) the sub mesh part of \({\mathcal{T}_h}_i\) where \(\pi_j\) are none zero.
And thanks to the function \sphinxcode{\sphinxupquote{trunc}} to build this array,
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
At this step we have all on the coarse mesh, so we can build the fine final mesh by splitting all meshes: \sphinxcode{\sphinxupquote{Thi, Thij{[}j{]}, Thij{[}j{]}}} with \sphinxstylestrong{FreeFEM} \sphinxcode{\sphinxupquote{trunc}} mesh function which do restriction and slipping.

\item {} 
The construction of the send/recv matrices \sphinxcode{\sphinxupquote{sMj}} and \sphinxtitleref{freefem:{}`rMj}: can done with this code:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{Thi}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whij}\PYG{p}{(}\PYG{n}{Thij}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Pii}\PYG{p}{;} \PYG{n}{Whi} \PYG{n}{wpii} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{;} \PYG{n}{Pii} \PYG{o}{=} \PYG{n}{wpii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Diagonal matrix corresponding X pi\PYGZus{}i}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M send/recive case}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//change mesh to change Whij, Whij}
    \PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whij \PYGZlt{}\PYGZhy{} Whi}
    \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n}{I}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//Whi \PYGZhy{}\PYGZgt{} s Whij}
    \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whij \PYGZhy{}\PYGZgt{} Whi}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

\end{enumerate}

To buil a not too bad application, all variables come from parameters value with the following code

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{vdebug} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ksplit} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}k}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nloc} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sff} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}p, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{gmres} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}gmres}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{dplot} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nC} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}N}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nloc}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

And small include to make graphic in parallel of distribute solution of vector \(u\) on mesh \(T_h\) with the following interface:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIplot.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{k+kt}{mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{cm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{PLOTMPIALL}\PYG{p}{(}\PYG{k+kt}{mesh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{cm}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
The \sphinxcode{\sphinxupquote{cmm=cm, ...}} in the macro argument is a way to quote macro argument so the argument is \sphinxcode{\sphinxupquote{cmm=cm, ...}}.
\end{sphinxadmonition}


\subsection{Parallel sparse solvers}
\label{\detokenize{documentation/parallelization:parallel-sparse-solvers}}\label{\detokenize{documentation/parallelization:parallelsparsesolvers}}
Parallel sparse solvers use several processors to solve linear systems of equation. Like sequential, parallel linear solvers can be direct or iterative. In \sphinxstylestrong{FreeFEM} both are available.


\subsubsection{Using parallel sparse solvers in \sphinxstylestrong{FreeFEM}}
\label{\detokenize{documentation/parallelization:using-parallel-sparse-solvers-in-freefem}}
We recall that the \sphinxcode{\sphinxupquote{solver}} parameters are defined in the following commands: \sphinxcode{\sphinxupquote{solve}}, \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{set}} (setting parameter of a matrix) and in the construction of the matrix corresponding to a bilinear form.
In these commands, the parameter \sphinxcode{\sphinxupquote{solver}} must be set to \sphinxcode{\sphinxupquote{sparsesolver}} for parallel sparse solver.
We have added specify parameters to these command lines for parallel sparse solvers.
These are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lparams}} : vector of integer parameters (\sphinxcode{\sphinxupquote{l}} is for the \sphinxcode{\sphinxupquote{C++}} type \sphinxcode{\sphinxupquote{long}})

\item {} 
\sphinxcode{\sphinxupquote{dparams}} : vector of real parameters

\item {} 
\sphinxcode{\sphinxupquote{sparams}} : string parameters

\item {} 
\sphinxcode{\sphinxupquote{datafilename}} : name of the file which contains solver parameters

\end{itemize}

The following four parameters are only for direct solvers and are vectors.
These parameters allow the user to preprocess the matrix (see the section on {\hyperref[\detokenize{documentation/parallelization:sparse-direct-solver}]{\emph{sparse direct solver}}} for more information).
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{permr}} : row permutation (integer vector)

\item {} 
\sphinxcode{\sphinxupquote{permc}} : column permutation or inverse row permutation (integer vector)

\item {} 
\sphinxcode{\sphinxupquote{scaler}} : row scaling (real vector)

\item {} 
\sphinxcode{\sphinxupquote{scalec}} : column scaling (real vector)

\end{itemize}

There are two possibilities to control solver parameters.
The first method defines parameters with \sphinxcode{\sphinxupquote{lparams}}, \sphinxcode{\sphinxupquote{dparams}} and \sphinxcode{\sphinxupquote{sparams}} in \sphinxcode{\sphinxupquote{.edp}} file.

The second one reads the solver parameters from a data file. The name of this file is specified by \sphinxcode{\sphinxupquote{datafilename}}.
If \sphinxcode{\sphinxupquote{lparams}}, \sphinxcode{\sphinxupquote{dparams}}, \sphinxcode{\sphinxupquote{sparams}} or \sphinxcode{\sphinxupquote{datafilename}} is not provided by the user, the solver’s default values are used.

To use parallel solver in \sphinxstylestrong{FreeFEM}, we need to load the dynamic library corresponding to this solver.
For example to use \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS} solver as parallel solver in \sphinxstylestrong{FreeFEM}, write in the \sphinxcode{\sphinxupquote{.edp}} file \sphinxcode{\sphinxupquote{load "MUMPS\_FreeFem"}}.

If the libraries are not loaded, the default sparse solver will be loaded (default sparse solver is \sphinxcode{\sphinxupquote{UMFPACK}}). The \hyperref[\detokenize{documentation/parallelization:tabparallelizationsparsesolver}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationsparsesolver}}} gives this new value for the different libraries.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Default sparse solver for real and complex arithmetics when we load a parallel sparse solver library}\label{\detokenize{documentation/parallelization:tabparallelizationsparsesolver}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Libraries
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily Default sparse solver
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
real
&\sphinxstyletheadfamily 
complex
\\
\hline
MUMPS\_FreeFem
&
mumps
&
mumps
\\
\hline
real\_SuperLU\_DIST\_FreeFem
&
SuperLU\_DIST
&
previous solver
\\
\hline
complex\_SuperLU\_DIST\_FreeFem
&
previous solver
&
SuperLU\_DIST
\\
\hline
real\_pastix\_FreeFem
&
PaStiX
&
previous solver
\\
\hline
complex\_pastix\_FreeFem
&
previous solver
&
PaStiX
\\
\hline
hips\_FreeFem
&
hips
&
previous solver
\\
\hline
hypre\_FreeFem
&
hypre
&
previous solver
\\
\hline
parms\_FreeFem
&
parms
&
previous solver
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

We also add functions (see \hyperref[\detokenize{documentation/parallelization:tabparallelizationfunction}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationfunction}}}) with no parameter to change the default sparse solver in the \sphinxcode{\sphinxupquote{.edp}} file.
To use these functions, we need to load the library corresponding to the solver.
An example of using different parallel sparse solvers for the same problem is given in {\hyperref[\detokenize{example/parallelization:exampledirectsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Direct solvers example}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Functions that allow to change the default sparse solver for real and complex arithmetics and the result of these functions}\label{\detokenize{documentation/parallelization:tabparallelizationfunction}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Function
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily default sparse solver
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
real
&\sphinxstyletheadfamily 
complex
\\
\hline
defaulttoMUMPS()
&
mumps
&
mumps
\\
\hline
realdefaulttoSuperLUdist()
&
SuperLU\_DIST
&
previous solver
\\
\hline
complexdefaulttoSuperLUdist()
&
previous solver
&
SuperLU\_DIST
\\
\hline
realdefaultopastix()
&
pastix
&
previous solver
\\
\hline
complexdefaulttopastix()
&
previous solver
&
pastix
\\
\hline
defaulttohips()
&
hips
&
previous solver
\\
\hline
defaulttohypre()
&
hypre
&
previous solver
\\
\hline
defaulttoparms()
&
parms
&
previous solver
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{tip}{Tip:}
Test direct solvers

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}SuperLU\PYGZus{}DIST\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST,}
\PYG{k+kt}{complex} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{MUMPS} \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}pastix\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} pastix, complex \PYGZhy{}\PYGZgt{} MUMPS}

\PYG{c+c1}{// Solving with pastix}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffpastix\PYGZus{}iparm\PYGZus{}dparm.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with SuperLU\PYGZus{}DIST}
\PYG{n}{realdefaulttoSuperLUdist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffsuperlu\PYGZus{}dist\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with MUMPS}
\PYG{n}{defaulttoMUMPS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solving solution}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Sparse direct solver}
\label{\detokenize{documentation/parallelization:sparse-direct-solver}}
In this section, we present the sparse direct solvers interfaced with \sphinxstylestrong{FreeFEM}.


\paragraph{MUMPS solver}
\label{\detokenize{documentation/parallelization:mumps-solver}}
MUltifrontal Massively Parallel Solver (\sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}) is an open-source library.

This package solves linear system of the form \(A \: x = b\) where \(A\) is a square sparse matrix with a direct method.
The square matrix considered in MUMPS can be either unsymmetric, symmetric positive definite or general symmetric.

The method implemented in MUMPS is a direct method based on a multifrontal approach.
It constructs a direct factorization \(A \:= \: L\:U\), \(A\: = \: L^t \: D \: L\) depending of the symmetry of the matrix \(A\).
\begin{description}
\item[{MUMPS uses the following libraries :}] \leavevmode\begin{itemize}
\item {} 
\sphinxhref{http://www.netlib.org/blas/}{BLAS},

\item {} 
\sphinxhref{http://www.netlib.org/blacs/}{BLACS},

\item {} 
\sphinxhref{http://www.netlib.org/scalapack/}{ScaLAPACK}.

\end{itemize}

\end{description}

\begin{sphinxadmonition}{warning}{Warning:}
MUMPS does not solve linear system with a rectangular matrix.
\end{sphinxadmonition}

\sphinxstylestrong{MUMPS parameters:}

There are four input parameters in \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS}.
Two integers \sphinxcode{\sphinxupquote{SYM}} and \sphinxcode{\sphinxupquote{PAR}}, a vector of integer of size 40 \sphinxcode{\sphinxupquote{INCTL}} and a vector of real of size 15 \sphinxcode{\sphinxupquote{CNTL}}.

The first parameter gives the type of the matrix: 0 for unsymmetric matrix, 1 for symmetric positive matrix and 2 for general symmetric.

The second parameter defined if the host processor work during the factorization and solves steps : \sphinxcode{\sphinxupquote{PAR=1}} host processor working and \sphinxcode{\sphinxupquote{PAR=0}} host processor not working.

The parameter \sphinxcode{\sphinxupquote{INCTL}} and \sphinxcode{\sphinxupquote{CNTL}} is the control parameter of MUMPS.
The vectors \sphinxcode{\sphinxupquote{ICNTL}} and \sphinxcode{\sphinxupquote{CNTL}} in MUMPS becomes with index 1 like vector in \sphinxcode{\sphinxupquote{Fortran}}.
For more details see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide}.

We describe now some elements of the main parameters of \sphinxcode{\sphinxupquote{ICNTL}} for MUMPS.
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{Input matrix parameter} The input matrix is controlled by parameters \sphinxcode{\sphinxupquote{ICNTL(5)}} and \sphinxcode{\sphinxupquote{ICNTL(18)}}.}] \leavevmode
The matrix format (resp. matrix pattern and matrix entries) are controlled by \sphinxcode{\sphinxupquote{INCTL(5)}} (resp. \sphinxcode{\sphinxupquote{INCTL(18)}}).

The different values of \sphinxcode{\sphinxupquote{ICNTL(5)}} are 0 for assembled format and 1 for element format.
In the current release of \sphinxstylestrong{FreeFEM}, we consider that FE matrix or matrix is storage in assembled format.
Therefore, \sphinxcode{\sphinxupquote{INCTL(5)}} is treated as 0 value.

The main option for \sphinxcode{\sphinxupquote{ICNTL(18)}}: \sphinxcode{\sphinxupquote{INCLTL(18)=0}} centrally on the host processor, \sphinxcode{\sphinxupquote{ICNTL(18)=3}} distributed the input matrix pattern and the entries (recommended option for distributed matrix by developer of MUMPS).
For other values of \sphinxcode{\sphinxupquote{ICNTL(18)}} see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide}.
These values can be used also in \sphinxstylestrong{FreeFEM}.

The default option implemented in \sphinxstylestrong{FreeFEM} are \sphinxcode{\sphinxupquote{ICNTL(5)=0}} and \sphinxcode{\sphinxupquote{ICNTL(18)=0}}.

\end{description}

\item {} 
\sphinxstylestrong{Preprocessing parameter} The preprocessed matrix \(A_{p}\) that will be effectively factored is defined by
\begin{quote}
\begin{equation*}
\begin{split}A_{p} = P \: D_r \: A \: Q_c \ D_c P^t\end{split}
\end{equation*}
where \(P\) is the permutation matrix, \(Q_c\) is the column permutation, \(D_r\) and \(D_c\) are diagonal matrix for respectively row and column scaling.

The ordering strategy to obtain \(P\) is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(7)}}.
The permutation of zero free diagonal \(Q_c\) is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(6)}}.
The row and column scaling is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(18)}}.
These option are connected and also strongly related with \sphinxcode{\sphinxupquote{ICNTL(12)}} (see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide} for more details).

The parameters \sphinxcode{\sphinxupquote{permr}}, \sphinxcode{\sphinxupquote{scaler}}, and \sphinxcode{\sphinxupquote{scalec}} in \sphinxstylestrong{FreeFEM} allow to give permutation matrix(\(P\)), row scaling (\(D_r\)) and column scaling (\(D_c\)) of the user respectively.
\end{quote}

\end{itemize}

\sphinxstylestrong{Calling MUMPS in FreeFEM}

To call MUMPS in \sphinxstylestrong{FreeFEM}, we need to load the dynamic library \sphinxcode{\sphinxupquote{MUMPS\_freefem.dylib}} (MacOSX), \sphinxcode{\sphinxupquote{MUMPS\_freefem.so}} (Unix) or \sphinxcode{\sphinxupquote{MUMPS\_freefem.dll}} (Windows).

This is done in typing \sphinxcode{\sphinxupquote{load "MUMPS\_FreeFem"}} in the \sphinxcode{\sphinxupquote{.edp}} file. We give now the two methods to give the option of MUMPS solver in \sphinxstylestrong{FreeFEM}.
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{Solver parameters is defined in .edp file:} In this method, we need to give the parameters \sphinxcode{\sphinxupquote{lparams}} and \sphinxcode{\sphinxupquote{dparams}}.}] \leavevmode
These parameters are defined for MUMPS by :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{lparams{[}0{]} = SYM}}, \sphinxcode{\sphinxupquote{lparams{[}1{]} = PAR}},

\item {} 
\(\forall i\) = 1,…,40, \sphinxcode{\sphinxupquote{lparams{[}i+1{]} = ICNTL(i)}}

\item {} 
\(\forall i\) = 1,…,15, \sphinxcode{\sphinxupquote{dparams{[}i-1{]} = CNTL(i)}}

\end{itemize}

\end{description}

\item {} 
\sphinxstylestrong{Reading solver parameters on a file:}
\begin{quote}

The structure of data file for MUMPS in \sphinxstylestrong{FreeFEM} is : first line parameter \sphinxcode{\sphinxupquote{SYM}} and second line parameter \sphinxcode{\sphinxupquote{PAR}} and in the following line the different value of vectors \sphinxcode{\sphinxupquote{ICNTL}} and \sphinxcode{\sphinxupquote{CNTL}}.
An example of this parameter file is given in \sphinxcode{\sphinxupquote{ffmumpsfileparam.txt}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{0} \PYG{c+cm}{/* SYM :: 0 for non symmetric matrix, 1 for symmetric definite positive matrix and 2 general symmetric matrix*/}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* PAR :: 0 host not working during factorization and solves steps, 1 host working during factorization and solves steps*/}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(1) :: output stream for error message */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(2) :: output for diagnostic printing, statics and warning message */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(3) :: for global information */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(4) :: Level of printing for error, warning and diagnostic message */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(5) :: matrix format : 0 assembled format, 1 elemental format. */}
\PYG{l+m+mi}{7} \PYG{c+cm}{/* ICNTL(6) :: control option for permuting and/or scaling the matrix in analysis phase */}
\PYG{l+m+mi}{3} \PYG{c+cm}{/* ICNTL(7) :: pivot order strategy : AMD, AMF, metis, pord scotch*/}
\PYG{l+m+mi}{77} \PYG{c+cm}{/* ICNTL(8) :: Row and Column scaling strategy */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(9) :: 0 solve Ax = b, 1 solve the transposed system A\PYGZca{}t x = b : parameter is not considered in the current release of FreeFEM*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(10) :: number of steps of iterative refinement */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(11) :: statics related to linear system depending on ICNTL(9) */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(12) :: constrained ordering strategy for general symmetric matrix */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(13) :: method to control splitting of the root frontal matrix */}
\PYG{l+m+mi}{20} \PYG{c+cm}{/* ICNTL(14) :: percentage increase in the estimated working space (default 20\PYGZbs{}\PYGZpc{})*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(15) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(16) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(17) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{3} \PYG{c+cm}{/* ICNTL(18) :: method for given : matrix pattern and matrix entries : */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(19) :: method to return the Schur complement matrix */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(20) :: right hand side form ( 0 dense form, 1 sparse form) : parameter will be set to 0 for FreeFEM */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(21) :: 0, 1 kept distributed solution : parameter is not considered in the current release of FreeFEM */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(22) :: controls the in\PYGZhy{}core/out\PYGZhy{}of\PYGZhy{}core (OOC) facility */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(23) :: maximum size of the working memory in Megabyte than MUMPS can allocate per working processor */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(24) :: control the detection of null pivot */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(25) :: control the computation of a null space basis */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(26) :: This parameter is only significant with Schur option (ICNTL(19) not zero). : parameter is not considered in the current release of FreeFEM */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8} \PYG{c+cm}{/* ICNTL(27) (Experimental parameter subject to change in next release of MUMPS) :: control the blocking factor for multiple righthand side during the solution phase : parameter is not considered in the current release of FreeFEM */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(28) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(29) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(30) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(31) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(32) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(33) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(34) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(35) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(36) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(37) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(38) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(39) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(40) :: not used in this release of MUMPS*/}
\PYG{l+m+mf}{0.01} \PYG{c+cm}{/* CNTL(1) :: relative threshold for numerical pivoting */}
\PYG{l+m+mf}{1e\PYGZhy{}8} \PYG{c+cm}{/* CNTL(2) :: stopping criteria for iterative refinement */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* CNTL(3) :: threshold for null pivot detection */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* CNTL(4) :: determine the threshold for partial pivoting */}
\PYG{l+m+mf}{0.0} \PYG{c+cm}{/* CNTL(5) :: fixation for null pivots */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(6) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(7) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(8) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(9) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(10) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(11) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(12) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(13) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(14) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(15) :: not used in this release of MUMPS */}
\end{sphinxVerbatim}

If no solver parameter is given, we used default option of MUMPS solver.
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
MUMPS example

A simple example of calling MUMPS in \sphinxstylestrong{FreeFEM} with this two methods is given in the {\hyperref[\detokenize{example/parallelization:examplesolvermumps}]{\sphinxcrossref{\DUrole{std,std-ref}{Test solver MUMPS example}}}}.
\end{sphinxadmonition}


\paragraph{SuperLU distributed solver}
\label{\detokenize{documentation/parallelization:superlu-distributed-solver}}
The package \sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU\_DIST} solves linear systems using LU factorization.
It is a free scientific library

This library provides functions to handle square or rectangular matrix in real and complex arithmetics.
The method implemented in SuperLU\_DIST is a supernodal method.
New release of this package includes a parallel symbolic factorization.
This scientific library is written in C and MPI for communications.

\sphinxstylestrong{SuperLU\_DIST parameters:}

We describe now some parameters of SuperLU\_DIST.
The SuperLU\_DIST library use a 2D-logical process group.
This process grid is specified by \(nprow\) (process row) and \(npcol\) (process column) such that \(N_{p} = nprow \: npcol\) where \(N_{p}\) is the number of all process allocated for SuperLU\_DIST.

The input matrix parameters is controlled by “matrix=” in \sphinxcode{\sphinxupquote{sparams}} for internal parameter or in the third line of parameters file.
The different value are
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{matrix=assembled}} global matrix are available on all process

\item {} 
\sphinxcode{\sphinxupquote{matrix=distributedglobal}} The global matrix is distributed among all the process

\item {} 
\sphinxcode{\sphinxupquote{matrix=distributed}} The input matrix is distributed (not yet implemented)

\end{itemize}

The option arguments of SuperLU\_DIST are described in the section Users-callable routine of the \sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/ug.pdf}{SuperLU users’ guide}.

The parameter \sphinxcode{\sphinxupquote{Fact}} and \sphinxcode{\sphinxupquote{TRANS}} are specified in \sphinxstylestrong{FreeFEM} interfaces to SuperLU\_DIST during the different steps.
For this reason, the value given by the user for this option is not considered.

The factorization LU is calculated in SuperLU\_DIST on the matrix \(A_p\).
\begin{equation*}
\begin{split}A_{p} = P_{c} \: P_r \: D_r \: A \: D_{c} \: P_{c}^{t}\end{split}
\end{equation*}
where \(P_c\) and \(P_r\) is the row and column permutation matrix respectively, \(D_r\) and \(D_c\) are diagonal matrix for respectively row and column scaling.

The option argument \sphinxcode{\sphinxupquote{RowPerm}} (resp. \sphinxcode{\sphinxupquote{ColPerm}}) control the row (resp. column) permutation matrix.
\(D_r\) and \(D_c\) is controlled by the parameter \sphinxcode{\sphinxupquote{DiagScale}}.

The parameter \sphinxcode{\sphinxupquote{permr}}, \sphinxcode{\sphinxupquote{permc}}, \sphinxcode{\sphinxupquote{scaler}}, and \sphinxcode{\sphinxupquote{scalec}} in \sphinxstylestrong{FreeFEM} is provided to give row permutation, column permutation, row scaling and column scaling of the user respectively.

The other parameters for LU factorization are \sphinxcode{\sphinxupquote{ParSymFact}} and \sphinxcode{\sphinxupquote{ReplaceTinyPivot}}.
The parallel symbolic factorization works only on a power of two processes and need the \sphinxcode{\sphinxupquote{ParMetis}} ordering.
The default option argument of SuperLU\_DIST are given in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}}.

\sphinxstylestrong{Calling SuperLU\_DIST in FreeFEM}

To call SuperLU\_DIST in \sphinxstylestrong{FreeFEM}, we need to load the library dynamic correspond to interface.
This done by the following line \sphinxcode{\sphinxupquote{load "real\_superlu \_DIST\_FreeFem"}} (resp. \sphinxcode{\sphinxupquote{load "complex\_superlu\_DIST\_FreeFem"}}) for real (resp. complex) arithmetics in the file \sphinxcode{\sphinxupquote{.edp}}.

\sphinxstylestrong{Solver parameters is defined in .edp file:}

To call SuperLU\_DIST with internal parameter, we used the parameters \sphinxcode{\sphinxupquote{sparams}}.
The value of parameters of SuperLU\_DIST in \sphinxcode{\sphinxupquote{sparams}} are defined by :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nprow=1}},

\item {} 
\sphinxcode{\sphinxupquote{npcol=1}},

\item {} 
\sphinxcode{\sphinxupquote{matrix= distributedgloba}},

\item {} 
\sphinxcode{\sphinxupquote{Fact= DOFACT}},

\item {} 
\sphinxcode{\sphinxupquote{Equil=NO}},

\item {} 
\sphinxcode{\sphinxupquote{ParSymbFact=NO}},

\item {} 
\sphinxcode{\sphinxupquote{ColPerm= MMD\_AT\_PLUS\_A}},

\item {} 
\sphinxcode{\sphinxupquote{RowPerm= LargeDiag}},

\item {} 
\sphinxcode{\sphinxupquote{DiagPivotThresh=1.0}},

\item {} 
\sphinxcode{\sphinxupquote{IterRefine=DOUBLE}},

\item {} 
\sphinxcode{\sphinxupquote{Trans=NOTRANS}},

\item {} 
\sphinxcode{\sphinxupquote{ReplaceTinyPivot=NO}},

\item {} 
\sphinxcode{\sphinxupquote{SolveInitialized=NO}},

\item {} 
\sphinxcode{\sphinxupquote{PrintStat=NO}},

\item {} 
\sphinxcode{\sphinxupquote{DiagScale=NOEQUIL}}

\end{itemize}

This value correspond to the parameter in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}}.
If one parameter is not specified by the user, we take the default value of SuperLU\_DIST.

\sphinxstylestrong{Reading solver parameters on a file:} The structure of data file for SuperLU\_DIST in \sphinxstylestrong{FreeFEM} is given in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}} (default value of the \sphinxstylestrong{FreeFEM} interface).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{1} \PYG{c+cm}{/* nprow : integer value */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* npcol : integer value */}
\PYG{n}{distributedglobal} \PYG{c+cm}{/* matrix input : assembled, distributedglobal, distributed */}
\PYG{n}{DOFACT} \PYG{c+cm}{/* Fact : DOFACT, SamePattern, SamePattern\PYGZus{}SameRowPerm, FACTORED */}
\PYG{n}{NO} \PYG{c+cm}{/* Equil : NO, YES */}
\PYG{n}{NO} \PYG{c+cm}{/* ParSymbFact : NO, YES */}
\PYG{n}{MMD\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A} \PYG{c+cm}{/* ColPerm : NATURAL, MMD\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A, MMD\PYGZus{}ATA, METIS\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A, PARMETIS, MY\PYGZus{}PERMC */}
\PYG{n}{LargeDiag} \PYG{c+cm}{/* RowPerm : NOROWPERM, LargeDiag, MY\PYGZus{}PERMR */}
\PYG{l+m+mf}{1.0} \PYG{c+cm}{/* DiagPivotThresh : real value */}
\PYG{n}{DOUBLE} \PYG{c+cm}{/* IterRefine : NOREFINE, SINGLE, DOUBLE, EXTRA */}
\PYG{n}{NOTRANS} \PYG{c+cm}{/* Trans : NOTRANS, TRANS, CONJ*/}
\PYG{n}{NO} \PYG{c+cm}{/* ReplaceTinyPivot : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* SolveInitialized : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* RefineInitialized : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* PrintStat : NO, YES*/}
\PYG{n}{NOEQUIL} \PYG{c+cm}{/* DiagScale : NOEQUIL, ROW, COL, BOTH*/}
\end{sphinxVerbatim}

If no solver parameter is given, we used default option of SuperLU\_DIST solver.

\begin{sphinxadmonition}{tip}{Tip:}
A simple example of calling SuperLU\_DIST in \sphinxstylestrong{FreeFEM} with this two methods is given in the {\hyperref[\detokenize{example/parallelization:examplesolversuperludist}]{\sphinxcrossref{\DUrole{std,std-ref}{Solver superLU\_DIST example}}}}.
\end{sphinxadmonition}


\paragraph{PaStiX solver}
\label{\detokenize{documentation/parallelization:pastix-solver}}
\sphinxhref{http://pastix.gforge.inria.fr/files/README-txt.html}{PaStiX} (Parallel Sparse matrix package) is a free scientific library under CECILL-C license.
This package solves sparse linear system with a direct and block ILU(k) iterative methods.
his solver can be applied to a real or complex matrix with a symmetric pattern.

\sphinxstylestrong{PaStiX parameters:}

The input \sphinxcode{\sphinxupquote{matrix}} parameter of \sphinxstylestrong{FreeFEM} depend on PaStiX interface.
\sphinxcode{\sphinxupquote{matrix = assembled}} for non distributed matrix.
It is the same parameter for SuperLU\_DIST.

There are four parameters in PaStiX : \sphinxcode{\sphinxupquote{iparm}}, \sphinxcode{\sphinxupquote{dparm}}, \sphinxcode{\sphinxupquote{perm}} and \sphinxcode{\sphinxupquote{invp}}.
These parameters are respectively the integer parameters (vector of size 64), real parameters (vector of size 64), permutation matrix and inverse permutation matrix respectively.
\sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} vectors are described in \sphinxhref{https://gforge.inria.fr/docman/?group\_id=186\&view=listfile\&dirid=246}{PaStiX RefCard}.

The parameters \sphinxcode{\sphinxupquote{permr}} and \sphinxcode{\sphinxupquote{permc}} in \sphinxstylestrong{FreeFEM} are provided to give permutation matrix and inverse permutation matrix of the user respectively.

\sphinxstylestrong{Solver parameters defined in .edp file:}

To call PaStiX in \sphinxstylestrong{FreeFEM} in this case, we need to specify the parameters \sphinxcode{\sphinxupquote{lparams}} and \sphinxcode{\sphinxupquote{dparams}}.
These parameters are defined by :

\(\forall i\) = 0,… ,63, \sphinxcode{\sphinxupquote{lparams{[}i{]} = iparm{[}i{]}}}.

\(\forall i\) = 0,… ,63, \sphinxcode{\sphinxupquote{dparams{[}i{]} = dparm{[}i{]}}}.

\sphinxstylestrong{Reading solver parameters on a file:}

The structure of data file for PaStiX parameters in \sphinxstylestrong{FreeFEM} is: first line structure parameters of the matrix and in the following line the value of vectors \sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} in this order.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{assembled} \PYG{c+cm}{/* matrix input :: assembled, distributed global and distributed */}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{63}\PYG{p}{]}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{63}\PYG{p}{]}
\end{sphinxVerbatim}

An example of this file parameter is given in \sphinxcode{\sphinxupquote{ffpastix\_iparm\_dparm.txt}} with a description of these parameters.
This file is obtained with the example file \sphinxcode{\sphinxupquote{iparm.txt}} and \sphinxcode{\sphinxupquote{dparm.txt}} including in the PaStiX package.

If no solver parameter is given, we use the default option of PaStiX solver.

\begin{sphinxadmonition}{tip}{Tip:}
A simple example of calling PaStiX in \sphinxstylestrong{FreeFEM} with this two methods is given in the {\hyperref[\detokenize{example/parallelization:examplesolverpastix}]{\sphinxcrossref{\DUrole{std,std-ref}{Solver PaStiX example}}}}.
\end{sphinxadmonition}

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationdirectsolver}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationdirectsolver}}}, we recall the different matrix considering in the different direct solvers.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Type of matrix used by the different direct sparse solver}\label{\detokenize{documentation/parallelization:tabparallelizationdirectsolver}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
direct solver
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{7}}
\sphinxstyletheadfamily square matrix
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{7}}
\sphinxstyletheadfamily rectangular matrix
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
sym
&\sphinxstyletheadfamily 
sym pattern
&\sphinxstyletheadfamily 
unsym
&\sphinxstyletheadfamily 
sym
&\sphinxstyletheadfamily 
sym pattern
&\sphinxstyletheadfamily 
unsym
\\
\hline
SuperLU\_DIST
&
yes
&
yes
&
yes
&
yes
&
yes
&
yes
\\
\hline
MUMPS
&
yes
&
yes
&
yes
&
no
&
no
&
no
\\
\hline
Pastix
&
yes
&
yes
&
no
&
no
&
no
&
no
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Parallel sparse iterative solver}
\label{\detokenize{documentation/parallelization:parallel-sparse-iterative-solver}}
Concerning iterative solvers, we have chosen \sphinxhref{https://www-users.cs.umn.edu/~saad/software/pARMS/}{pARMS}, \sphinxhref{http://hips.gforge.inria.fr/}{HIPS} and \sphinxhref{https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{Hypre}.

Each software implements a different type of parallel preconditioner.

So, pARMS implements algebraic domain decomposition preconditioner type such as additive Schwartz \sphinxcite{references:cai1989} and interface method; while HIPS implement hierarchical incomplete factorization and finally HYPRE implements multilevel preconditioner are AMG(Algebraic MultiGrid) and parallel approximated inverse.

To use one of these programs in \sphinxstylestrong{FreeFEM}, you have to install it independently of \sphinxstylestrong{FreeFEM}.
It is also necessary to install the MPI communication library which is essential for communication between the processors and, in some cases, software partitioning graphs like \sphinxhref{http://glaros.dtc.umn.edu/gkhome/metis/metis/overview}{METIS} or \sphinxhref{http://www.labri.fr/perso/pelegrin/scotch/}{Scotch}.

All this preconditioners are used with Krylov subspace methods accelerators.

Krylov subspace methods are iterative methods which consist in finding a solution \(x\) of linear system \(Ax=b\) inside the affine space \(x_0+K_m\) by imposing that \(b-Ax \bot \mathcal{L}_m\), where \(K_m\) is Krylov subspace of dimension \(m\) defined by \(K_m=\{r_0, Ar_0, A^2r_0,...,A^{m-1}r_0\}\) and \(\mathcal{L}_m\) is another subspace of dimension \(m\) which depends on type of Krylov subspace. For example in GMRES, \(\mathcal{L}_m=AK_m\).

We realized an interface which is easy to use, so that the call of these different softwares in \sphinxstylestrong{FreeFEM} is done in the same way.
You just have to load the solver and then specify the parameters to apply to the specific solvers.
In the rest of this chapter, when we talk about Krylov subspace methods we mean one among GMRES, CG and BICGSTAB.


\paragraph{pARMS solver}
\label{\detokenize{documentation/parallelization:parms-solver}}
\sphinxhref{https://www-users.cs.umn.edu/~saad/software/pARMS/}{pARMS} (parallel Algebraic Multilevel Solver) is a software developed by Youssef Saad and al at University of Minnesota.

This software is specialized in the resolution of large sparse non symmetric linear systems of equation.
Solvers developed in pARMS are of type “Krylov’s subspace”.

It consists of variants of GMRES like FGMRES (Flexible GMRES), DGMRES (Deflated GMRES) \sphinxcite{references:saad2003} and BICGSTAB.
pARMS also implements parallel preconditioner like RAS (Restricted Additive Schwarz) \sphinxcite{references:cai1989} and Schur Complement type preconditioner.

All these parallel preconditioners are based on the principle of domain decomposition.
Thus, the matrix \(A\) is partitioned into sub matrices \(A_i\)(\(i=1,...,p\)) where p represents the number of partitions one needs.
The union of \(A_i\) forms the original matrix.
The solution of the overall system is obtained by solving the local systems on \(A_i\) (see \sphinxcite{references:smith1996}).
Therefore, a distinction is made between iterations on \(A\) and the local iterations on \(A_i\).

To solve the local problem on \(A_i\) there are several preconditioners as \sphinxstylestrong{ilut} (Incomplete LU with threshold), \sphinxstylestrong{iluk} (Incomplete LU with level of fill in) and \sphinxstylestrong{ARMS} (Algebraic Recursive Multilevel Solver).

\begin{sphinxadmonition}{tip}{Tip:}
Default parameters

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parms\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//Tell FreeFem that you will use pARMS}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh} \PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real} \PYG{n}{cpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ CPU time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In line 1, the pARMS dynamic library is loaded with interface \sphinxstylestrong{FreeFEM}.
After this, in line 15 we specify that the bilinear form will be solved by the last sparse linear solver load in memory which, in this case, is pARMS.

The parameters used in pARMS in this case are the default one since the user does not have to provide any parameter.

\begin{sphinxadmonition}{note}{Note:}
In order to see the plot of a parallel script, run the command \sphinxcode{\sphinxupquote{FreeFem++-mpi -glut ffglut script.edp}}
\end{sphinxadmonition}
\end{sphinxadmonition}

Here are some default parameters:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{solver=FGMRES}},

\item {} 
\sphinxcode{\sphinxupquote{Krylov dimension=30}},

\item {} 
\sphinxcode{\sphinxupquote{Maximum of Krylov=1000}},

\item {} 
\sphinxcode{\sphinxupquote{Tolerance for convergence=1e-08}} (see book
\sphinxcite{references:saad2003} to understand all this parameters),

\item {} 
\sphinxcode{\sphinxupquote{preconditionner=Restricted Additif Schwarz}}
\sphinxcite{references:cai1989},

\item {} 
\sphinxcode{\sphinxupquote{Inner Krylov dimension=5}},

\item {} 
\sphinxcode{\sphinxupquote{Maximum of inner Krylov dimension=5}},

\item {} 
\sphinxcode{\sphinxupquote{Inner preconditionner=ILUK}}.

\end{itemize}

To specify the parameters to apply to the solver, the user can either give an integer vector for \sphinxstylestrong{integer parameters} and real vectors for \sphinxstylestrong{real parameters} or provide a \sphinxstylestrong{file} which contains those parameters.

\begin{sphinxadmonition}{tip}{Tip:}
User specifies parameters inside two vectors

Lets us consider Navier-Stokes example.
In this example we solve linear systems coming from discretization of Navier-Stokes equations with pARMS.
Parameters of solver is specified by user.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parms\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{16}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{;} \PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{wall} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{inlet} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{uc} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{Stokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ush}\PYG{p}{,} \PYG{n}{vsh}\PYG{p}{,} \PYG{n}{psh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}
            \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{psh}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{psh}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{wall}\PYG{p}{,} \PYG{n}{wall}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{inlet}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{uc}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{Stokes}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set pARMS as linear solver}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{n}{Stokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{k+kp}{bb}\PYG{p}{;}
\end{sphinxVerbatim}

We need two vectors to specify the parameters of the linear solver.
In line 5-6 of the example, we have declared these vectors(\sphinxcode{\sphinxupquote{int{[}int{]} iparm(16); real{[}int{]} dparm(6);}}).
In line 7-10 we have initialized these vectors by negative values.

We do this because all parameters values in pARMS are positive and if you do not change the negative values of one entry of this vector, the default value will be set.

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationlparams}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationlparams}}} and \hyperref[\detokenize{documentation/parallelization:tabparallelizationdparams}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationdparams}}}, we have the meaning of different entries of these vectors.

We run this example on a cluster paradent of Grid5000 and report results in \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetime}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Convergence and time for solving linear system}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{5}%
\begin{varwidth}[t]{\sphinxcolwidth{5}{5}}
\sphinxstyletheadfamily \(n=471281\)
\(nnz=13\times10^6\)
\(Te=571.29\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
np
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{5}}
\sphinxstyletheadfamily add(iluk)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{5}}
\sphinxstyletheadfamily shur(iluk)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
nit
&\sphinxstyletheadfamily 
time
&\sphinxstyletheadfamily 
nit
&\sphinxstyletheadfamily 
time
\\
\hline
4
&
230
&
637.57
&
21
&
557.8
\\
\hline
8
&
240
&
364.12
&
22
&
302.25
\\
\hline
16
&
247
&
212.07
&
24
&
167.5
\\
\hline
32
&
261
&
111.16
&
25
&
81.5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Legend of \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetime}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}}}\label{\detokenize{documentation/parallelization:tabparallelizationlegend}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{n}}
&\sphinxstyletheadfamily 
matrix size
\\
\hline
\sphinxcode{\sphinxupquote{nnz}}
&
number of non null entries inside matrix
\\
\hline
\sphinxcode{\sphinxupquote{nit}}
&
number of iteration for convergence
\\
\hline
\sphinxcode{\sphinxupquote{time}}
&
Time for convergence
\\
\hline
\sphinxcode{\sphinxupquote{Te}}
&
Time for constructing finite element matrix
\\
\hline
\sphinxcode{\sphinxupquote{np}}
&
number of processor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

In this example, we fix the matrix size (in term of finite element, we fix the mesh) and increase the number of processors used to solve the linear system.
We saw that, when the number of processors increases, the time for solving the linear equation decreases, even if the number of iteration increases.
This proves that, using pARMS as solver of linear systems coming from discretization of partial differential equation in \sphinxstylestrong{FreeFEM} can decrease drastically the total time of simulation.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Meaning of \sphinxstyleliteralintitle{\sphinxupquote{lparams}} corresponding variables}\label{\detokenize{documentation/parallelization:tabparallelizationlparams}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
Entries of \sphinxcode{\sphinxupquote{iparm}}
&\sphinxstyletheadfamily 
Significations of each entries
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&
Krylov subspace methods

Different values for this parameters are specify on \hyperref[\detokenize{documentation/parallelization:tabparallelizationparmskrylov}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationparmskrylov}}}
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&
Preconditionner

Different preconditionners for this parameters are  specify on \hyperref[\detokenize{documentation/parallelization:tabparallelizationparmsprecon}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationparmsprecon}}}
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}2{]}}}
&
Krylov subspace dimension in outer iteration: default value 30
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}3{]}}}
&
Maximum of iterations in outer iteration: default value 1000
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}4{]}}}
&
Number of level in arms when used
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}5{]}}}
&
Krylov subspace dimension in inner iteration: default value 3
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}6{]}}}
&
Maximum of iterations in inner iteration: default value 3
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}7{]}}}
&
Symmetric(=1 for symmetric) or unsymmetric matrix:

default value 0(unsymmetric matrix)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}8{]}}}
&
Overlap size between different subdomain: default value 0(no overlap)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}9{]}}}
&
Scale the input matrix or not: Default value 1 (Matrix should be scaled)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}10{]}}}
&
Block size in arms when used: default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}11{]}}}
&
lfil0 (ilut, iluk, and arms) : default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}12{]}}}
&
lfil for Schur complement const : default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}13{]}}}
&
lfil for Schur complement const : default value 20
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}14{]}}}
&
Multicoloring or not in ILU when used : default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}15{]}}}
&
Inner iteration : default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}16{]}}}
&
Print message when solving: default 0 (no message print)
\begin{itemize}
\item {} 
0: no message is print,

\item {} 
1: Convergence informations like number of iteration and residual,

\item {} 
2: Timing for a different step like preconditioner,

\item {} 
3 : Print all informations

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{dparams}} corresponding variables}\label{\detokenize{documentation/parallelization:tabparallelizationdparams}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Entries of \sphinxcode{\sphinxupquote{dparm}}
&\sphinxstyletheadfamily 
Significations of each entries
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}0{]}}}
&
precision for outer iteration : default value 1e-08
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}1{]}}}
&
precision for inner iteration: default value 1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}2{]}}}
&
tolerance used for diagonal domain: : default value 0.1
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}3{]}}}
&
drop tolerance droptol0 (ilut, iluk, and arms) : default value 1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}4{]}}}
&
droptol for Schur complement const: default value 1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}5{]}}}
&
droptol for Schur complement const: default value 1e-2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Krylov Solvers in pARMS}\label{\detokenize{documentation/parallelization:tabparallelizationparmskrylov}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Values of \sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&\sphinxstyletheadfamily 
Krylov subspace methods
\\
\hline
0
&
FGMRES (Flexible GMRES)
\\
\hline
1
&
DGMRES (Deflated GMRES)
\\
\hline
2
&
BICGSTAB
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Preconditionners in pARMS}\label{\detokenize{documentation/parallelization:tabparallelizationparmsprecon}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Values of \sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&\sphinxstyletheadfamily 
Preconditionners type
\\
\hline
0
&
additive Schwartz preconditioner with ilu0 as local preconditioner
\\
\hline
1
&
additive Schwartz preconditioner with iluk as local preconditioner
\\
\hline
2
&
additive Schwartz preconditioner with ilut as local preconditioner
\\
\hline
3
&
additive Schwartz preconditioner with arms as local preconditioner
\\
\hline
4
&
Left Schur complement preconditioner with ilu0 as local preconditioner
\\
\hline
5
&
Left Schur complement preconditioner with ilut as local preconditioner
\\
\hline
6
&
Left Schur complement preconditioner with iluk as local preconditioner
\\
\hline
7
&
Left Schur complement preconditioner with arms as local preconditioner
\\
\hline
8
&
Right Schur complement preconditioner with ilu0 as local preconditioner
\\
\hline
9
&
Right Schur complement preconditioner with ilut as local preconditioner
\\
\hline
10
&
Right Schur complement preconditioner with iluk as local preconditioner
\\
\hline
11
&
Right Schur complement preconditioner with arms as local preconditioner
\\
\hline
12
&
sch\_gilu0, Schur complement preconditioner with global ilu0
\\
\hline
13
&
SchurSymmetric GS preconditioner
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Interfacing with HIPS}
\label{\detokenize{documentation/parallelization:interfacing-with-hips}}
\sphinxhref{http://hips.gforge.inria.fr/}{HIPS} (\sphinxstyleemphasis{Hierarchical Iterative Parallel Solver}) is a scientific library that provides an efficient parallel iterative solver for very large sparse linear systems.
HIPS is available as free software under the CeCILL-C licence.

HIPS implements two solver classes which are the iteratives class (GMRES, PCG) and the Direct class.
Concerning preconditionners, HIPS implements a type of multilevel ILU.
For further informations on those preconditionners see the \sphinxhref{http://hips.gforge.inria.fr/doc/hips\_user.pdf}{HIPS documentation}.

\begin{sphinxadmonition}{tip}{Tip:}
Laplacian 3D solved with HIPS

Let us consider the 3D Laplacian example inside \sphinxstylestrong{FreeFEM} package where after discretization we want to solve the linear equation with HIPS.

The following example is a Laplacian 3D using Hips as linear solver.
We first load Hips solver at line 2.
From line 7 to 18 we specify the parameters for the Hips solver and in line 82 we set these parameters in the linear solver.

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}}} results of running on Cluster Paradent of Grid5000 are reported.
We can see in this running example the efficiency of parallelism.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hips\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//load Hips library}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{14}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//use iterative solver}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//PCG as Krylov method}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Matrix are symmetric}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Pattern are also symmetric}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Scale matrix}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}13}\PYG{p}{;} \PYG{c+c1}{//Tolerance to convergence}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold in ILUT}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold for Schur preconditionner}

\PYG{c+c1}{// Functions}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uex} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{z}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uey} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uez} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,}
    \PYG{k+kp}{reffaceup} \PYG{o}{=} \PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow} \PYG{o}{=} \PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uhe} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uhe min =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{F}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{va} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{ue}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{p}{(}\PYG{n}{uex}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{uey}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{+} \PYG{n}{uez}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{z}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{l} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{o}{=}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Aa} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{F}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Size of A =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Aa}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Non zero coefficients =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Aa}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CPU TIME FOR FORMING MATRIX =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{Aa}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Set hips as linear solver}

\PYG{c+c1}{// Solve}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Aa}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{F}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Legend of this table are give in \hyperref[\detokenize{documentation/parallelization:tabparallelizationlegend}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationlegend}}}}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
\sphinxstyletheadfamily \(n=4\times 10^6\)
\(nnz=118 \times 10^6\)
\(Te=221.34\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{np}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{nit}}
&\sphinxstyletheadfamily 
\sphinxcode{\sphinxupquote{time}}
\\
\hline
8
&
190
&
120.34
\\
\hline
16
&
189
&
61.08
\\
\hline
32
&
186
&
31.70
\\
\hline
64
&
183
&
23.44
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{lparams}} corresponding to HIPS interface}\label{\detokenize{documentation/parallelization:tabparallelizationhipsinterface}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Entries of \sphinxcode{\sphinxupquote{iparm}}
&\sphinxstyletheadfamily 
Significations of each entries
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&
Strategy use for solving (Iterative=0 or Hybrid=1 or Direct=2).

Defaults values are : Iterative
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&
Krylov methods.

If iparm{[}0{]}=0, give type of Krylov methods: 0 for GMRES, 1 for PCG
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}2{]}}}
&
Maximum of iterations in outer iteration: default value 1000
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}3{]}}}
&
Krylov subspace dimension in outer iteration: default value 40
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}4{]}}}
&
Symmetric(=0 for symmetric) and 1 for unsymmetricmatrix:

default value 1 (unsymmetric matrix)
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}5{]}}}
&
Pattern of matrix are symmetric or not: default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}6{]}}}
&
Partition type of input matrix: default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}7{]}}}
&
Number of level that use the HIPS locally consistentfill-in:

Default value 2
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}8{]}}}
&
Numbering in indices array will start at 0 or 1: Default value 0
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}9{]}}}
&
Scale matrix. Default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}10{]}}}
&
Reordering use inside subdomains for reducingfill-in:

Only use for iterative. Default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}11{]}}}
&
Number of unknowns per node in the matrix non-zeropattern graph:

Default value 1
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}12{]}}}
&
This value is used to set the number of time the

normalization is applied to the matrix: Default 2.
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}13{]}}}
&
Level of informations printed during solving: Default 5.
\\
\hline
\sphinxcode{\sphinxupquote{iparm{[}14{]}}}
&
HIPS\_DOMSIZE Subdomain size
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{dparams}} corresponding to HIPS interface}\label{\detokenize{documentation/parallelization:tabparallelizationhipsdparms}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{dparm{[}0{]}}}
&
HIPS\_PREC: Relative residual norm: Default=1e-9
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}1{]}}}
&
HIPS\_DROPTOL0: Numerical threshold in ILUT for interior domain

(important : set 0.0 in HYBRID: Default=0.005)
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}2{]}}}
&
HIPS\_DROPTOL1 : Numerical threshold in ILUT for Schur preconditioner:

Default=0.005
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}3{]}}}
&
HIPS\_DROPTOLE : Numerical threshold for coupling between the interior

level and Schur: Default 0.005
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}4{]}}}
&
HIPS\_AMALG : Numerical threshold for coupling between the interior level

and Schur: Default=0.005
\\
\hline
\sphinxcode{\sphinxupquote{dparm{[}5{]}}}
&
HIPS\_DROPSCHUR : Numerical threshold for coupling between the interior

level and Schur: Default=0.005
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\paragraph{Interfacing with HYPRE}
\label{\detokenize{documentation/parallelization:interfacing-with-hypre}}
\sphinxhref{https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{Hypre} (High Level Preconditioner) is a suite of parallel preconditioner developed at Lawrence Livermore National Lab.

There are two main classes of preconditioners developed in HYPRE: AMG (Algebraic MultiGrid) and Parasails (Parallel Sparse Approximate Inverse).

Now, suppose we want to solve \(Ax=b\).

At the heart of AMG there is a series of progressively coarser (smaller) representations of the matrix \(A\).
Given an approximation \(\hat{x}\) to the solution \(x\), consider solving the residual equation \(Ae=r\) to find the error \(e\), where \(r=b-A\hat{x}\).
A fundamental principle of AMG is that it is an algebraically smooth error.
To reduce the algebraically smooth errors further, they need to be represented by a smaller defect equation (coarse grid residual equation) \(A_ce_c=r_c\), which is cheaper to solve.
After solving this coarse equation, the solution is then interpolated in fine grid represented here by matrix \(A\).
The quality of AMG depends on the choice of coarsening and interpolating operators.

The \sphinxstyleemphasis{sparse approximate inverse} approximates the inverse of a matrix \(A\) by a sparse matrix \(M\).
A technical idea to construct matrix \(M\) is to minimize the Frobenuis norm of the residual matrix \(I-MA\).
For more details on this preconditioner technics see \sphinxcite{references:chow1997}.

HYPRE implement three Krylov subspace solvers: GMRES, PCG and BiCGStab.

\begin{sphinxadmonition}{tip}{Tip:}
Laplacian 3D solved with HYPRE

Let us consider again the 3D Laplacian example inside \sphinxstylestrong{FreeFEM} package where after discretization we want to solve the linear equation with Hypre.
The following example is a Laplacian 3D using Hypre as linear solver.
This is the same example as Hips one, so we just show here the lines where we set some Hypre parameters.

We first load the Hypre solver at line 2.
From line 6 to 18 we specifies the parameters to set to Hypre solver and in line 22 we set parameters to Hypre solver.

It should be noted that the meaning of the entries of these vectors is different from those of Hips.
In the case of HYPRE, the meaning of differents entries of vectors \sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} are given in \hyperref[\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}}} to \hyperref[\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}}}.

In \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}}} the results of running on Cluster Paradent of Grid5000 are reported.
We can see in this running example the efficiency of parallelism, in particular when AMG are use as preconditioner.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hipre\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//Load Hipre librairy}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//PCG as krylov method}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//AMG as preconditionner 2: if ParaSails}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;} \PYG{c+c1}{//Interpolation}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{c+c1}{//AMG Coarsen type}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Measure type}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//Additive schwarz as smoother}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}13}\PYG{p}{;} \PYG{c+c1}{//Tolerance to convergence}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Truncation factor}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{Aa}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of common entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} vectors for every preconditioner in HYPRE}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}0{]}}}
&
Solver identification:

0: BiCGStab, 1: GMRES, 2: PCG. Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}1{]}}}
&
Preconditioner identification:

0: BOOMER AMG, 1: PILUT, 2: Parasails, 3: Schwartz Default=0
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}2{]}}}
&
Maximum of iteration: Default=1000
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}3{]}}}
&
Krylov subspace dim: Default= 40
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}4{]}}}
&
Solver print info level: Default=2
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}5{]}}}
&
Solver log: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}6{]}}}
&
Solver stopping criteria only for BiCGStab : Default=1
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}0{]}}}
&
Tolerance for convergence: Default=:math:\sphinxtitleref{1.0e-11}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is BOOMER AMG}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsboomer}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
AMG interpolation type: Default=6
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Specifies the use of GSMG - geometrically smooth coarsening and

interpolation: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}9{]}}}
&
AMG coarsen type: Default=6
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}10{]}}}
&
Defines whether local or global measures are used: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}11{]}}}
&
AMG cycle type: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}12{]}}}
&
AMG Smoother type: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}13{]}}}
&
AMG number of levels for smoothers: Default=3
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}14{]}}}
&
AMG number of sweeps for smoothers: Default=2
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}15{]}}}
&
Maximum number of multigrid levels: Default=25
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}16{]}}}
&
Defines which variant of the Schwartz method isused:

0: hybrid multiplicative Schwartz method (no overlap across processor boundaries)

1: hybrid additive Schwartz method (no overlap across processor boundaries)

2: additive Schwartz method

3: hybrid multiplicative Schwartz method (with overlap across processor boundaries)

Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}17{]}}}
&
Size of the system of PDEs: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}18{]}}}
&
Overlap for the Schwarz method: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}19{]}}}
&
Type of domain used for the Schwarz method

0: each point is a domain

1: each node is a domain (only of interest in “systems” AMG)

2: each domain is generated by agglomeration (default)
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
AMG strength threshold: Default=0.25
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}2{]}}}
&
Truncation factor for the interpolation: Default=1e-2
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}3{]}}}
&
Sets a parameter to modify the definition of strength for

diagonal dominant portions of the matrix: Default=0.9
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}3{]}}}
&
Defines a smoothing parameter for the additive Schwartz method. Default=1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is PILUT}\label{\detokenize{documentation/parallelization:id9}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
Row size in Parallel ILUT: Default=1000
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Set maximum number of iterations: Default=30
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
Drop tolerance in Parallel ILUT: Default=1e-5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is ParaSails}\label{\detokenize{documentation/parallelization:id10}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
Number of levels in Parallel Sparse Approximate inverse: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Symmetric parameter for the ParaSails preconditioner:

0: nonsymmetric and/or indefinite problem, and nonsymmetric preconditioner

1: SPD problem, and SPD (factored) preconditioner

2: nonsymmetric, definite problem, and SPD (factored) preconditioner

Default=0
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
Filters parameters. The filter parameter is used to drop small nonzeros in the preconditioner,

to reduce the cost of applying the preconditioner: Default=0.1
\\
\hline
\sphinxcode{\sphinxupquote{dparms{[}2{]}}}
&
Threshold parameter: Default=0.1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditionner is Schwartz}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
Defines which variant of the Schwartz method isused:

0: hybrid multiplicative Schwartz method (no overlap across processor boundaries)

1: hybrid additive Schwartz method (no overlap across processor boundaries)

2: additive Schwartz method

3: hybrid multiplicative Schwartz method (with overlap across processor boundaries)

Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
Overlap for the Schwartz method: Default=1
\\
\hline
\sphinxcode{\sphinxupquote{iparms{[}9{]}}}
&
Type of domain used for the Schwartz method

0: each point is a domain

1: each node is a domain (only of interest in “systems” AMG)

2: each domain is generated by agglomeration (default)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Convergence and time for solving linear system}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\(n=4\times10^6\)
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxstyletheadfamily \(nnz=13\times10^6\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstyletheadfamily 
\(Te = 571.29\)
\\
\hline\sphinxstyletheadfamily 
np
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxstyletheadfamily AMG
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxtitleref{nit}
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxstyletheadfamily \sphinxtitleref{time}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
8
&
6
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
1491.83
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
16
&
5
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
708.49
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
32
&
4
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
296.22
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
64
&
4
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
145.64
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Conclusion}
\label{\detokenize{documentation/parallelization:conclusion}}
With the different runs presented here, we wanted to illustrate the gain in time when we increase the number of processors used for the simulations.
We saw that in every case the time for the construction of the finite element matrix is constant.
This is normal because until now this phase is sequential in \sphinxstylestrong{FreeFEM}.
In contrast, phases for solving the linear system are parallel.
We saw on several examples presented here that when we increase the number of processors, in general we decrease the time used for solving the linear systems.
But this is not true in every case.
In several case, when we increase the number of processors the time to convergence also increases.
There are two main reasons for this.
First, the increase of processors can lead to the increase of volume of exchanged data across processors consequently increasing the time for solving the linear systems.

Furthermore, in decomposition domain type preconditioners, the number of processors generally corresponds to the number of sub domains.
In subdomain methods, generally when we increase the number of subdomains we decrease convergence quality of the preconditioner.
This can increase the time used for solving linear equations.

To end this, we should note that good use of the preconditioners interfaced in \sphinxstylestrong{FreeFEM} is empiric, because it is difficult to know what is a good preconditioner for some type of problems.
Although, the efficiency of preconditioners sometimes depends on how its parameters are set.
For this reason we advise the user to pay attention to the meaning of the parameters in the user guide of the iterative solvers interfaced in \sphinxstylestrong{FreeFEM}.


\subsubsection{Domain decomposition}
\label{\detokenize{documentation/parallelization:domain-decomposition}}
In the previous section, we saw that the phases to construct a matrix are sequential.
One strategy to construct the matrix in parallel is to divide geometrically the domain into subdomains.
In every subdomain we construct a local submatrix and after that we assemble every submatrix to form the global matrix.

We can use this technique to solve PDE directly in domain \(\Omega\).
In this case, in every subdomains you have to define artificial boundary conditions to form consistent equations in every subdomains.
After this, you solve equation in every subdomains and define a strategy to obtain the global solution.

In terms of parallel programming for \sphinxstylestrong{FreeFEM}, with MPI, this means that the user must be able to divide processors avaible for computation into subgroups of processors and also must be able to realize different type of communications in \sphinxstylestrong{FreeFEM} script.
Here is a wrapper of some MPI functions.


\paragraph{Communicators and groups}
\label{\detokenize{documentation/parallelization:communicators-and-groups}}
\sphinxstylestrong{Groups}

\sphinxcode{\sphinxupquote{mpiGroup grpe(mpiGroup gp, KN\_\textless{}long\textgreater{})}}: Create MPI\_Group from existing group \sphinxcode{\sphinxupquote{gp}} by given vector.

\sphinxstylestrong{Communicators}

Communicators is an abstract MPI object which allows MPI user to communicate across group of processors.
Communicators can be Intra-communicators(involves a single group) or Inter-communicators (involves two groups).
When we not specify type of communicator it will be Intra-communicators

\sphinxstylestrong{mpiComm cc(mpiComm comm, mpiGroup gp):} Creates a new communicator.

\sphinxcode{\sphinxupquote{comm}} communicator(handle), \sphinxcode{\sphinxupquote{gp}} group which is a subset of the group of \sphinxcode{\sphinxupquote{comm}} (handle).
Return new communicator

\sphinxstylestrong{mpiComm cc(mpiGroup gp)}: Same as previous constructor but default \sphinxcode{\sphinxupquote{comm}} here is \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxstylestrong{mpiComm cc(mpiComm comm, int color, int key):} Creates new communicators based on \sphinxcode{\sphinxupquote{colors}} and \sphinxcode{\sphinxupquote{key}}.
This constructor is based on MPI\_Comm\_split routine of MPI.

\sphinxstylestrong{mpiComm cc(MPIrank p, int key):} Same constructor than the last one.

Here \sphinxcode{\sphinxupquote{colors}} and \sphinxcode{\sphinxupquote{comm}} is defined in \sphinxcode{\sphinxupquote{MPIrank}}.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Comm\_split}} routine of MPI.

\begin{sphinxadmonition}{tip}{Tip:}
Split communicator

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{color}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{qpp}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{cp}\PYG{p}{(}\PYG{n}{ccc}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxstylestrong{mpiComm cc(mpiComm comm, int high):} Creates an intracommunicator from an intercommunicator. \sphinxcode{\sphinxupquote{comm}} intercommunicator, \sphinxcode{\sphinxupquote{high}}.

Used to order the groups within \sphinxcode{\sphinxupquote{comm}} (logical) when creating the new communicator.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Intercomm\_merge}} routine of MPI.

\sphinxstylestrong{mpiComm cc(MPIrank p1, MPIrank p2, int tag):} This constructor creates an intercommuncator from two intracommunicators.
\sphinxcode{\sphinxupquote{p1}} defined local (intra)communicator and rank in \sphinxcode{\sphinxupquote{local\_comm}} of leader (often 0) while \sphinxcode{\sphinxupquote{p2}} defined remote communicator and rank in \sphinxcode{\sphinxupquote{peer\_comm}} of remote leader (often 0).
\sphinxcode{\sphinxupquote{tag}} Message tag to use in constructing intercommunicator.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Intercomm\_create}}.

\begin{sphinxadmonition}{tip}{Tip:}
Merge

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rk} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Color values: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{color} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rk}\PYG{o}{\PYGZlt{}}\PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{cp}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rleader}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{rk} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{rk} \PYG{o}{=}\PYG{o}{=} \PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mpiComm} \PYG{n}{qqp}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ccc}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{rleader}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{12345}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{aaa} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{ccc}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of processor: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{aaa} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\paragraph{Process}
\label{\detokenize{documentation/parallelization:process}}
In \sphinxstylestrong{FreeFEM} we wrap MPI process by function call \sphinxcode{\sphinxupquote{processor}} which create internal \sphinxstylestrong{FreeFEM} object call \sphinxcode{\sphinxupquote{MPIrank}}.
This mean that do not use \sphinxcode{\sphinxupquote{MPIrank}} in \sphinxstylestrong{FreeFEM} script.

\sphinxcode{\sphinxupquote{processor(int rk)}}: Keep process rank inside object \sphinxcode{\sphinxupquote{MPIrank}}.
Rank is inside \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} and \sphinxcode{\sphinxupquote{processor(mpiComm cc, int rk)}} process rank inside communicator cc.

\sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} and \sphinxcode{\sphinxupquote{processor(mpiComm cc, int rk)}} process rank inside communicator cc.

\sphinxcode{\sphinxupquote{processorblock(int rk)}}: This function is exactlly the same than \sphinxcode{\sphinxupquote{processor(int rk)}} but is use in case of blocking communication.

\sphinxcode{\sphinxupquote{processorblock(int rk, mpiComm cc)}}: This function is exactly the same as \sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} but uses a synchronization point.


\paragraph{Points to Points communicators}
\label{\detokenize{documentation/parallelization:points-to-points-communicators}}
In \sphinxstylestrong{FreeFEM} you can call MPI points to points communications functions.

\sphinxcode{\sphinxupquote{Send(processor(int rk, mpiComm cc), Data D)}} : Blocking send of \sphinxcode{\sphinxupquote{Data D}} to processor of \sphinxcode{\sphinxupquote{rank rk}} inside communicator \sphinxcode{\sphinxupquote{cc}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxcode{\sphinxupquote{Recv(processor(int rk, mpiComm cc), Data D)}}: Receive \sphinxcode{\sphinxupquote{Data D}} from process of rank \sphinxcode{\sphinxupquote{rk}} in communicator \sphinxcode{\sphinxupquote{cc}}.

Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}} and should be the same type than corresponding send.

\sphinxcode{\sphinxupquote{Isend(processor(int rk, mpiComm cc), Data D)}} : Non blocking send of \sphinxcode{\sphinxupquote{Data D}} to processor of \sphinxcode{\sphinxupquote{rank rk}} inside communicator \sphinxcode{\sphinxupquote{cc}}.

Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, \sphinxcode{\sphinxupquote{matrix}}.

\sphinxcode{\sphinxupquote{Recv(processor(int rk, mpiComm cc), Data D)}}: Receive corresponding to send.


\paragraph{Global operations}
\label{\detokenize{documentation/parallelization:global-operations}}
In \sphinxstylestrong{FreeFEM} you can call MPI global communication functions.

\sphinxcode{\sphinxupquote{broadcast(processor(int rk, mpiComm cc), Data D)}}: Process \sphinxcode{\sphinxupquote{rk}} Broadcast \sphinxcode{\sphinxupquote{Data D}} to all process inside \sphinxcode{\sphinxupquote{communicator cc}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxcode{\sphinxupquote{broadcast(processor(int rk), Data D)}}: Process \sphinxcode{\sphinxupquote{rk}} Broadcast \sphinxcode{\sphinxupquote{Data D}} to all process inside \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxcode{\sphinxupquote{mpiAlltoall(Data a, Data b)}}: Sends \sphinxcode{\sphinxupquote{data a}} from all to all processes.
Receive buffer is \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxcode{\sphinxupquote{mpiAlltoall(Data a, Data b, mpiComm cc)}}: Sends \sphinxcode{\sphinxupquote{data a}} from all to all processes. Receive buffer is \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{cc}}.

\sphinxcode{\sphinxupquote{mpiGather(Data a, Data b, processor(mpiComm, int rk)}}: Gathers together values \sphinxcode{\sphinxupquote{Data a}} from a group of processes.
Process of rank \sphinxcode{\sphinxupquote{rk}} get data on communicator \sphinxcode{\sphinxupquote{rk}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Gather}}.

\sphinxcode{\sphinxupquote{mpiAllgather(Data a, Data b)}}: Gathers \sphinxcode{\sphinxupquote{Data a}} from all processes and distribute it to all in \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Allgather}}.

\sphinxcode{\sphinxupquote{mpiAllgather(Data a, Data b, mpiComm cc)}}: Gathers \sphinxcode{\sphinxupquote{Data a}} from all processes and distribute it to all in \sphinxcode{\sphinxupquote{Data b}}.
This is done inside \sphinxcode{\sphinxupquote{communicator cc}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Allgather}}.

\sphinxcode{\sphinxupquote{mpiScatter(Data a,Data b,processor(int rk, mpiComm cc))}}: Sends \sphinxcode{\sphinxupquote{Data a}} from one process whith rank \sphinxcode{\sphinxupquote{rk}} to all other processes in group represented by communicator \sphinxcode{\sphinxupquote{mpiComm cc}}.

\sphinxcode{\sphinxupquote{mpiReduce(Data a, Data b, processor(int rk, mpiComm cc), MPI\_Op op)}} Reduces values \sphinxcode{\sphinxupquote{Data a}} on all processes to a single value \sphinxcode{\sphinxupquote{Data b}} on process of rank \sphinxcode{\sphinxupquote{rk}} and communicator \sphinxcode{\sphinxupquote{cc}}.

Operation use in reduce is: \sphinxcode{\sphinxupquote{MPI\_Op op}} which can be: \sphinxcode{\sphinxupquote{mpiMAX}}, \sphinxcode{\sphinxupquote{mpiMIN}}, \sphinxcode{\sphinxupquote{mpiSUM}}, \sphinxcode{\sphinxupquote{mpiPROD}}, \sphinxcode{\sphinxupquote{mpiLAND}}, \sphinxcode{\sphinxupquote{mpiLOR}}, \sphinxcode{\sphinxupquote{mpiLXOR}}, \sphinxcode{\sphinxupquote{mpiBAND}}, \sphinxcode{\sphinxupquote{mpiBXOR}}, \sphinxcode{\sphinxupquote{mpiMAXLOC}}, \sphinxcode{\sphinxupquote{mpiMINLOC}}.

Note that, for all global operations, only \sphinxcode{\sphinxupquote{int{[}int{]}}} and \sphinxcode{\sphinxupquote{real{[}int{]}}} are data type take in account in \sphinxstylestrong{FreeFEM}.


\subsubsection{HPDDM solvers}
\label{\detokenize{documentation/parallelization:hpddm-solvers}}
Real valued problems (diffusion, heat, elasticity and Stokes) and complex valued problems (Maxwell and Helmholtz) are given in both 2D and 3D.
We detail here the 3D elasticity problem and the 3D time-dependent heat problem.

\begin{sphinxadmonition}{tip}{Tip:}
Elasticity 3D

A three dimensional elasticity problem is defined.
The solver is a domain decomposition method.
Domain decomposition methods are a natural framework for parallel computers.
The scripts run on multicores computers (from 2 to tens of thousands of cores).
Recall that like in any MPI code the number of MPI processes, \sphinxcode{\sphinxupquote{mpisize}}, is given in the command line via the option \sphinxcode{\sphinxupquote{-np}}.
We focus on the script \sphinxcode{\sphinxupquote{Elasticity3D.edp}} but the other scripts have the same structure.
The command line to run the example on four processes with \sphinxcode{\sphinxupquote{ffglut}} visualization is: \sphinxcode{\sphinxupquote{ff-mpirun -np 4 Elasticity3D.edp -glut ffglut}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hpddm}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//load HPDDM plugin}
\PYG{k+kt}{macro} \PYG{n}{partitioner}\PYG{p}{(}\PYG{p}{)}\PYG{n}{metis}\PYG{c+c1}{//metis, scotch, or parmetis}
\PYG{k+kt}{macro} \PYG{n}{dimension}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{3}\PYG{c+c1}{//2D or 3D}
\PYG{k+kt}{macro} \PYG{n}{vectorialfe}\PYG{p}{(}\PYG{p}{)}\PYG{n+nc}{P1}\PYG{c+c1}{//}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{macro\PYGZus{}ddm.idp}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//additional DDM functions}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{i}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]} \PYG{c+c1}{//vector field definition}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{]} \PYG{c+c1}{//vector field initialization}

\PYG{k+kt}{real} \PYG{n}{Sqrt} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Sqrt}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Sqrt}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{Sqrt}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{9000.0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{strain} \PYG{o}{=} \PYG{l+m+mf}{100.0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Young} \PYG{o}{=} \PYG{l+m+mf}{2.0e11}\PYG{p}{;} \PYG{c+c1}{// steel}
\PYG{k+kt}{real} \PYG{n}{poisson} \PYG{o}{=} \PYG{l+m+mf}{0.35}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{p}{[}\PYG{n}{vectorialfe}\PYG{p}{,} \PYG{n}{vectorialfe}\PYG{p}{,} \PYG{n}{vectorialfe}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{string} \PYG{n}{deflation} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deflation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//coarse space construction}
\PYG{k+kt}{int} \PYG{n}{overlap} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}overlap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//geometric overlap between subdomains}
\PYG{k+kt}{int} \PYG{n}{fakeInterface} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}interface}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//interface between subdomains}
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}split}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//refinement factor}
\PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mpiComm} \PYG{n}{comm}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{excluded} \PYG{o}{=} \PYG{n+nf}{splitComm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{topology} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}topology}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exclude} \PYG{o}{=} \PYG{p}{(}\PYG{n}{usedARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}exclude}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Elasticity3D.edp \PYGZhy{} input parameters: refinement factor = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} overlap = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{overlap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{LL} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{meshN} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local finite element space}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{arrayIntersection}\PYG{p}{;} \PYG{c+c1}{//ranks of neighboring subdomains}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{restrictionIntersection}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local\PYGZhy{}to\PYGZhy{}neighbors renumbering}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{D}\PYG{p}{;} \PYG{c+c1}{//partition of unity}
\PYG{p}{\PYGZob{}}
    \PYG{n}{meshN} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{LL}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//global mesh}
    \PYG{n}{build}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{ThGlobal}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{overlap}\PYG{p}{,} \PYG{n}{D}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{excluded}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{tmp} \PYG{o}{=} \PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{poisson}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{Young} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{tmp}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{Young} \PYG{o}{*} \PYG{n}{poisson} \PYG{o}{/} \PYG{p}{(}\PYG{n}{tmp} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{poisson}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{//local right\PYGZhy{}hand side}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Mat}\PYG{p}{;} \PYG{c+c1}{//local operator}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//local weak form}
    \PYG{n}{meshN} \PYG{n}{ThAugmented} \PYG{o}{=} \PYG{n}{Th} \PYG{o}{+} \PYG{n}{ThBorder}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{f} \PYG{o}{*} \PYG{n}{vC}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uB}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uC}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{fespace} \PYG{n+nf}{WhAugmented}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Mat} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{n}{WhAugmented}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsFull} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{R} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{renumbering}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{rhsFull}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{ThBorder} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{dschwarz} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{scaling} \PYG{o}{=} \PYG{n}{D}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{sparams} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}method ras \PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}coarse\PYGZus{}correction balanced \PYGZhy{}hpddm\PYGZus{}variant right \PYGZhy{}hpddm\PYGZus{}verbosity 1 \PYGZhy{}hpddm\PYGZus{}geneo\PYGZus{}nu 10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Opt}\PYG{p}{;} \PYG{c+c1}{//local operator with optimized boundary conditions}
\PYG{n}{dpair} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kp}{solver} \PYG{o}{=} \PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}method}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//optimized Schwarz methods}
        \PYG{k+kt}{fespace} \PYG{n}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{kZero} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}kZero}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Ph} \PYG{n}{transmission} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{kZero} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{n}{lambda} \PYG{o}{+} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{mu}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{vOptimized} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{o}{+} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{transmission} \PYG{o}{*} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uB}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uC}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
            \PYG{p}{;}
        \PYG{n}{Opt} \PYG{o}{=} \PYG{n}{vOptimized}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpisize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{isSetOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}coarse\PYGZus{}correction}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//two\PYGZhy{}level Schwarz methods}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{excluded}\PYG{p}{)}
            \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{varf} \PYG{n}{vPbNoPen} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                      \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{)}
                \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uB}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{uC}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
                \PYG{p}{;}
            \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{noPen} \PYG{o}{=} \PYG{n}{vPbNoPen}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//standard GenEO, no need for RHS \PYGZhy{}\PYGZgt{} deduced from LHS (Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dtn}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{k+kt}{varf} \PYG{n}{vMass} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{massMatrix} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{massMatrix}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo\PYGZhy{}2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//GenEO\PYGZhy{}2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{// Solve}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local solution}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Opt}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//optimized Schwarz methods}
    \PYG{n}{DDM}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{,} \PYG{n}{excluded}\PYG{o}{=}\PYG{n}{excluded}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{,} \PYG{n}{O}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{rhs}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{err}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kp}{err} \PYG{o}{=} \PYG{k+kp}{A} \PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//global matrix\PYGZhy{}vector product}
\PYG{k+kp}{err} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{err}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global residual}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2000.0}\PYG{p}{;}
\PYG{n}{meshN} \PYG{n}{ThMoved} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo} \PYG{o}{=} \PYG{p}{[}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{uB}\PYG{p}{,} \PYG{k+kr}{z} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{uC}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kr}{mpirank}\PYG{p}{;}
\PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{ThMoved}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global moved solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

The macro \sphinxcode{\sphinxupquote{build}} is of particular interest since it handles the data distribution among the \sphinxcode{\sphinxupquote{mpisize}} MPI processes with the following steps:
\begin{itemize}
\item {} 
The initial mesh \sphinxcode{\sphinxupquote{ThGlobal}} is partitioned by process 0 into \sphinxcode{\sphinxupquote{mpisize}} submeshes

\item {} \begin{description}
\item[{The partition is broadcasted to every process \(i\) for 0 \textless{} \(i\) \textless{} \sphinxcode{\sphinxupquote{mpisize}}.}] \leavevmode
From then on, all tasks are parallel.

\end{description}

\item {} \begin{description}
\item[{Each process creates the local submesh \sphinxcode{\sphinxupquote{Th}} (if the refinement factor \sphinxcode{\sphinxupquote{s}} defined via the option \sphinxcode{\sphinxupquote{-split}} is larger than 1, each local edge is splitted into \(s\) subedges, resulting in each element being split into \(s^2\) element in 2D and \(s^3\) elements in 3D) so that the collection of these submeshes is an overlapping domain decomposition of a refined mesh.}] \leavevmode
The number of extra layers added to the initial partition is monitored by the option \sphinxcode{\sphinxupquote{overlap}}.

\end{description}

\item {} 
Connectivity structures are created

\item {} 
\sphinxcode{\sphinxupquote{D}} is the diagonal of the local partition of unity (see {\hyperref[\detokenize{documentation/parallelization:paralleldistributedvectorshpddm}]{\sphinxcrossref{\DUrole{std,std-ref}{Distributed vectors in HPDDM}}}})

\item {} 
\sphinxcode{\sphinxupquote{arrayIntersection}} is the list of neighbors of the current subdomain

\item {} 
For \sphinxcode{\sphinxupquote{j}} in \sphinxcode{\sphinxupquote{arrayIntersection}}, \sphinxcode{\sphinxupquote{restrictionIntersection{[}j{]}}} is the list of the degrees of freedom that belong to the intersection of the current subdomain with its neighbor \sphinxcode{\sphinxupquote{j}}.

\end{itemize}

Then, the variational formulation \sphinxcode{\sphinxupquote{vPb}} of a three dimensional elasticity problem is used to assemble a local matrix \sphinxcode{\sphinxupquote{Mat}}.
This matrix along with \sphinxcode{\sphinxupquote{D}}, \sphinxcode{\sphinxupquote{arrayIntersection}} and \sphinxcode{\sphinxupquote{restrictionIntersection}} are arguments for the constructor of the distributed matrix \sphinxcode{\sphinxupquote{A}}.
This is enough to solve the problem with a one-level additive Schwarz method which can be either ASM or RAS.

For some problems it is interesting to use optimized interface conditions.
When there are many subdomains, it is usually profitable to add a second level to the solver.
Options are set in the sequel of the script:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}method ras \PYGZhy{}hpddm\PYGZus{}schwarz\PYGZus{}coarse\PYGZus{}correction balanced \PYGZhy{}hpddm\PYGZus{}variant right \PYGZhy{}hpddm\PYGZus{}verbosity 1 \PYGZhy{}hpddm\PYGZus{}geneo\PYGZus{}nu 10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In the above line, the first option selects the one-level preconditioner \sphinxcode{\sphinxupquote{ras}} (possible choices are \sphinxcode{\sphinxupquote{ras}}, \sphinxcode{\sphinxupquote{oras}}, \sphinxcode{\sphinxupquote{soras}}, \sphinxcode{\sphinxupquote{asm}}, \sphinxcode{\sphinxupquote{osm}} or \sphinxcode{\sphinxupquote{none}}), the second option selects the correction formula for the second level here \sphinxcode{\sphinxupquote{balanced}} (possible options are \sphinxcode{\sphinxupquote{deflated}}, \sphinxcode{\sphinxupquote{additive}} or \sphinxcode{\sphinxupquote{balanced}}), the third option selects right preconditioning, the fourth one is verbosity level of HPDDM (different from the one of \sphinxstylestrong{FreeFEM}), the fifth one prints all possible options of HPPDM and the last one specifies the number of coarse degrees of freedom per subdomain of the GENEO coarse space.
All other options of \sphinxhref{https://github.com/hpddm/hpddm/blob/master/doc/cheatsheet.pdf}{HPDDM library} can be selected via the \sphinxstylestrong{FreeFEM} function \sphinxcode{\sphinxupquote{set}}.

In the last part of the script, the global linear system is solved by the domain decomposition method defined above.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local solution}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Opt}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//optimized Schwarz methods}
\PYG{n}{DDM}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{,} \PYG{n}{excluded}\PYG{o}{=}\PYG{n}{excluded}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{,} \PYG{n}{O}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{rhs}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Time dependent problem}
\label{\detokenize{documentation/parallelization:time-dependent-problem}}
\begin{sphinxadmonition}{tip}{Tip:}
Heat 3D

A three dimensional heat problem
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t} - \Delta u = 1,\ \ \ u(0,\cdot) := 0 \text{ in }\Omega\,.\end{split}
\end{equation*}
is discretized by an implicit Euler scheme. At each time step \(n\), we shall seek \(u^n(x,y,z)\) satisfying for all \(w\in H^1(\Omega)\):
\begin{equation*}
\begin{split}\int_\Omega \frac{u^n-u^{n-1}}{\delta t}\,w + \nabla u^n \nabla w = \int_\Omega w ,\ \ \ u^0 := 0 \text{ in }\Omega\,.\end{split}
\end{equation*}
so that at each time step a linear system:
\begin{equation*}
\begin{split}(M+dt*K) u^n[] = M*u^{n-1}[] + \delta t*F\end{split}
\end{equation*}
is solved by a domain decomposition method where \(M\) is the mass matrix and \(K\) is the rigidity matrix. In order to save computational efforts, the domain decomposition method preconditioner is built only once and then reused for all subsequent solves with matrix \(A:=M+dt*K\).
The distributed matrix vector product with matrix \(M\) is made through the call to the function \sphinxcode{\sphinxupquote{dmv}} using the partition of unity associated to matrix \(A\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hpddm}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//load HPDDM plugin}
\PYG{k+kt}{macro} \PYG{n}{partitioner}\PYG{p}{(}\PYG{p}{)}\PYG{n}{metis}\PYG{c+c1}{//metis, scotch, or parmetis}
\PYG{k+kt}{macro} \PYG{n}{dimension}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{3}\PYG{c+c1}{//2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{macro\PYGZus{}ddm.idp}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//additional DDM functions}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i} \PYG{c+c1}{//scalar field definition}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i} \PYG{c+c1}{//scalar field initialization}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//three\PYGZhy{}dimensional gradient}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{n+nc}{P2}\PYG{p}{;} \PYG{c+c1}{//finite element space}

\PYG{k+kt}{string} \PYG{n}{deflation} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}deflation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//coarse space construction}
\PYG{k+kt}{int} \PYG{n}{overlap} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}overlap}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//geometric overlap between subdomains}
\PYG{k+kt}{int} \PYG{n}{fakeInterface} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}interface}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//interface between subdomains}
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}split}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//refinement factor}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//time step}
\PYG{k+kt}{int} \PYG{n}{iMax} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}iMax}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//number of iterations}

\PYG{k+kt}{mpiComm} \PYG{n}{comm}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{excluded} \PYG{o}{=} \PYG{n+nf}{splitComm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{topology} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}topology}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{exclude} \PYG{o}{=} \PYG{p}{(}\PYG{n}{usedARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}master\PYGZus{}exclude}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Heat3D.edp \PYGZhy{} input parameters: refinement factor = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} overlap = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{overlap} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{LL} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{meshN} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local finite element space}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{arrayIntersection}\PYG{p}{;} \PYG{c+c1}{//ranks of neighboring subdomains}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{restrictionIntersection}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local\PYGZhy{}to\PYGZhy{}neighbors renumbering}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{D}\PYG{p}{;} \PYG{c+c1}{//partition of unity}
\PYG{p}{\PYGZob{}}
    \PYG{n}{meshN} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}global}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{LL}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//global mesh}
    \PYG{n}{build}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ThBorder}\PYG{p}{,} \PYG{n}{ThGlobal}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{overlap}\PYG{p}{,} \PYG{n}{D}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{excluded}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{// local right\PYGZhy{}hand side}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Mat}\PYG{p}{;} \PYG{c+c1}{//local operator}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{M}\PYG{p}{;} \PYG{c+c1}{//local mass matrix}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//local weak form}
    \PYG{n}{meshN} \PYG{n}{ThAugmented} \PYG{o}{=} \PYG{n}{Th} \PYG{o}{+} \PYG{n}{ThBorder}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
        \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{u} \PYG{o}{*} \PYG{n}{v}
            \PYG{o}{+} \PYG{n}{dt} \PYG{o}{*} \PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{dt} \PYG{o}{*} \PYG{n}{v}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{WhAugmented}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Mat} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{n}{WhAugmented}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsFull} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{R} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{vPbM} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{ThAugmented}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{M} \PYG{o}{=} \PYG{n}{vPbM}\PYG{p}{(}\PYG{n}{WhAugmented}\PYG{p}{,} \PYG{n}{WhAugmented}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{renumbering}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{rhsFull}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{renumbering}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{rhsFull}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{ThBorder} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{dschwarz} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{Mat}\PYG{p}{,} \PYG{n}{arrayIntersection}\PYG{p}{,} \PYG{n}{restrictionIntersection}\PYG{p}{,} \PYG{n}{scaling}\PYG{o}{=}\PYG{n}{D}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Opt}\PYG{p}{;} \PYG{c+c1}{//local operator with optimized boundary conditions}
\PYG{n}{dpair} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kp}{solver} \PYG{o}{=} \PYG{n}{getOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}method}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{k+kp}{solver} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//optimized Schwarz methods}
        \PYG{k+kt}{fespace} \PYG{n}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{kZero} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}kZero}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{10.0}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Ph} \PYG{n}{transmission} \PYG{o}{=} \PYG{n}{kZero}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{vOptimized} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{u} \PYG{o}{*} \PYG{n}{v}
                \PYG{o}{+} \PYG{n}{dt} \PYG{o}{*} \PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{transmission} \PYG{o}{*} \PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
            \PYG{p}{;}
        \PYG{n}{Opt} \PYG{o}{=} \PYG{n}{vOptimized}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpisize} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{isSetOption}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{schwarz\PYGZus{}coarse\PYGZus{}correction}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//two\PYGZhy{}level Schwarz methods}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{excluded}\PYG{p}{)}
            \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{varf} \PYG{n}{vPbNoPen} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
                \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                      \PYG{n}{u} \PYG{o}{*} \PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{dt} \PYG{o}{*} \PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                \PYG{p}{)}
                \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{)}
                \PYG{p}{;}
            \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{noPen} \PYG{o}{=} \PYG{n}{vPbNoPen}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//standard GenEO, no need for RHS \PYGZhy{}\PYGZgt{} deduced from LHS (Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{n}{ret} \PYG{o}{=} \PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dtn}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{varf} \PYG{n}{vMass} \PYG{p}{(}\PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{def}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fakeInterface}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u} \PYG{o}{*} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{massMatrix} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{massMatrix}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{n+nf}{if}\PYG{p}{(}\PYG{n}{deflation} \PYG{o}{=}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{geneo\PYGZhy{}2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{//GenEO\PYGZhy{}2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)}
                \PYG{n}{attachCoarseOperator}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{noPen}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{pattern}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solve}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}reuse\PYGZus{}preconditioner=1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{=} \PYG{k+kp}{init}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local solution}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{iMax}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newRhs}\PYG{p}{(}\PYG{n}{rhs}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dmv}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{newRhs}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//newRhs = M * u[]}
    \PYG{n}{newRhs} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{Opt}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//optimized Schwarz methods}
    \PYG{n}{DDM}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{newRhs}\PYG{p}{,} \PYG{n}{excluded}\PYG{o}{=}\PYG{n}{excluded}\PYG{p}{,} \PYG{n}{ret}\PYG{o}{=}\PYG{n}{ret}\PYG{p}{,} \PYG{n}{O}\PYG{o}{=}\PYG{n}{Opt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{else}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{newRhs}\PYG{p}{;}

    \PYG{n}{plotMPI}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Global solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Distributed vectors in HPDDM}
\label{\detokenize{documentation/parallelization:distributed-vectors-in-hpddm}}\label{\detokenize{documentation/parallelization:paralleldistributedvectorshpddm}}
We give here some hints on the way vectors are distributed among \(np\) processes when using \sphinxstylestrong{FreeFEM} interfaced with HPDDM.
The set of degrees of freedom \({\mathcal N}\) is decomposed into \(np\) overlapping sets \(({\mathcal N}_i)_{1\le i\le np}\).

A MPI-process is in charge of each subset.
Let \(n:=\#{\mathcal N}\) be the number of degrees of freedom of the global finite element space.
Let \(R_i\) denote the restriction operator from \(\R^n\) onto \(\R^{\#{\mathcal N}_i}\).
We have also defined local diagonal matrices \(D_i\in \R^{\#{\mathcal N}_i}\times \R^{\#{\mathcal N}_i}\) so that we have a partition of unity at the algebraic level:
\begin{equation}\label{equation:documentation/parallelization:eq:hpddm:14}
\begin{split}{\mathbf U} = \sum_{i=1}^{np} R_i^T\,D_i\,R_i\,{\mathbf U}\ \ \ \ \forall\ {\mathbf U}\in\R^n\,.\end{split}
\end{equation}
A global vector \({\mathbf U}\in\R^n\) is actually not stored.
Rather, it is stored in a distributed way.
Each process \(i\), \(1\le i\le N\), stores the local vector \({\mathbf U}_i:=R_i {\mathbf U}\in \R^{\#{\mathcal N}_i}\).

It is important to ensure that the result of all linear algebra operators applied to this representation are coherent.

As an example, consider the scalar product of two distributed vectors \({\mathbf U}, {\mathbf V} \in \mathbb{R}^{n}\).
Using the partition of unity \eqref{equation:documentation/parallelization:eq:hpddm:14}, we have:
\begin{equation*}
\begin{split}({\mathbf U}, {\mathbf V}) = \left({\mathbf U}, \sum_{i=1}^{np} R_i^T D_i R_i {\mathbf V}\right) &= \sum_{i=1}^{np} (R_i {\mathbf U}, D_i R_i {\mathbf V})\\
&=\sum_{i=1}^{np} \left({\mathbf U}_i, D_i {\mathbf V}_i\right)\,.\end{split}
\end{equation*}
Thus, the formula for the scalar product is:
\begin{equation*}
\begin{split}({\mathbf U}, {\mathbf V}) = \sum_{i = 1}^{np} (R_i {\mathbf U}, D_i R_i {\mathbf V})\,.\end{split}
\end{equation*}
Local scalar products are performed concurrently.
Thus, the implementation is parallel except for the sum which corresponds to a \sphinxcode{\sphinxupquote{MPI\_Reduce}} call across the \(np\) MPI processes.

Note also that the implementation relies on the knowledge of a partition of unity so that the \sphinxstylestrong{FreeFEM} syntax is \sphinxcode{\sphinxupquote{dscalprod(D, u, v)}}.

A \sphinxcode{\sphinxupquote{axpy}} procedure \(y \leftarrow \alpha\,x+y\) for \(x,y\in \mathbb{R}^{n}\) and \(\alpha\in\R\) is easily implemented concurrently for distributed vectors in the form:
\begin{equation*}
\begin{split}y_i \leftarrow \alpha\,x_i+y_i\,, \forall\ 1\le i \le np\,.\end{split}
\end{equation*}
The matrix vector product is more involved and details are given in the SIAM book \sphinxhref{https://www.ljll.math.upmc.fr/nataf/OT144DoleanJolivetNataf\_full.pdf}{An Introduction to Domain Decomposition Methods: algorithms, theory and parallel implementation} and even more details are given in \sphinxhref{http://jolivet.perso.enseeiht.fr/thesis.pdf}{P. Jolivet’s PhD manuscrit}.


\section{Plugins}
\label{\detokenize{documentation/plugins:plugins}}\label{\detokenize{documentation/plugins::doc}}

\subsection{gsl}
\label{\detokenize{documentation/plugins:gsl}}
The interface with \sphinxcode{\sphinxupquote{gsl}} spline is available in \sphinxstylestrong{FreeFEM}, the seven kind of spline are
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{-1}
\item {} 
\sphinxcode{\sphinxupquote{gslinterpcspline}}: default type of spline

\item {} 
\sphinxcode{\sphinxupquote{gslinterpakima}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterpsteffen}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterplinear}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterppolynomial}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterpcsplineperiodic}}

\item {} 
\sphinxcode{\sphinxupquote{gslinterpakimaperiodic}}

\end{enumerate}

A brief wing example given all the syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gsl}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//data points to define the spline}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//set data points}
   \PYG{k+kt}{real} \PYG{n}{xx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{yy} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{xx}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{;}
   \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{yy}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// GSL splines}
\PYG{k+kt}{gslspline} \PYG{n}{spline1}\PYG{p}{(}\PYG{n+nf}{gslinterpcspline}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline1}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline11}\PYG{p}{(}\PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline11}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline2}\PYG{p}{(}\PYG{n+nf}{gslinterpsteffen}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline2}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline3}\PYG{p}{(}\PYG{n+nf}{gslinterpcspline}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline33}\PYG{p}{(}\PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline3}
\PYG{n}{spline1} \PYG{o}{=} \PYG{n}{spline2}\PYG{p}{;} \PYG{c+c1}{//copy spline2 in spline1}

\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{s1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ds1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{.}\PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the derivative of function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1.d(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ds1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dds1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{.}\PYG{n+nf}{dd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the second derivative of function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1.dd(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dds1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

This can be usefull to build function from data value.

The list of all \sphinxcode{\sphinxupquote{gsl}} functions and the \sphinxstylestrong{FreeFEM} equivalent is available in the \DUrole{xref,std,std-ref}{Language references} (same names without \sphinxcode{\sphinxupquote{\_}}).


\subsection{ffrandom}
\label{\detokenize{documentation/plugins:ffrandom}}
Plugin to linux \sphinxcode{\sphinxupquote{random}} functions.

The range of the random generator is from \(0\) to \((2^{31})-1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffrandom}\PYG{l+s}{\PYGZdq{}}

\PYG{n+nf}{srandomdev}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set a true random seed}
\PYG{c+c1}{//warning: under window this command}
\PYG{c+c1}{//change the seed by randinit(random())) so all}
\PYG{c+c1}{//FreeFEM random function are changed}

\PYG{k+kt}{int} \PYG{n}{maxrang} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{31} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ max range }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxrang} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{srandom}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{mmap / semaphore}
\label{\detokenize{documentation/plugins:mmap-semaphore}}
The idea is just try to use Interprocess communication using POSIX Shared Memory in Linux.

We build a small library \sphinxcode{\sphinxupquote{libff-mmap-semaphore.c}} and \sphinxcode{\sphinxupquote{libff-mmap-semaphore.h}} to easily interface.
\begin{itemize}
\item {} 
mmap - allocate memory, or map files or devices into memory

\item {} 
semaphore - allow processes and threads to synchronize their actions

A semaphore is an integer whose value is never allowed to fall below zero.
Two operations can be performed on semaphores: increment the semaphore value by one (\sphinxcode{\sphinxupquote{sem\_post}}); and decrement the semaphore value by one (\sphinxcode{\sphinxupquote{sem\_wait}}).

If the value of a semaphore is currently zero, then a \sphinxcode{\sphinxupquote{sem\_wait}} operation will block until the value becomes greater than zero.

\end{itemize}

\sphinxstylestrong{The functions of library}

First the \sphinxcode{\sphinxupquote{semaphore}} interface to make synchronization:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{typedef struct FF\_P\_sem *ff\_Psem;}} the pointer to data structure

\item {} 
\sphinxcode{\sphinxupquote{ff\_Psem ffsem\_malloc();}} malloc an empty data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_del(ff\_Psem sem);}} clean and free the pointer

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_destroy(ff\_Psem sem);}} clean, close the data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_init0(ff\_Psem sem);}} make a correct empty of the data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffsem\_init(ff\_Psem sem,const char *nmm, int crea);}} create or use a new semaphore

\item {} 
\sphinxcode{\sphinxupquote{long ffsem\_post(ff\_Psem sem);}} \sphinxcode{\sphinxupquote{nlocked}}, the value of the semaphore is incremented, and all threads which are waiting on the semaphore are awakened

\item {} 
\sphinxcode{\sphinxupquote{long ffsem\_wait(ff\_Psem sem);}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is locked.
When calling \sphinxcode{\sphinxupquote{sem\_wait()}}, if the semaphore’s value is zero, the calling thread will block until the lock is acquired or until the call is interrupted by a signal.

Alternatively, the \sphinxcode{\sphinxupquote{sem\_trywait()}} function will fail if the semaphore is already locked, rather than blocking on the semaphore

\item {} 
\sphinxcode{\sphinxupquote{long ffsem\_trywait(ff\_Psem p);}}

\end{itemize}

Secondly, the \sphinxcode{\sphinxupquote{mmap}} functions:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{typedef struct FF\_P\_mmap *ff\_Pmmap;}} the pointer to data structure

\item {} 
\sphinxcode{\sphinxupquote{ff\_Psem ffmmap\_malloc();}} malloc an empty data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_del(ff\_Pmmap p);}} clean and free the pointer

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_destroy(ff\_Pmmap p);}} clean, close the data structure

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_init0(ff\_Pmmap p);}} make a correct empty of the data structure

\item {} 
\sphinxcode{\sphinxupquote{long ffmmap\_msync(ff\_Pmmap p, long off, long ln);}} call writes modified whole pages back to the filesystem and updates the file modification time.
Only those pages containing \sphinxcode{\sphinxupquote{addr}} and \sphinxcode{\sphinxupquote{len-1}} succeeding locations will be examined.

\item {} 
\sphinxcode{\sphinxupquote{void ffmmap\_init(ff\_Pmmap p, const char *nmm, long len);}} allocate memory, or map files or devices into memory.

\item {} 
\sphinxcode{\sphinxupquote{long ffmmap\_read(ff\_Pmmap p, void *t, size\_t n, size\_t off);}} read \sphinxcode{\sphinxupquote{n}} bytes from the \sphinxcode{\sphinxupquote{mmap}} at memory \sphinxcode{\sphinxupquote{off}} in pointer \sphinxcode{\sphinxupquote{t}}.

\item {} 
\sphinxcode{\sphinxupquote{long ffmmap\_write(ff\_Pmmap p, void *t, size\_t n, size\_t off);}} write \sphinxcode{\sphinxupquote{n}} bytes to the \sphinxcode{\sphinxupquote{mmap}} at memory \sphinxcode{\sphinxupquote{off}} in pointer \sphinxcode{\sphinxupquote{t}}.

\end{itemize}

The \sphinxstylestrong{FreeFEM} corresponding functions:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Pmmap sharedata(filename, 1024);}} new type to store the \sphinxcode{\sphinxupquote{mmap}} informations of name store in string \sphinxcode{\sphinxupquote{filename}} with 1024 is the size the \sphinxcode{\sphinxupquote{sharedata}} zone and file.

\item {} 
\sphinxcode{\sphinxupquote{Psemaphore smff("ff-slave", creat);}} new type to store the semaphore of name \sphinxcode{\sphinxupquote{ff-slave}} where \sphinxcode{\sphinxupquote{creat}} is a boolean to create or use a existing semaphore.

\item {} 
\sphinxcode{\sphinxupquote{Wait(sem)}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is locked.
When calling \sphinxcode{\sphinxupquote{Wait(sem)}}, if the semaphore’s value is zero, the calling thread will block until the lock is acquired or until the call is interrupted by a signal.
Alternatively, the \sphinxcode{\sphinxupquote{trywait(sem)}} function will fail if the semaphore is already locked, rather than blocking on the semaphore.

\item {} 
\sphinxcode{\sphinxupquote{Post(sem)}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is unlocked, the value of the semaphore is incremented, and all threads which are waiting on the semaphore are awakened.

\item {} 
\sphinxcode{\sphinxupquote{Read(sharedata ,offset, data);}} read the variable \sphinxcode{\sphinxupquote{data}} from the place \sphinxcode{\sphinxupquote{offset}} in \sphinxcode{\sphinxupquote{sharedata}} mmap.

\item {} 
\sphinxcode{\sphinxupquote{Write(sharedata, offset, data);}} write the variable \sphinxcode{\sphinxupquote{data}} at the place \sphinxcode{\sphinxupquote{offset}} in \sphinxcode{\sphinxupquote{sharedata}} mmap.

\end{itemize}

The full example:

The \sphinxcode{\sphinxupquote{FFMaster.c}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}libff\PYGZhy{}mmap\PYGZhy{}semaphore.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{n}{ff\PYGZus{}Psem} \PYG{n}{sem\PYGZus{}ff}\PYG{p}{,} \PYG{n}{sem\PYGZus{}c}\PYG{p}{;} \PYG{c+c1}{//the semaphore for mutex}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{debug} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{ff\PYGZus{}Pmmap} \PYG{n}{shd}\PYG{p}{;}
   \PYG{k+kt}{double} \PYG{n}{cff}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{;}
   \PYG{k+kt}{long} \PYG{n}{status}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{debug} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ff\PYGZus{}mmap\PYGZus{}sem\PYGZus{}verb} \PYG{o}{=} \PYG{n}{debug}\PYG{p}{;}

   \PYG{n}{sem\PYGZus{}ff} \PYG{o}{=} \PYG{n}{ffsem\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{sem\PYGZus{}c} \PYG{o}{=} \PYG{n}{ffsem\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{shd} \PYG{o}{=} \PYG{n}{ffmmap\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ffsem\PYGZus{}init}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}slave1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}init}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}master1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}init}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shared\PYGZhy{}data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{status}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{status}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}msync}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{char} \PYG{n}{ff}\PYG{p}{[}\PYG{l+m+mi}{1024}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FreeFem++ FFSlave.edp \PYGZhy{}nw \PYGZhy{}ns \PYGZhy{}v \PYGZpc{}d\PYGZam{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{debug}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{system}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//lauch FF++ in batch no graphics}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cc: before wait}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cc: before wait 0 ff}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter : \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{cff} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{+}\PYG{n}{i}\PYG{p}{;}
      \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cff}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{cff}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffsem\PYGZus{}post}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}

      \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ cc: before wait 2}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffmmap\PYGZus{}read}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rff}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{rff}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter = \PYGZpc{}d rff= \PYGZpc{}f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//end}
   \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{status}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{status}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}post}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End Master }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}del}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}del}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}del}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{FFSlave.edp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}mmap\PYGZhy{}semaphore}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{Psemaphore} \PYG{n}{smff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}slave1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{Psemaphore} \PYG{n+nf}{smc}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}master1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{Pmmap} \PYG{n+nf}{sharedata}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shared\PYGZhy{}data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lab} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{int} \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF status = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cff}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{cff}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Lab}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF: before FF post}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unlock master end init}

\PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF: before FF wait }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{n+nf}{Wait}\PYG{p}{(}\PYG{n}{smc}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait from cint write ok}
   \PYG{n+nf}{Read}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{Read}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ After wait .. FF }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Solve}
   \PYG{n}{Pb}\PYG{p}{;}
   \PYG{n}{rff} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ** FF }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

   \PYG{c+c1}{// Write}
   \PYG{n+nf}{Write}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unlock cc}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait from cint}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ End FreeFEM }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

To test this example of coupling \sphinxcode{\sphinxupquote{C}} program and \sphinxstylestrong{FreeFEM} script:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
cc \PYGZhy{}c libff\PYGZhy{}mmap\PYGZhy{}semaphore.c
cc FFMaster.c \PYGZhy{}o FFMaster libff\PYGZhy{}mmap\PYGZhy{}semaphore.o \PYGZhy{}g \PYGZhy{}pthread
ff\PYGZhy{}c++ \PYGZhy{}auto ff\PYGZhy{}mmap\PYGZhy{}semaphore.cpp
./FFMaster
\end{sphinxVerbatim}

The output:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
len \PYG{l+m}{1024} size \PYG{l+m}{0}
len \PYG{l+m}{1024} size \PYG{l+m}{1024}
FF \PYG{n+nv}{status} \PYG{o}{=} \PYG{l+m}{1}
iter : \PYG{l+m}{0}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{10} \PYG{l+m}{1}
** FF \PYG{l+m}{10} \PYG{l+m}{0}.161797
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{0} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.161797
iter : \PYG{l+m}{1}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{11} \PYG{l+m}{1}
** FF \PYG{l+m}{11} \PYG{l+m}{0}.195774
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{1} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.195774
iter : \PYG{l+m}{2}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{12} \PYG{l+m}{1}
** FF \PYG{l+m}{12} \PYG{l+m}{0}.232987
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{2} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.232987
iter : \PYG{l+m}{3}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{13} \PYG{l+m}{1}
** FF \PYG{l+m}{13} \PYG{l+m}{0}.273436
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{3} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.273436
iter : \PYG{l+m}{4}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{14} \PYG{l+m}{1}
** FF \PYG{l+m}{14} \PYG{l+m}{0}.317121
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{4} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.317121
iter : \PYG{l+m}{5}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{15} \PYG{l+m}{1}
** FF \PYG{l+m}{15} \PYG{l+m}{0}.364042
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{5} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.364042
iter : \PYG{l+m}{6}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{16} \PYG{l+m}{1}
** FF \PYG{l+m}{16} \PYG{l+m}{0}.414199
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{6} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.414199
iter : \PYG{l+m}{7}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{17} \PYG{l+m}{1}
** FF \PYG{l+m}{17} \PYG{l+m}{0}.467592
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{7} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.467592
iter : \PYG{l+m}{8}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{18} \PYG{l+m}{1}
** FF \PYG{l+m}{18} \PYG{l+m}{0}.524221
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{8} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.524221
iter : \PYG{l+m}{9}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{19} \PYG{l+m}{1}
** FF \PYG{l+m}{19} \PYG{l+m}{0}.584086
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{9} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.584086
End Master
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{19} \PYG{l+m}{0}
\end{sphinxVerbatim}


\section{Developers}
\label{\detokenize{documentation/developers:developers}}\label{\detokenize{documentation/developers::doc}}

\subsection{File formats}
\label{\detokenize{documentation/developers:file-formats}}

\subsubsection{Mesh file data structure}
\label{\detokenize{documentation/developers:mesh-file-data-structure}}\label{\detokenize{documentation/developers:meshfiledatastructure}}
The mesh data structure, output of a mesh generation algorithm, refers to the geometric data structure and in some case to another mesh data structure.

In this case, the fields are

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{MeshVersionFormatted} \PYG{n}{0}

\PYG{n}{Dimension} \PYG{n+no}{[DIM]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Vertices}
\PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{X\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{Y\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Z\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{X\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{Y\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Z\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nv}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Edges}
\PYG{n+no}{[Number of edges]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}ne}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}ne}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}ne}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Triangles}
\PYG{n+no}{[Number of triangles]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nt}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Quadrilaterals}
\PYG{n+no}{[Number of Quadrilaterals]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex4\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Vertex4\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{Geometry}
\PYG{n+no}{[File name of geometric support]}\PYG{p}{(}\PYG{n}{char}\PYG{p}{*}\PYG{p}{)}

   \PYG{n}{VertexOnGeometricVertex}
   \PYG{n+no}{[Number of vertex on geometric vertex]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexGeometry\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexGeometry\PYGZus{}nvg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

   \PYG{n}{EdgeOnGeometricEdge}
   \PYG{n+no}{[Number of geometric edge]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Edge\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeGeometry\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Edge\PYGZus{}neg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeGeometry\PYGZus{}neg}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{CrackedEdges}
\PYG{n+no}{[Number of cracked edges]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n}{Edge1\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Edge2\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Edge1\PYGZus{}nce}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{Edge2\PYGZus{}nce}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\end{sphinxVerbatim}

When the current mesh refers to a previous mesh, we have in addition

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{MeshSupportOfVertices}
\PYG{n+no}{[File name of mesh support]}\PYG{p}{(}\PYG{n}{char}\PYG{p}{*}\PYG{p}{)}

   \PYG{n}{VertexOnSupportVertex}
   \PYG{n+no}{[Number of vertex on support vertex]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvsv}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{VertexSupport\PYGZus{}nvsv}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

   \PYG{n}{VertexOnSupportEdge}
   \PYG{n+no}{[Number of vertex on support edge]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvse}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{EdgeSupport\PYGZus{}nvse}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvse}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

   \PYG{n}{VertexOnSupportTriangle}
   \PYG{n+no}{[Number of vertex on support triangle]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}nvst}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

   \PYG{n}{VertexOnSupportQuadrilaterals}
   \PYG{n+no}{[Number of vertex on support quadrilaterals]}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nv}} means the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{ne}} means the number of edges

\item {} 
\sphinxcode{\sphinxupquote{nt}} means the number of triangles

\item {} 
\sphinxcode{\sphinxupquote{nq}} means the number of quadrilaterals

\item {} 
\sphinxcode{\sphinxupquote{nvg}} means the number of vertex on geometric vertex

\item {} 
\sphinxcode{\sphinxupquote{neg}} means the number of edges on geometric edge

\item {} 
\sphinxcode{\sphinxupquote{nce}} means the number of cracked edges

\end{itemize}


\subsubsection{bb file type to Store Solutions}
\label{\detokenize{documentation/developers:bb-file-type-to-store-solutions}}
The file is formatted such that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{2} \PYG{n+no}{[Number of solutions]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{2}

\PYG{n}{U\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}ns\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ns}} means the number of solutions

\item {} 
\sphinxcode{\sphinxupquote{nv}} means the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{U\_i\_j}} is the solution component \sphinxcode{\sphinxupquote{i}} at the vertex \sphinxcode{\sphinxupquote{j}} on the associated mesh.

\end{itemize}


\subsubsection{BB file type to store solutions}
\label{\detokenize{documentation/developers:id1}}
The file is formatted such that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{2} \PYG{n+no}{[Number of solutions]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Type 1]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n+no}{[Type ns]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{2}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}nbv\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}1\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}nbv\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}nbv\PYGZus{}ns}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ns}} means the number of solutions

\item {} 
\sphinxcode{\sphinxupquote{type\_k}} mean the type of solution \sphinxcode{\sphinxupquote{k}}:
\begin{itemize}
\item {} 
1: the solution is scalar (1 value per vertex)

\item {} 
2: the solution is vectorial (2 values per vertex)

\item {} 
3: the solution is a \(2\times 2\) symmetric matrix (3 values per vertex)

\item {} 
4: the solution is a \(2\times 2\) matrix (4 values per vertex)

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nbv}} means the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{U\_i\_j\_k}} is the value of the component \sphinxcode{\sphinxupquote{i}} of the solution
\sphinxcode{\sphinxupquote{k}} at vertex \sphinxcode{\sphinxupquote{j}} on the associated mesh

\end{itemize}


\subsubsection{Metric file}
\label{\detokenize{documentation/developers:metric-file}}
A metric file can be of two types, isotropic or anisotropic.

The isotropic file is such that

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{1}
\PYG{n}{h\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{h\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nv}} is the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{h\_i}} is the wanted mesh size near the vertex \sphinxcode{\sphinxupquote{i}} on associated mesh.

\end{itemize}

The metric is \(\mathcal{M}_i = h_i^{-2}I\) where \(I\) is the identity matrix.

The anisotropic file is such that

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+no}{[Number of vertices]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n}{3}
\PYG{n}{a11\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a21\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a22\PYGZus{}0}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{a11\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a21\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{n}{a22\PYGZus{}nv}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nv}} is the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{a11\_i}}, \sphinxcode{\sphinxupquote{a21\_i}} and \sphinxcode{\sphinxupquote{a22\_i}} represent metric \(\mathcal{M}_i = \left(\begin{array}{cc}a_{11,i} & a_{12,i}\\a{12}_i & a_{22,i}\end{array}\right)\) which define the wanted size in a vicinity of the vertex \sphinxcode{\sphinxupquote{i}} such that \(h\) in direction \(u \in \mathbb{R}^2\) is equal to \(|u|/\sqrt{u\cdot\mathcal{M}_i\, u}\), where \(\cdot\) is the dot product in \(\mathbb{R}^2\), and \(|\cdot|\) is the classical norm.

\end{itemize}


\subsubsection{List of AM\_FMT, AMDBA Meshes}
\label{\detokenize{documentation/developers:list-of-am-fmt-amdba-meshes}}
The mesh is only composed of triangles and can be defined with the help of the following two integers and four arrays:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbt}} the number of triangles

\item {} 
\sphinxcode{\sphinxupquote{nbv}} the number of vertices

\item {} 
\sphinxcode{\sphinxupquote{nu(1:3, 1:nbt)}} an integer array giving the three vertex numbers counterclockwise for each triangle

\item {} 
\sphinxcode{\sphinxupquote{c(1:2, 1:nbv)}} a real array giving tje two coordinates of each vertex

\item {} 
\sphinxcode{\sphinxupquote{refs(1:nbv)}} an integer array giving the reference numbers of the vertices

\item {} 
\sphinxcode{\sphinxupquote{reft(1:nbt)}} an integer array giving the reference numbers of the triangles

\end{itemize}

\sphinxstylestrong{AM\_FMT Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{am\_fmt}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.am\PYGZus{}fmt\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{AM Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{am}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.am\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}unformatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{n}{reft}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{n}{refs}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{AMDBA Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{amdba}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.amdba\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{msh Files}

First, we add the notions of boundary edges
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nbbe}} the number of boundary edge

\item {} 
\sphinxcode{\sphinxupquote{nube(1:2, 1:nbbe)}} an integer array giving the two vertex numbers of boundary edges

\item {} 
\sphinxcode{\sphinxupquote{refbe(1:nbbe)}} an integer array giving the reference numbers of boundary edges

\end{itemize}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{msh}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.msh\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{,} \PYG{n}{nbbe}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{ne}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refbe}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbbe}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{ftq Files}

In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{ftq}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.ftq\PYGZsq{}}\PYG{p}{,}\PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,}\PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{,}\PYG{n}{nbt}\PYG{p}{,}\PYG{n}{nbq}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{k}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{reft}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

where if \sphinxcode{\sphinxupquote{k(j) = 3}} when the element \sphinxcode{\sphinxupquote{j}} is a triangle and \sphinxcode{\sphinxupquote{k(j) = 4}} when the the element \sphinxcode{\sphinxupquote{j}} is a quadrilateral.


\subsubsection{sol and solb files}
\label{\detokenize{documentation/developers:sol-and-solb-files}}
With the keyword \sphinxcode{\sphinxupquote{savesol}}, we can store a scalar functions, a scalar finite element functions, a vector fields, a vector finite element fields, a symmetric tensor and a symmetric finite element tensor.

Such format is used in \sphinxcode{\sphinxupquote{medit}}.

\sphinxstylestrong{Extension file .sol}

The first two lines of the file are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MeshVersionFormatted 0}}

\item {} 
\sphinxcode{\sphinxupquote{Dimension {[}DIM{]}(int)}}

\end{itemize}

The following fields begin with one of the following keyword:
\sphinxcode{\sphinxupquote{SolAtVertices}}, \sphinxcode{\sphinxupquote{SolAtEdges}},
\sphinxcode{\sphinxupquote{SolAtTriangles}}, \sphinxcode{\sphinxupquote{SolAtQuadrilaterals}},
\sphinxcode{\sphinxupquote{SolAtTetrahedra}}, \sphinxcode{\sphinxupquote{SolAtPentahedra}},
\sphinxcode{\sphinxupquote{SolAtHexahedra}}.

In each field, we give then in the next line the number of elements in the solutions (\sphinxcode{\sphinxupquote{SolAtVertices}}: number of vertices, \sphinxcode{\sphinxupquote{SolAtTriangles}}: number of triangles, …).
In other lines, we give the number of solutions, the type of solution (1: scalar, 2: vector, 3: symmetric tensor).
And finally, we give the values of the solutions on the elements.

The file must be ended with the keyword End.

The real element of symmetric tensor :
\begin{equation}\label{equation:documentation/developers:savesol.def.symtensor}
\begin{split}ST^{3d}=\left(
\begin{array}{ccc}
   ST_{xx}^{3d} & ST_{xy}^{3d} & ST_{xz}^{3d}\\
   ST_{yx}^{3d} & ST_{yy}^{3d} & ST_{yz}^{3d} \\
   ST_{zx}^{3d} & ST_{zy}^{3d} & ST_{zz}^{3d}
\end{array}
\right)
\quad
ST^{2d}= \left(
\begin{array}{cc}
   ST_{xx}^{2d} & ST_{xy}^{2d} \\
   ST_{yx}^{2d} & ST_{yy}^{2d}
\end{array}
\right)\end{split}
\end{equation}
stored in the extension \sphinxcode{\sphinxupquote{.sol}} are respectively \(ST_{xx}^{3d}, ST_{yx}^{3d}, ST_{yy}^{3d}, ST_{zx}^{3d}, ST_{zy}^{3d}, ST_{zz}^{3d}\) and \(ST_{xx}^{2d}, ST_{yx}^{2d}, ST_{yy}^{2d}\)

An example of field with the keyword \sphinxcode{\sphinxupquote{SolAtTetrahedra}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{SolAtTetrahedra}
\PYG{n+no}{[Number of tetrahedra]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}
\PYG{n+no}{[Number of solutions]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{n+no}{[Type of solution 1]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n+no}{[Type of soution nt]}\PYG{p}{(}\PYG{n}{int}\PYG{p}{)}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}nrs\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{nrs\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}nrs\PYGZus{}1\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}ns\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{nrs\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}ns\PYGZus{}nt}\PYG{p}{(}\PYG{n}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ns}} is the number of solutions

\item {} 
\sphinxcode{\sphinxupquote{typesol\_k}}, type of the solution number \sphinxcode{\sphinxupquote{k}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{typesol\_k = 1}} the solution \sphinxcode{\sphinxupquote{k}} is scalar

\item {} 
\sphinxcode{\sphinxupquote{typesol\_k = 2}} the solution \sphinxcode{\sphinxupquote{k}} is vectorial

\item {} 
\sphinxcode{\sphinxupquote{typesol\_k = 3}} the solution \sphinxcode{\sphinxupquote{k}} is a symmetric tensor or symmetric matrix

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{nrs\_k}} is the number of real to describe solution \sphinxcode{\sphinxupquote{k}}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{nrs\_k = 1}} if the solution \sphinxcode{\sphinxupquote{k}} is scalar

\item {} 
\sphinxcode{\sphinxupquote{nrs\_k = dim}} if the solution \sphinxcode{\sphinxupquote{k}} is vectorial (\sphinxcode{\sphinxupquote{dim}} is the dimension of the solution)

\item {} 
\sphinxcode{\sphinxupquote{nrs\_k = dim*(dim+1)/2}} if the solution k is a symmetric tensor or symmetric matrix

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{U\_i\_j\_\textasciicircum{}k}} is a real equal to the value of the component \sphinxcode{\sphinxupquote{i}} of the solution \sphinxcode{\sphinxupquote{k}} at tetrahedron \sphinxcode{\sphinxupquote{j}} on the associated mesh

\end{itemize}

The format \sphinxcode{\sphinxupquote{.solb}} is the same as format \sphinxcode{\sphinxupquote{.sol}} but in binary (read/write is faster, storage is less).

A real scalar functions \(f1\), a vector fields \(\mathbf{\Phi} = [\Phi1, \Phi2, \Phi3]\) and a symmetric tensor \(ST^{3d}\) \eqref{equation:documentation/developers:savesol.def.symtensor} at the vertices of the three dimensional mesh \sphinxcode{\sphinxupquote{Th3}} is stored in the file \sphinxcode{\sphinxupquote{f1PhiTh3.sol}} using :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savesol}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f1PhiST3dTh3.sol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{VV3}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \(VV3 = [ST_{xx}^{3d}, ST_{yx}^{3d}, ST_{yy}^{3d}, ST_{zx}^{3d}, ST_{zy}^{3d}, ST_{zz}^{3d}]\).

For a two dimensional mesh \sphinxcode{\sphinxupquote{Th}}, A real scalar functions \(f2\), a vector fields \(\mathbf{\Psi} = [\Psi1, \Psi2]\) and a symmetric tensor \(ST^{2d}\) \eqref{equation:documentation/developers:savesol.def.symtensor} at triangles is stored in the file \sphinxcode{\sphinxupquote{f2PsiST2dTh3.solb}} using :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savesol}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f2PsiST2dTh3.solb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Psi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Psi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{VV2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \(VV2 = [ST_{xx}^{2d}, ST_{yx}^{2d}, ST_{yy}^{2d}]\)

The arguments of \sphinxcode{\sphinxupquote{savesol}} functions are the name of a file, a mesh and solutions.
These arguments must be given in this order.

The parameters of this keyword are :
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{order =}} 0 is the solution is given at the center of gravity of elements.
1 is the solution is given at the vertices of elements.

\end{itemize}

In the file, solutions are stored in this order : scalar solutions, vector solutions and finally symmetric tensor solutions.


\subsection{Adding a new finite element}
\label{\detokenize{documentation/developers:adding-a-new-finite-element}}\label{\detokenize{documentation/developers:developersaddingfiniteelement}}

\subsubsection{Some notations}
\label{\detokenize{documentation/developers:some-notations}}
For a function \(\boldsymbol{f}\) taking value in \(\mathbb{R}^{N},\, N=1,2,\cdots\), we define the finite element approximation \(\Pi_h\boldsymbol{f}\) of \(\boldsymbol{f}\).

Let us denote the number of the degrees of freedom of the finite element by \(NbDoF\).
Then the \(i\)-th base \(\boldsymbol{\omega}^{K}_{i}\) (\(i=0,\cdots,NbDoF-1\)) of the finite element space has the \(j\)-th component \(\mathbf{\omega}^{K}_{ij}\) for \(j=0,\cdots,N-1\).

The operator \(\Pi_{h}\) is called the interpolator of the finite element.

We have the identity \(\boldsymbol{\omega}^{K}_{i} = \Pi_{h} \boldsymbol{\omega}^{K}_{i}\).

Formally, the interpolator \(\Pi_{h}\) is constructed by the following formula:
\begin{equation}\label{equation:documentation/developers:eq-interpo}
\begin{split}\Pi_{h} \boldsymbol{f} = \sum_{k=0}^{\mathtt{kPi}-1} \alpha_k \boldsymbol{f}_{j_{k}}(P_{p_{k}}) \boldsymbol{\omega}^{K}_{i_{k}}\end{split}
\end{equation}
where \(P_{p}\) is a set of \(npPi\) points,

In the formula \eqref{equation:documentation/developers:eq-interpo}, the list \(p_{k},\, j_{k},\, i_{k}\) depend just on the type of finite element (not on the element), but the coefficient \(\alpha_{k}\) can be depending on the element.

\begin{sphinxadmonition}{tip}{Tip:}
Classical scalar Lagrange finite element

With the classical scalar Lagrange finite element, we have \(\mathtt{kPi}=\mathtt{npPi}=\mathtt{NbOfNode}\) and
\begin{itemize}
\item {} 
\(P_{p}\) is the point of the nodal points.

\item {} 
the \(\alpha_k=1\), because we take the value of the function at the point \(P_{k}\).

\item {} 
\(p_{k}=k\) , \(j_{k}=k\) because we have one node per function.

\item {} 
\(j_{k}=0\) because \(N=1\).

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
The Raviart-Thomas finite element
\begin{equation}\label{equation:documentation/developers:eq:RT0-fe}
\begin{split}RT0_{h} = \{ \mathbf{v} \in H(div) / \forall K \in
\mathcal{T}_{h} \quad \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \}\end{split}
\end{equation}
The degrees of freedom are the flux through an edge \(e\) of the mesh, where the flux of the function \(\mathbf{f} : \mathbb{R}^2 \longrightarrow \mathbb{R}^2\) is \(\int_{e} \mathbf{f}.n_{e}\), \(n_{e}\) is the unit normal of edge \(e\) (this implies a orientation of all the edges of the mesh, for example we can use the global numbering of the edge vertices and we just go to small to large number).

To compute this flux, we use a quadrature formula with one point, the middle point of the edge.
Consider a triangle \(T\) with three vertices \((\mathbf{a},\mathbf{b},\mathbf{c})\).

Let denote the vertices numbers by \(i_{a},i_{b},i_{c}\), and define the three edge vectors \(\mathbf{e}^{0},\mathbf{e}^{1},\mathbf{e}^{2}\) by \(sgn(i_{b}-i_{c})(\mathbf{b}-\mathbf{c})\), \(sgn(i_{c}-i_{a})(\mathbf{c}-\mathbf{a})\), \(sgn(i_{a}-i_{b})(\mathbf{a}-\mathbf{b})\).

The three basis functions are:
\begin{equation*}
\begin{split}\boldsymbol{\omega}^{K}_{0}= \frac{sgn(i_{b}-i_{c})}{2|T|}(x-a),\quad \boldsymbol{\omega}^{K}_{1}= \frac{sgn(i_{c}-i_{a})}{2|T|}(x-b),\quad \boldsymbol{\omega}^{K}_{2}= \frac{sgn(i_{a}-i_{b})}{2|T|}(x-c),\end{split}
\end{equation*}
where \(|T|\) is the area of the triangle \(T\).

So we have \(N=2\), \(\mathtt{kPi}=6; \mathtt{npPi}=3;\) and:
\begin{itemize}
\item {} 
\(P_{p} = \left\{\frac{\mathbf{b}+\mathbf{c}}{2}, \frac{\mathbf{a}+\mathbf{c}}{2}, \frac{\mathbf{b}+\mathbf{a}}{2} \right\}\)

\item {} \begin{description}
\item[{\(\alpha_{0}= - \mathbf{e}^{0}_{2}, \alpha_{1}= \mathbf{e}^{0}_{1}\),}] \leavevmode
\(\alpha_{2}= - \mathbf{e}^{1}_{2}, \alpha_{3}= \mathbf{e}^{1}_{1}\),
\(\alpha_{4}= - \mathbf{e}^{2}_{2}, \alpha_{5}= \mathbf{e}^{2}_{1}\) (effectively, the vector
\((-\mathbf{e}^{m}_{2}, \mathbf{e}^{m}_{1})\) is orthogonal to the edge \(\mathbf{e}^{m}= (e^m_{1},e^m_{2})\) with
a length equal to the side of the edge or equal to \(\int_{e^m} 1\)).

\end{description}

\item {} 
\(i_{k}=\{0,0,1,1,2,2\}\),

\item {} 
\(p_{k}=\{0,0,1,1,2,2\}\) , \(j_{k}=\{0,1,0,1,0,1,0,1\}\).

\end{itemize}
\end{sphinxadmonition}


\subsubsection{Which class to add?}
\label{\detokenize{documentation/developers:which-class-to-add}}
Add file \sphinxcode{\sphinxupquote{FE\_ADD.cpp}} in directory \sphinxcode{\sphinxupquote{FreeFem-sources/src/femlib}} for
example first to initialize :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{}include \PYGZdq{}error.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}rgraph.hpp\PYGZdq{}}
\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c}{\PYGZsh{}include \PYGZdq{}RNM.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}fem.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}FESpace.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}AddNewFE.h\PYGZdq{}}

\PYG{n}{namespace} \PYG{n}{Fem2D} \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Then add a class which derive for \sphinxcode{\sphinxupquote{public TypeOfFE}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
class TypeOfFE\PYGZus{}RTortho : public TypeOfFE \PYGZob{} public:
    static int Data[]; //some numbers
    TypeOfFE\PYGZus{}RTortho():
    TypeOfFE(
        0+3+0,  //nb degree of freedom on element
        2,      //dimension N of vectorial FE (1 if scalar FE)
        Data,   //the array data
        1,      //nb of subdivision for plotting
        1,      //nb of sub finite element (generaly 1)
        6,      //number kPi of coef to build the interpolator
        3,      //number npPi of integration point to build interpolator
        0       //an array to store the coef \PYGZbs{}alpha\PYGZus{}k to build interpolator
        //here this array is no constant so we have
        //to rebuilt for each element
    )
    \PYGZob{}
        const R2 Pt[] = \PYGZob{}R2(0.5, 0.5), R2(0.0, 0.5), R2(0.5, 0.0) \PYGZcb{};
        // the set of Point in hat\PYGZob{}K\PYGZcb{}
        for (int p = 0, kk = 0; p \PYGZlt{} 3; p++)\PYGZob{}
            P\PYGZus{}Pi\PYGZus{}h[p] = Pt[p];
            for (int j = 0; j \PYGZlt{} 2; j++)
                pij\PYGZus{}alpha[kk++] = IPJ(p, p, j);
        \PYGZcb{}
    \PYGZcb{} //definition of i\PYGZus{}k, p\PYGZus{}k, j\PYGZus{}k in interpolator

    void FB(const bool *watdd, const Mesh \PYGZam{}Th, const Triangle \PYGZam{}K,
        const R2 \PYGZam{}PHat, RNMK\PYGZus{} \PYGZam{}val) const;

    void Pi\PYGZus{}h\PYGZus{}alpha(const baseFElement \PYGZam{}K, KN\PYGZus{}\PYGZlt{}double\PYGZgt{} \PYGZam{}v) const;
\PYGZcb{} ;
\end{sphinxVerbatim}

where the array data is formed with the concatenation of five array of
size \sphinxcode{\sphinxupquote{NbDoF}} and one array of size \sphinxcode{\sphinxupquote{N}}.

This array is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
int TypeOfFE\PYGZus{}RTortho::Data[] = \PYGZob{}
    //for each df 0, 1, 3:
    3, 4, 5, //the support of the node of the df
    0, 0, 0, //the number of the df on the node
    0, 1, 2, //the node of the df
    0, 0, 0, //the df come from which FE (generally 0)
    0, 1, 2, //which are the df on sub FE
    0, 0
\PYGZcb{}; //for each component j=0, N\PYGZhy{}1 it give the sub FE associated
\end{sphinxVerbatim}

where the support is a number \(0,1,2\) for vertex support, \(3,4,5\) for edge support, and finally \(6\) for element support.

The function to defined the function
\(\boldsymbol{\omega}^{K}_{i}\), this function return the value of all the basics function or this derivatives in array \sphinxcode{\sphinxupquote{val}}, computed at point \sphinxcode{\sphinxupquote{Phat}} on the reference triangle corresponding to point \sphinxcode{\sphinxupquote{R2 P=K(Phat);}} on the current triangle \sphinxcode{\sphinxupquote{K}}.

The index \(i,j,k\) of the array \(val(i,j,k)\) correspond to:
\begin{itemize}
\item {} 
\(i\) is the basic function number on finite element
\(i \in [0,NoF[\)

\item {} 
\(j\) is the value of component \(j \in [0,N[\)

\item {} 
\(k\) is the type of computed value
\(f(P),dx(f)(P), dy(f)(P), ...\ i \in [0,\mathtt{last\_operatortype}[\).

\begin{sphinxadmonition}{note}{Note:}
For optimization, this value is computed only if \sphinxcode{\sphinxupquote{whatd{[}k{]}}} is true, and the numbering is defined with

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{enum} \PYG{n}{operatortype} \PYG{p}{\PYGZob{}}
\PYG{n}{op\PYGZus{}id} \PYG{p}{=} \PYG{n}{0}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dx} \PYG{p}{=} \PYG{n}{1}\PYG{p}{,} \PYG{n}{op\PYGZus{}dy} \PYG{p}{=} \PYG{n}{2}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dxx} \PYG{p}{=} \PYG{n}{3}\PYG{p}{,}\PYG{n}{op\PYGZus{}dyy} \PYG{p}{=} \PYG{n}{4}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dyx} \PYG{p}{=} \PYG{n}{5}\PYG{p}{,}\PYG{n}{op\PYGZus{}dxy} \PYG{p}{=} \PYG{n}{5}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dz} \PYG{p}{=} \PYG{n}{6}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzz} \PYG{p}{=} \PYG{n}{7}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzx} \PYG{p}{=} \PYG{n}{8}\PYG{p}{,} \PYG{n}{op\PYGZus{}dxz} \PYG{p}{=} \PYG{n}{8}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzy} \PYG{p}{=} \PYG{n}{9}\PYG{p}{,} \PYG{n}{op\PYGZus{}dyz} \PYG{p}{=} \PYG{n}{9}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{const} \PYG{n}{int} \PYG{n}{last\PYGZus{}operatortype} \PYG{p}{=} \PYG{n}{10}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\end{itemize}

The shape function:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{void} \PYG{n}{TypeOfFE\PYGZus{}RTortho}\PYG{p}{::}\PYG{n}{FB}\PYG{p}{(}\PYG{n}{const} \PYG{n}{bool} \PYG{p}{*}\PYG{n}{whatd}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Mesh} \PYG{p}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{const} \PYG{n}{Triangle} \PYG{p}{\PYGZam{}} \PYG{n}{K}\PYG{p}{,}
    \PYG{n}{const} \PYG{n}{R2} \PYG{p}{\PYGZam{}}\PYG{n}{PHat}\PYG{p}{,}\PYG{n}{RNMK\PYGZus{}} \PYG{p}{\PYGZam{}}\PYG{n}{val}\PYG{p}{)} \PYG{n}{const}
\PYG{p}{\PYGZob{}}
    \PYG{n}{R2} \PYG{n}{P}\PYG{p}{(}\PYG{n}{K}\PYG{p}{(}\PYG{n}{PHat}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{R2} \PYG{n}{A}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{n}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{B}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{n}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{C}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{n}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{l0} \PYG{p}{=} \PYG{n}{1} \PYG{p}{\PYGZhy{}} \PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{n}{\PYGZhy{}P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{l1} \PYG{p}{=} \PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{l2} \PYG{p}{=} \PYG{n}{P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
    \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{N}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}}\PYG{p}{=} \PYG{n}{3}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{M}\PYG{p}{(}\PYG{p}{)} \PYG{p}{=}\PYG{p}{=} \PYG{n}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{val} \PYG{p}{=} \PYG{n}{0}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a} \PYG{p}{=} \PYG{n}{1}\PYG{p}{.}\PYG{p}{/}\PYG{p}{(}\PYG{n}{2}\PYG{p}{*}\PYG{n}{K}\PYG{p}{.}\PYG{n}{area}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a0} \PYG{p}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{0}\PYG{p}{)} \PYG{p}{*} \PYG{n}{a}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a1} \PYG{p}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{1}\PYG{p}{)} \PYG{p}{*} \PYG{n}{a}\PYG{p}{;}
    \PYG{n+nb}{R }\PYG{n}{a2} \PYG{p}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{2}\PYG{p}{)} \PYG{p}{*} \PYG{n}{a}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}id]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{of} \PYG{n}{the} \PYG{k}{function}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}} \PYG{n}{op\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{RN\PYGZus{}} \PYG{n}{f0}\PYG{p}{(}\PYG{n}{val}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}.\PYGZsq{}}\PYG{p}{,} \PYG{n}{0}\PYG{p}{,}\PYG{n}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{first} \PYG{n}{component}
        \PYG{n}{RN\PYGZus{}} \PYG{n}{f1}\PYG{p}{(}\PYG{n}{val}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}.\PYGZsq{}}\PYG{p}{,} \PYG{n}{1}\PYG{p}{,}\PYG{n}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{second} \PYG{n}{component}
        \PYG{n}{f1}\PYG{p}{[}\PYG{n}{0}\PYG{p}{]} \PYG{p}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{p}{\PYGZhy{}} \PYG{n}{A}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a0}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{n}{0}\PYG{p}{]} \PYG{p}{=} \PYG{p}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{p}{\PYGZhy{}} \PYG{n}{A}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a0}\PYG{p}{;}

        \PYG{n}{f1}\PYG{p}{[}\PYG{n}{1}\PYG{p}{]} \PYG{p}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{p}{\PYGZhy{}} \PYG{n}{B}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a1}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{n}{1}\PYG{p}{]} \PYG{p}{=} \PYG{p}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{p}{\PYGZhy{}} \PYG{n}{B}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a1}\PYG{p}{;}

        \PYG{n}{f1}\PYG{p}{[}\PYG{n}{2}\PYG{p}{]} \PYG{p}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{p}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a2}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{n}{2}\PYG{p}{]} \PYG{p}{=} \PYG{p}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{p}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{p}{*}\PYG{n}{a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}dx]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{value} \PYG{n}{of} \PYG{n}{the} \PYG{n}{dx} \PYG{n}{of} \PYG{k}{function}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}} \PYG{n}{op\PYGZus{}dx}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{0}\PYG{p}{,}\PYG{n}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{p}{=} \PYG{n}{a0}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{1}\PYG{p}{,}\PYG{n}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{p}{=} \PYG{n}{a1}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{2}\PYG{p}{,}\PYG{n}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{p}{=} \PYG{n}{a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}dy]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZgt{}} \PYG{n}{op\PYGZus{}dy}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{0}\PYG{p}{,}\PYG{n}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{p}{=} \PYG{n}{\PYGZhy{}a0}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{1}\PYG{p}{,}\PYG{n}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{p}{=} \PYG{n}{\PYGZhy{}a1}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{n}{2}\PYG{p}{,}\PYG{n}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{p}{=} \PYG{n}{\PYGZhy{}a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{for} \PYG{p}{(}\PYG{n}{int} \PYG{n}{i} \PYG{p}{=} \PYG{n}{op\PYGZus{}dy}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\PYGZlt{}} \PYG{n}{last\PYGZus{}operatortype}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{n+no}{[op\PYGZus{}dx]}\PYG{p}{)}
            \PYG{n}{assert}\PYG{p}{(}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The function to defined the coefficient \(\alpha_{k}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{void} \PYG{n}{TypeOfFE\PYGZus{}RT}\PYG{p}{::}\PYG{n}{Pi\PYGZus{}h\PYGZus{}alpha}\PYG{p}{(}\PYG{n}{const} \PYG{n}{baseFElement} \PYG{p}{\PYGZam{}}\PYG{n}{K}\PYG{p}{,} \PYG{n}{KN\PYGZus{}}\PYG{p}{\PYGZlt{}}\PYG{n}{double}\PYG{p}{\PYGZgt{}} \PYG{p}{\PYGZam{}}\PYG{n}{v}\PYG{p}{)} \PYG{n}{const}
\PYG{p}{\PYGZob{}}
    \PYG{n}{const} \PYG{n}{Triangle} \PYG{p}{\PYGZam{}}\PYG{n}{T}\PYG{p}{(}\PYG{n}{K}\PYG{p}{.}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{n}{int} \PYG{n}{i} \PYG{p}{=} \PYG{n}{0}\PYG{p}{,} \PYG{n}{k} \PYG{p}{=} \PYG{n}{0}\PYG{p}{;} \PYG{n}{i} \PYG{p}{\PYGZlt{}} \PYG{n}{3}\PYG{p}{;} \PYG{n}{i}\PYG{p}{+}\PYG{p}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{R2} \PYG{n}{E}\PYG{p}{(}\PYG{n}{T}\PYG{p}{.}\PYG{n}{Edge}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nb}{R }\PYG{n}{signe} \PYG{p}{=} \PYG{n}{T}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{n}{k}\PYG{p}{+}\PYG{p}{+}\PYG{p}{]} \PYG{p}{=} \PYG{n}{signe}\PYG{p}{*}\PYG{n}{E}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{n}{k}\PYG{p}{+}\PYG{p}{+}\PYG{p}{]} \PYG{p}{=} \PYG{n}{\PYGZhy{}signe}\PYG{p}{*}\PYG{n}{E}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Now , we just need to add a new key work in \sphinxstylestrong{FreeFEM}.

Two way, with static or dynamic link so at the end of the file, we add:

\sphinxstylestrong{With dynamic link} it is very simple (see section {\hyperref[\detokenize{documentation/developers:developersdynamicallink}]{\sphinxcrossref{\DUrole{std,std-ref}{Dynamical link}}}}), just add before the end of \sphinxcode{\sphinxupquote{FEM2d namespace}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
   \PYG{n}{static} \PYG{n}{TypeOfFE\PYGZus{}RTortho} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{;}
   \PYG{n}{static} \PYG{n}{AddNewFE}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RT0Ortho}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{FEM2d} \PYG{n}{namespace}
\end{sphinxVerbatim}

Try with \sphinxcode{\sphinxupquote{./load.link}} command in \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{examples++-load/} and see \sphinxcode{\sphinxupquote{BernardiRaugel.cpp}} or \sphinxcode{\sphinxupquote{Morley.cpp}} new finite element examples.

\sphinxstylestrong{Otherwise with static link} (for expert only), add

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{/}\PYG{p}{/}\PYG{n}{let} \PYG{n}{the} \PYG{n}{2} \PYG{n}{globals} \PYG{n}{variables}
\PYG{n}{static} \PYG{n}{TypeOfFE\PYGZus{}RTortho} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{;}
\PYG{p}{/}\PYG{p}{/}\PYG{n}{the} \PYG{n}{name} \PYG{k}{in} \PYG{n}{freefem}
\PYG{n}{static} \PYG{n}{ListOfTFE} \PYG{n}{typefemRTOrtho}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RT0Ortho}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{\PYGZam{}}\PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{/}\PYG{p}{/}\PYG{n}{link} \PYG{n}{with} \PYG{n}{FreeFEM} \PYG{k}{do} \PYG{n}{not} \PYG{n}{work} \PYG{n}{with} \PYG{n}{static} \PYG{n}{library} \PYG{p}{.}\PYG{n}{a}
\PYG{p}{/}\PYG{p}{/}\PYG{n}{so} \PYG{n}{add} \PYG{n}{a} \PYG{n}{extern} \PYG{n}{name} \PYG{n}{to} \PYG{n}{call} \PYG{k}{in} \PYG{n}{init\PYGZus{}static\PYGZus{}FE}
\PYG{p}{/}\PYG{p}{/}\PYG{p}{(}\PYG{n}{see} \PYG{k}{end} \PYG{n}{of} \PYG{n}{FESpace}\PYG{p}{.}\PYG{n}{cpp}\PYG{p}{)}
\PYG{n}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{/}\PYG{p}{/}\PYG{k}{end}
\PYG{p}{\PYGZcb{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{FEM2d} \PYG{n}{namespace}
\end{sphinxVerbatim}

To inforce in loading of this new finite element, we have to add the two new lines close to the end of files \sphinxcode{\sphinxupquote{src/femlib/FESpace.cpp}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{/}\PYG{p}{/}\PYG{n}{correct} \PYG{n}{problem} \PYG{n}{of} \PYG{n}{static} \PYG{n}{library} \PYG{n}{link} \PYG{n}{with} \PYG{n}{new} \PYG{n}{make} \PYG{n}{file}
\PYG{n}{void} \PYG{n}{init\PYGZus{}static\PYGZus{}FE}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{p}{/}\PYG{p}{/}\PYG{n}{list} \PYG{n}{of} \PYG{n}{other} \PYG{n}{FE} \PYG{n}{file}\PYG{p}{.}\PYG{n}{o}
    \PYG{n}{extern} \PYG{n}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}P2h}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
    \PYG{n}{init\PYGZus{}FE\PYGZus{}P2h}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
    \PYG{n}{extern} \PYG{n}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{new} \PYG{n}{line} \PYG{n}{1}
    \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{new} \PYG{n}{line} \PYG{n}{2}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

and now you have to change the makefile.

First, create a file \sphinxcode{\sphinxupquote{FE\_ADD.cpp}} contening all this code, like in file \sphinxcode{\sphinxupquote{src/femlib/Element\_P2h.cpp}}, after modify the \sphinxcode{\sphinxupquote{Makefile.am}} by adding the name of your file to the variable \sphinxcode{\sphinxupquote{EXTRA\_DIST}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{} Makefile using Automake + Autoconf}
\PYG{c}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c}{\PYGZsh{} Id}

\PYG{c}{\PYGZsh{} This is not compiled as a separate library because its}
\PYG{c}{\PYGZsh{} interconnections with other libraries have not been solved.}

\PYG{n}{EXTRA\PYGZus{}DIST}\PYG{p}{=}\PYG{n}{BamgFreeFem}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{BamgFreeFem}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{CGNL}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{CheckPtr}\PYG{p}{.}\PYG{n+nb}{cpp }       \PYG{p}{\PYGZbs{}}
\PYG{n}{ConjuguedGradrientNL}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{DOperator}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{Drawing}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{Element\PYGZus{}P2h}\PYG{p}{.}\PYG{n+nb}{cpp }     \PYG{p}{\PYGZbs{}}
\PYG{n}{Element\PYGZus{}P3}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{Element\PYGZus{}RT}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{fem3}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{fem}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{fem}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{FESpace}\PYG{p}{.}\PYG{n+nb}{cpp }     \PYG{p}{\PYGZbs{}}
\PYG{n}{FESpace}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{FESpace}\PYG{n}{\PYGZhy{}v0}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{FQuadTree}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{FQuadTree}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{gibbs}\PYG{p}{.}\PYG{n+nb}{cpp }       \PYG{p}{\PYGZbs{}}
\PYG{n}{glutdraw}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{gmres}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{MatriceCreuse}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{MatriceCreuse\PYGZus{}tpl}\PYG{p}{.}\PYG{n}{hpp}          \PYG{p}{\PYGZbs{}}
\PYG{n}{MeshPoint}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{mortar}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{mshptg}\PYG{p}{.}\PYG{n+nb}{cpp }\PYG{n}{QuadratureFormular}\PYG{p}{.}\PYG{n+nb}{cpp }             \PYG{p}{\PYGZbs{}}
\PYG{n}{QuadratureFormular}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RefCounter}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM\PYGZus{}opc}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM\PYGZus{}op}\PYG{p}{.}\PYG{n}{hpp}    \PYG{p}{\PYGZbs{}}
\PYG{n}{RNM\PYGZus{}tpl}\PYG{p}{.}\PYG{n}{hpp}     \PYG{n}{FE\PYGZus{}ADD}\PYG{p}{.}\PYG{n+nb}{cpp}
\end{sphinxVerbatim}

and do in the \sphinxstylestrong{FreeFEM} root directory

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
autoreconf
./reconfigure
make
\end{sphinxVerbatim}

For codewarrior compilation add the file in the project an remove the flag in panal PPC linker FreeFm++ Setting Dead-strip Static Initializition Code Flag.


\subsection{Dynamical link}
\label{\detokenize{documentation/developers:dynamical-link}}\label{\detokenize{documentation/developers:developersdynamicallink}}
Now, it’s possible to add built-in functionnalites in \sphinxstylestrong{FreeFEM} under the three environnents Linux, Windows and MacOS X 10.3 or newer.

It is agood idea to first try the example \sphinxcode{\sphinxupquote{load.edp}} in directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{example++-load}.

You will need to install a \sphinxcode{\sphinxupquote{compiler}} (generally \sphinxcode{\sphinxupquote{g++/gcc}} compiler) to compile your function.
\begin{itemize}
\item {} 
Windows Install the \sphinxcode{\sphinxupquote{cygwin}} environnent or the \sphinxcode{\sphinxupquote{mingw}} one

\item {} 
MacOs Install the developer tools \sphinxcode{\sphinxupquote{Xcode}} on the apple DVD

\item {} 
Linux/Unix Install the correct compiler (\sphinxcode{\sphinxupquote{gcc}} for instance)

\end{itemize}

Now, assume that you are in a shell window (a \sphinxcode{\sphinxupquote{cygwin}} window under Windows) in the directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{example++-load}.

\begin{sphinxadmonition}{note}{Note:}
In the sub directory \sphinxcode{\sphinxupquote{include}}, they are all the \sphinxstylestrong{FreeFEM} include file to make the link with \sphinxstylestrong{FreeFEM}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
If you try to load dynamically a file with command \sphinxcode{\sphinxupquote{load "xxx"}}
- Under Unix (Linux or MacOs), the file \sphinxcode{\sphinxupquote{xxx.so}} will be loaded so it must be either in the search directory of routine \sphinxcode{\sphinxupquote{dlopen}} (see the environment variable \sphinxtitleref{\$LD\_LIBRARY\_PATH}) or in the current directory, and the suffix \sphinxcode{\sphinxupquote{".so"}} or the prefix \sphinxcode{\sphinxupquote{"./"}} is automatically added.
\begin{itemize}
\item {} 
Under Windows, the file \sphinxtitleref{xxx.dll} will be loaded so it must be in the \sphinxtitleref{loadLibary} search directory which includes the directory of the application,

\end{itemize}
\end{sphinxadmonition}

\sphinxstylestrong{Compilation of your module:}

The script \sphinxcode{\sphinxupquote{ff-c++}} compiles and makes the link with \sphinxstylestrong{FreeFEM}, but be careful, the script has no way to known if you try to compile for a pure Windows environment or for a cygwin environment so to build the load module under cygwin you must add the \sphinxcode{\sphinxupquote{-cygwin}} parameter.


\subsubsection{A first example myfunction.cpp}
\label{\detokenize{documentation/developers:a-first-example-myfunction-cpp}}
The following defines a new function call \sphinxcode{\sphinxupquote{myfunction}} with no parameter, but using the \(x,y\) current value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZsh{}include \PYGZlt{}iostream\PYGZgt{}}
\PYG{c}{\PYGZsh{}include \PYGZlt{}cfloat\PYGZgt{}}
\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c}{\PYGZsh{}include \PYGZdq{}error.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}AFunction.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}rgraph.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}RNM.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}fem.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}FESpace.hpp\PYGZdq{}}
\PYG{c}{\PYGZsh{}include \PYGZdq{}MeshPoint.hpp\PYGZdq{}}

\PYG{n}{using} \PYG{n}{namespace} \PYG{n}{Fem2D}\PYG{p}{;}
\PYG{n}{double} \PYG{n}{myfunction}\PYG{p}{(}\PYG{n}{Stack} \PYG{n}{stack}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{/}\PYG{p}{/}\PYG{n}{to} \PYG{n}{get} \PYG{n}{FreeFEM} \PYG{n}{data}
    \PYG{n}{MeshPoint} \PYG{p}{\PYGZam{}}\PYG{n+nb}{mp }\PYG{p}{=} \PYG{p}{*}\PYG{n}{MeshPointStack}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{)}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{the} \PYG{n}{struct} \PYG{n}{to} \PYG{n}{get} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{normal}\PYG{p}{,} \PYG{n}{value}
    \PYG{n}{double} \PYG{n}{x} \PYG{p}{=} \PYG{n}{mp}\PYG{p}{.}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{get} \PYG{n}{the} \PYG{n}{current} \PYG{n}{x} \PYG{n}{value}
    \PYG{n}{double} \PYG{n}{y} \PYG{p}{=} \PYG{n}{mp}\PYG{p}{.}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{p}{/}\PYG{p}{/}\PYG{n}{get} \PYG{n}{the} \PYG{n}{current} \PYG{n}{y} \PYG{n}{value}
    \PYG{p}{/}\PYG{p}{/}\PYG{n}{cout} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x = }\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{n}{x} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ y=}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{n}{y} \PYG{p}{\PYGZlt{}}\PYG{p}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{*}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Now the Problem is to build the link with \sphinxstylestrong{FreeFEM}, to do that we need two classes, one to call the function \sphinxcode{\sphinxupquote{myfunction}}.

All \sphinxstylestrong{FreeFEM} evaluable expression must be a \sphinxcode{\sphinxupquote{C++}} \sphinxcode{\sphinxupquote{struct}}/\sphinxcode{\sphinxupquote{class}} which derivate from \sphinxcode{\sphinxupquote{E\_F0}}.
By default this expression does not depend of the mesh position, but if they derivate from \sphinxcode{\sphinxupquote{E\_F0mps}} the expression depends of the mesh position, and for more details see \sphinxcite{references:hecht2002}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
//A class build the link with FreeFEM
//generaly this class are already in AFunction.hpp
//but unfortunatly, I have no simple function with no parameter
//in FreeFEM depending of the mesh
template\PYGZlt{}class R\PYGZgt{}
class OneOperator0s : public OneOperator \PYGZob{}
    //the class to define and evaluate a new function
    //It must devive from E\PYGZus{}F0 if it is mesh independent
    //or from E\PYGZus{}F0mps if it is mesh dependent
    class E\PYGZus{}F0\PYGZus{}F :public E\PYGZus{}F0mps \PYGZob{}
    public:
        typedef R (*func)(Stack stack);
        func f; //the pointeur to the fnction myfunction
        E\PYGZus{}F0\PYGZus{}F(func ff) : f(ff) \PYGZob{}\PYGZcb{}
        //the operator evaluation in FreeFEM
        AnyType operator()(Stack stack) const \PYGZob{}return SetAny\PYGZlt{}R\PYGZgt{}(f(stack));\PYGZcb{}
    \PYGZcb{};
    typedef R (*func)(Stack);
    func f;
    public:
        //the function which build the FreeFEM byte code
        E\PYGZus{}F0 *code(const basicAC\PYGZus{}F0 \PYGZam{}) const \PYGZob{} return new E\PYGZus{}F0\PYGZus{}F(f); \PYGZcb{}
        //the constructor to say ff is a function without parameter
        //and returning a R
        OneOperator0s(func ff) : OneOperator(map\PYGZus{}type[typeid(R).name()]),f(ff)\PYGZob{}\PYGZcb{}
\PYGZcb{};
\end{sphinxVerbatim}

To finish we must add this new function in \sphinxstylestrong{FreeFEM} table, to do that include :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n}{void} \PYG{n}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
     \PYG{n}{Global}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myfunction}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{new} \PYG{n}{OneOperator0s}\PYG{p}{\PYGZlt{}}\PYG{n}{double}\PYG{p}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{myfunction}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
 \PYG{n}{LOADFUNC}\PYG{p}{(}\PYG{n}{init}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It will be called automatically at load module time.

To compile and link, use the \sphinxcode{\sphinxupquote{ff-c++}} script :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ff}\PYG{n}{\PYGZhy{}c}\PYG{p}{+}\PYG{p}{+} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n+nb}{cpp}
\PYG{n}{g}\PYG{p}{+}\PYG{p}{+} \PYG{n}{\PYGZhy{}c} \PYG{n}{\PYGZhy{}g} \PYG{n}{\PYGZhy{}Iinclude} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n+nb}{cpp}
\PYG{n}{g}\PYG{p}{+}\PYG{p}{+} \PYG{n}{\PYGZhy{}bundle} \PYG{n}{\PYGZhy{}undefined} \PYG{n}{dynamic\PYGZus{}lookup} \PYG{n}{\PYGZhy{}g} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{o} \PYG{n}{\PYGZhy{}o} \PYG{p}{.}\PYG{p}{/}\PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{dylib}
\end{sphinxVerbatim}

To try the simple example under Linux or MacOS, do \sphinxcode{\sphinxupquote{FreeFem++-nw load.edp}}

The output must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZhy{}\PYGZhy{} FreeFem++ v  *.****** \PYG{o}{(}date *** ** *** ****, **:**:** \PYG{o}{(}UTC+0*00\PYG{o}{)}\PYG{o}{)}
 Load: lg\PYGZus{}fem lg\PYGZus{}mesh lg\PYGZus{}mesh3 eigenvalue
    \PYG{l+m}{1} : // Example of dynamic \PYG{k}{function} load
    \PYG{l+m}{2} : // \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
    \PYG{l+m}{3} : // \PYG{n+nv}{\PYGZdl{}Id}\PYGZdl{}
    \PYG{l+m}{4} :
    \PYG{l+m}{5} :  load \PYG{l+s+s2}{\PYGZdq{}myfunction\PYGZdq{}}
    \PYG{l+m}{6} : // dumptable\PYG{o}{(}cout\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{7} :  mesh \PYG{n+nv}{Th}\PYG{o}{=}square\PYG{o}{(}\PYG{l+m}{5},5\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{8} :  fespace Vh\PYG{o}{(}Th,P1\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{9} :  Vh \PYG{n+nv}{uh}\PYG{o}{=} myfunction\PYG{o}{(}\PYG{o}{)}\PYG{p}{;} // warning \PYG{k}{do} not forget \PYG{o}{(}\PYG{o}{)}
   \PYG{l+m}{10} :  cout \PYG{l+s}{\PYGZlt{}\PYGZlt{} uh[].min \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{} uh}\PYG{o}{[}\PYG{o}{]}.max \PYG{l+s}{\PYGZlt{}\PYGZlt{} endl;}
\PYG{l+s}{   11 :  cout \PYGZlt{}\PYGZlt{} \PYGZdq{} test io ( \PYGZdq{} \PYGZlt{}\PYGZlt{} endl}\PYG{p}{;}
   \PYG{l+m}{12} :  testio\PYG{o}{(}\PYG{o}{)}\PYG{p}{;}
   \PYG{l+m}{13} :  cout \PYGZlt{}\PYGZlt{} \PYG{l+s+s2}{\PYGZdq{} ) end test io .. \PYGZdq{}} \PYG{l+s}{\PYGZlt{}\PYGZlt{} endl; sizestack + 1024 =1416  ( 392 )}

\PYG{l+s}{  \PYGZhy{}\PYGZhy{} Square mesh : nb vertices  =36 ,  nb triangles = 50 ,  nb boundary edges 20}
\PYG{l+s}{0 0.841471}
\PYG{l+s}{ test io (}
\PYG{l+s}{ test cout 3.14159}
\PYG{l+s}{ test cout 512}
\PYG{l+s}{ test cerr 3.14159}
\PYG{l+s}{ test cerr 512}
\PYG{l+s}{ ) end} \PYG{n+nb}{test} io ..
times: compile \PYG{l+m}{0}.012854s, execution \PYG{l+m}{0}.000313s,  mpirank:0
 CodeAlloc : nb ptr  \PYG{l+m}{2715},  size :371104 mpirank: \PYG{l+m}{0}
Ok: Normal End
\end{sphinxVerbatim}

Under Windows, launch \sphinxstylestrong{FreeFEM} with the mouse (or ctrl O) on the example.


\subsubsection{Example: Discrete Fast Fourier Transform}
\label{\detokenize{documentation/developers:example-discrete-fast-fourier-transform}}
This will add FFT to \sphinxstylestrong{FreeFEM}, taken from \sphinxhref{http://www.fftw.org/}{FFTW}. To download and install under \sphinxcode{\sphinxupquote{download/include}} just go in \sphinxcode{\sphinxupquote{download/fftw}} and try \sphinxcode{\sphinxupquote{make}}.

The 1D dfft (fast discret fourier transform) for a simple array \(f\) of size \(n\) is defined by the following formula:
\begin{equation*}
\begin{split}\mathtt{dfft}(f,\varepsilon)_{k} = \sum_{j=0}^{n-1} f_i e^{\varepsilon 2\pi i kj/n}\end{split}
\end{equation*}
The 2D DFFT for an array of size \(N=n\times m\) is:
\begin{equation*}
\begin{split}\mathtt{dfft}(f,m,\varepsilon)_{k+nl} = \sum_{j'=0}^{m-1} \sum_{j=0}^{n-1} f_{i+nj} e^{\varepsilon 2\pi i (kj/n+lj'/m) }\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The value \(n\) is given by \(size(f)/m\), and the numbering is row-major order.
\end{sphinxadmonition}

So the classical discrete DFFT is \(\hat{f}=\mathtt{dfft}(f,-1)/\sqrt{n}\) and the reverse dFFT \(f=\mathtt{dfft}(\hat{f},1)/\sqrt{n}\)

\begin{sphinxadmonition}{note}{Note:}
The 2D Laplace operator is
\begin{quote}
\begin{equation*}
\begin{split}f(x,y) = 1/\sqrt{N} \sum_{j'=0}^{m-1} \sum_{j=0}^{n-1} \hat{f}_{i+nj} e^{\varepsilon 2\pi i (x j+ yj') }\end{split}
\end{equation*}
and we have
\begin{equation*}
\begin{split}f_{k+nl} = f(k/n,l/m)\end{split}
\end{equation*}
So
\begin{equation*}
\begin{split}\widehat{\Delta f_{kl}} = -( (2\pi)^2 ( (\tilde{k})^2+(\tilde{l})^2)) \widehat{ f_{kl}} \\\end{split}
\end{equation*}
where \(\tilde{k} = k\) if \(k \leq n/2\) else \(\tilde{k} = k-n\) and \(\tilde{l} = l\) if \(l \leq m/2\) else \(\tilde{l} = l-m\).
\end{quote}

And to have a real function we need all modes to be symmetric around zero, so \(n\) and \(m\) must be odd.
\end{sphinxadmonition}

\sphinxstylestrong{Compile to build a new library}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}c++ dfft.cpp ../download/install/lib/libfftw3.a \PYGZhy{}I../download/install/include
\PYG{n+nb}{export} \PYG{n+nv}{MACOSX\PYGZus{}DEPLOYMENT\PYGZus{}TARGET}\PYG{o}{=}\PYG{l+m}{10}.3
g++ \PYGZhy{}c \PYGZhy{}Iinclude \PYGZhy{}I../download/install/include dfft.cpp
g++ \PYGZhy{}bundle \PYGZhy{}undefined dynamic\PYGZus{}lookup dfft.o \PYGZhy{}o ./dfft.dylib ../download/install/lib/libfftw3.a
\end{sphinxVerbatim}

To test, try {\hyperref[\detokenize{example/developers:examplefft}]{\sphinxcrossref{\DUrole{std,std-ref}{FFT example}}}}.


\subsubsection{Load Module for Dervieux P0-P1 Finite Volume Method}
\label{\detokenize{documentation/developers:load-module-for-dervieux-p0-p1-finite-volume-method}}
The associed edp file is
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/convect\_dervieux.edp}{examples++-load/convect\_dervieux.edp}.

See
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/mat\_dervieux.cpp}{mat\_dervieux.cpp}.


\subsubsection{More on Adding a new finite element}
\label{\detokenize{documentation/developers:more-on-adding-a-new-finite-element}}
First read the {\hyperref[\detokenize{documentation/developers:developersaddingfiniteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Adding a new finite element section}}}}, we add two new finite elements examples in the directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{examples++-load}.


\paragraph{The Bernardi-Raugel Element}
\label{\detokenize{documentation/developers:the-bernardi-raugel-element}}
The Bernardi-Raugel finite element is meant to solve the Navier Stokes equations in \(u,p\) formulation; the velocity space \(P^{br}_K\) is minimal to prove the inf-sup condition with piecewise constant pressure by triangle.

The finite element space \(V_h\) is
\begin{equation*}
\begin{split}V_h= \{u\in H^1(\Omega)^2 ; \quad \forall K \in T_h, u_{|K} \in P^{br}_K \}\end{split}
\end{equation*}
where
\begin{equation*}
\begin{split}P^{br}_K = span \{ \lambda^K_i e_k \}_{i=1,2,3, k= 1,2} \cup \{ \lambda^K_i\lambda^K_{i+1} n^K_{i+2}\}_{i=1,2,3}\end{split}
\end{equation*}
with notation \(4=1, 5=2\) and where \(\lambda^K_i\) are the barycentric coordinates of the triangle \(K\), \((e_k)_{k=1,2}\) the canonical basis of \(\mathbb{R}^2\) and \(n^K_k\) the outer normal of triangle \(K\) opposite to vertex \(k\).

See
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/BernardiRaugel.cpp}{BernardiRaugel.cpp}.

A way to check the finite element

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BernardiRaugel}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Macro}
\PYG{c+c1}{//a macro the compute numerical derivative}
\PYG{k+kt}{macro} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{hx}\PYG{p}{,} \PYG{n}{hy}\PYG{p}{)} \PYG{p}{(} \PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{+}\PYG{n}{hx}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{o}{+}\PYG{n}{hy}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{hx}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n}{hy}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{hx}\PYG{o}{+}\PYG{n}{hy}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{it1} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2BR}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2}\PYG{p}{]}\PYG{p}{;}


\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{it1}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//do the interpolation}

    \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{b1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}9} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//check if the interpolation is correct}

    \PYG{c+c1}{// check the derivative and numerical derivative}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ dx(a1)(x1, y1) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

A real example using this finite element, just a small modification of the Navier-Stokes P2-P1 example, just the begenning is change to

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BernardiRaugel}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{real} \PYG{n}{s0} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2BR}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{up1}\PYG{p}{,} \PYG{n}{up2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

And the plot instruction is also changed because the pressure is constant, and we cannot plot isovalues of peacewise constant functions.


\paragraph{The Morley Element}
\label{\detokenize{documentation/developers:the-morley-element}}
See the example
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/bilapMorley.edp}{bilapMorley.edp}.


\section{ffddm}
\label{\detokenize{documentation/ffddm/index:ffddm}}\label{\detokenize{documentation/ffddm/index::doc}}
In the acronym \sphinxcode{\sphinxupquote{ffddm}}, \sphinxcode{\sphinxupquote{ff}} stands for FreeFEM and \sphinxcode{\sphinxupquote{ddm}} for domain decomposition methods.
The idea behind ffddm is to simplify the use of parallel solvers in FreeFEM: distributed direct methods and domain decomposition methods.

Parallelism is an important issue because, since about 2004, the clock speed of cores stagnates at 2-3 GHz.
The increase in performance is almost entirely due to the increase in the number of cores per processor.
All major processor vendors are producing multicore chips and now every machine is a parallel machine.
Waiting for the next generation machine does not guarantee anymore a better performance of a software.
To keep doubling performance parallelism must double.
It implies a huge effort in algorithmic development.

Thanks to \sphinxcode{\sphinxupquote{ffddm}}, FreeFEM users have access to high-level functionalities for specifying and solving their finite element problems in parallel.
The first task handled by \sphinxcode{\sphinxupquote{ffddm}} is the data distribution among the processors.
This is done via an overlapping domain decomposition and a related distributed linear algebra.
Then, solving a linear system is possible either via an interface to the parallel \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS} solver or by using domain decomposition methods as preconditioners to the GMRES Krylov method.
The \sphinxcode{\sphinxupquote{ffddm}} framework makes it easy to use scalable Schwarz methods enhanced by a coarse space correction built either from a coarse mesh or a \sphinxhref{https://link.springer.com/article/10.1007\%2Fs00211-013-0576-y}{GenEO} (Generalized Eigenvalue in the Overlap) coarse space, see also the book \sphinxhref{http://bookstore.siam.org/ot144/}{An Introduction to Domain Decomposition Methods: algorithms, theory, and parallel implementation}.
State-of-the-art three level methods are also implemented in \sphinxcode{\sphinxupquote{ffddm}}.

The \sphinxcode{\sphinxupquote{ffddm}} framework is entirely written in the FreeFEM language and the ‘idp’ scripts can be found \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/idp}{here} (‘ffddm*.idp’ files).
It makes it also a very good tool for learning and prototyping domain decomposition methods without compromising efficiency.

\sphinxcode{\sphinxupquote{ffddm}} can also act as a wrapper for the \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} library.
HPDDM is an efficient implementation of various domain decomposition methods and a variety of Krylov subspace algorithms, with advanced block and recycling methods for solving sequences of linear systems with multiple right-hand sides: GMRES and Block GMRES, CG, Block CG, and Breakdown-Free Block CG, GCRO-DR and Block GCRO-DR.
For more details on how to use HPDDM within \sphinxcode{\sphinxupquote{ffddm}}, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{the ffddm documentation}}}}.

Getting Started

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Th} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{k+kr}{P} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n}{PVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}
\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{c+c1}{// Step 5: Define the two\PYGZhy{}level GenEO Coarse Space}
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{k+kr}{P} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{c+c1}{// Step 6: Solve the linear system with GMRES}
\PYG{n}{PVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{k+kr}{P}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{Pwritesummary}
\end{sphinxVerbatim}

This example solves a Laplace problem in 2D in parallel with a two-level GenEO domain decomposition method.
To try this example, just copy and paste the script above in a file ‘test.edp’ and run it on 2 cores with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ff}\PYG{o}{\PYGZhy{}}\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{np} \PYG{l+m+mi}{2} \PYG{n}{test}\PYG{p}{.}\PYG{n}{edp} \PYG{o}{\PYGZhy{}}\PYG{n}{glut} \PYG{n}{ffglut}
\end{sphinxVerbatim}


\subsection{Domain Decomposition (DD)}
\label{\detokenize{documentation/ffddm/introddm:domain-decomposition-dd}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroduction}}\label{\detokenize{documentation/ffddm/introddm::doc}}
When the size of a three dimensional problem is large (whatever it means), it is necessary to distribute data among several processors especially for solving linear systems.
A natural way is to do it via domain decomposition.


\subsubsection{Mesh Decomposition}
\label{\detokenize{documentation/ffddm/introddm:mesh-decomposition}}


The starting point is a collection of \(N\) sub-meshes \((Th_i)_{i=1}^N\) that together form a global mesh
\begin{equation*}
\begin{split}Th:= \cup_{i=1}^N Th_i\,.\end{split}
\end{equation*}
These meshes may be overlapping or not. This decomposition induces a natural decomposition of the global finite element space \(Vh\) on \(Th\) into \(N\) local finite element spaces \((Vh_i)_{i=1}^N\) each of them defined on \(Th_i\).

\sphinxstylestrong{Note} By global, we mean that the corresponding structure can be refered to in the code (most often only) by its local values.
In computer science term, it corresponds to a distributed data where each piece of data is stored by a MPI process.


\subsubsection{Distributed Linear Algebra}
\label{\detokenize{documentation/ffddm/introddm:distributed-linear-algebra}}
The domain decomposition induces a natural decomposition of the set of the global degrees of freedom (d.o.f.) \({\mathcal N}\) of the finite element space \(Vh\) into the \(N\) subsets of d.o.f.’s \(({\mathcal N}_i)_{i=1}^N\) each associated with the local finite element space \(Vh_i\).
We have thus
\begin{equation*}
\begin{split}{\mathcal N} = \cup_{i=1}^N {\mathcal N}_i\,,\end{split}
\end{equation*}
but with duplications of some of the d.o.f.’s.

Associated with this decomposition of the set of d.o.f.’s \({\mathcal N}\), a \sphinxstyleemphasis{distributed vector} is a collection of local vectors \(({\mathbf V_i})_{1\le i\le N}\) so that the values on the duplicated d.o.f.’s are the same.

\begin{sphinxadmonition}{note}{Note:}
In mathematical terms, it can be described as follows for a real valued problem.
Let \(R_i\) be the restriction operator from \(\R^{\#{\mathcal N}}\) to \(\R^{\#{\mathcal N}_i}\), where \(\#{\mathcal N}_i\) denotes the number of elements of \({\mathcal N}_i\).
A collection of local vectors \(({\mathbf V}_i)_{1\le i\le N}\in \Pi_{i=1}^N \R^{\#{\mathcal N}_i}\) is a distributed vector iff there exists a global vector \({\mathbf V}\in\R^{\#{\mathcal N}}\) such that for all subset \(1\le i\le N\), we have:
\begin{equation*}
\begin{split}{\mathbf V}_i = R_i\,{\mathbf V}\,.\end{split}
\end{equation*}
We will also say that the collection of local vectors \(({\mathbf V}_i)_{1\le i\le N}\) is consistent. For a complex valued problem, simply replace \(\R\) with \(\C\).
\end{sphinxadmonition}


\subsubsection{Partition of Unity Matrices (POUM)}
\label{\detokenize{documentation/ffddm/introddm:partition-of-unity-matrices-poum}}
Let \((D_i)_{1\le i \le N}\) be square diagonal matrices of size \(\#{\mathcal N}_i\) which form a partition of unity in the sense that:
\begin{equation*}
\begin{split}Id_{} = \sum_{i=1}^N R_i^T\,D_i\,R_i\text{ in }\R^{\#{\mathcal N}\times \#{\mathcal N}} \,.\end{split}
\end{equation*}
For instance if a degree of freedom is shared by \(k\) subdomains defining the corresponding entry of the diagonal matrix \(D\) to be \(1/k\) yields partition of unity matrices.
The matrices \(R_i\) and \(D_i\) are the heart of distributed linear algebra.


\paragraph{Distributed scalar product}
\label{\detokenize{documentation/ffddm/introddm:distributed-scalar-product}}
For two global vectors \({\mathbf U}\) and \({\mathbf V}\) of size \(\#{\mathcal N}\), the formula for the scalar product \({\mathbf V}^T\,{\mathbf U}=({\mathbf U},\,{\mathbf V})\) in terms of their distributed vector counterparts is:
\begin{equation*}
\begin{split}({\mathbf U}, {\mathbf V}) = \left({\mathbf U}, \sum_{i=1}^N R_i^T D_i R_i {\mathbf V}\right) = \sum_{i=1}^N(R_i {\mathbf U}, D_i R_i {\mathbf V})
=\sum_{i=1}^N\left({\mathbf U}_i, D_i {\mathbf V}_i\right)\,.\end{split}
\end{equation*}
Local scalar products are performed concurrently.
Thus, the implementation is parallel except for the sum which corresponds to a MPI\_Reduce call across the \(N\) MPI processes.
Note also that the implementation relies on the knowledge of a partition of unity so that the FreeFEM syntax is \sphinxcode{\sphinxupquote{dscalprod(Di,u,v)}} or equivalently \sphinxcode{\sphinxupquote{pr\#scalprod(u,v)}} where \sphinxcode{\sphinxupquote{pr}} is a user defined prefix that refers to the domain decomposition and thus implicitely also to the partition of unity.


\paragraph{Update}
\label{\detokenize{documentation/ffddm/introddm:update}}\label{\detokenize{documentation/ffddm/introddm:ffddmdocumentationupdate}}
From a collection of local vectors \(({\mathbf U}_i)_{1\le i \le N}\), it is possible ensure consistency of the duplicated data and thus creating a distributed vector \(({\mathbf V}_i)_{1\le i \le N}\) by calling the function \sphinxcode{\sphinxupquote{pr\#update(Ui, TRUE)}} where \sphinxcode{\sphinxupquote{pr}} is a user defined prefix that refers to the domain decomposition.
This function performs the following operation for all \(1\le i \le N\):
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i\, \sum_{j=1}^N R_j^T D_j {\mathbf U}_j\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The implementation corresponds to
\begin{equation*}
\begin{split}{\mathbf V}_i := R_i \sum_{j=1}^N R_j^T D_j {\mathbf U}_j = D_i {\mathbf U}_i + \sum_{j\in \mathcal{O}(i)} R_i\,R_j^T\,D_j {\mathbf U}_j\end{split}
\end{equation*}
where \(\mathcal{O}(i)\) is the set of neighbors of subdomain \(i\).
Therefore, the matrix vector product is computed in three steps: - concurrent computing of \(D_j {\mathbf U}_j\) for all \(1\le j\le N\); - neighbor to neighbor MPI-communications (\(R_i\,R_j^T\)) ; - concurrent sum of neighbor contributions.
\end{sphinxadmonition}


\subsubsection{Distributed Matrix and Vector resulting from a variational formulation}
\label{\detokenize{documentation/ffddm/introddm:distributed-matrix-and-vector-resulting-from-a-variational-formulation}}
The discretization of a variational formulation on the global mesh \(Th\) yields a global matrix \(A\) and a global right hand side \(\mathbf{RHS}\).
Thanks to the sparsity of finite element matrices for partial differential equations and thanks to the overlap between subdomains, the knowledge of the local matrix \(R_i A R_i^T\) on each subdomain \(1\le i\le N\) is sufficient to perform the matrix-vector product \(A\times \mathbf{U}\) for any global vector \(\mathbf{U}\).
Once the problem has been set up by a call to \sphinxcode{\sphinxupquote{ffddmsetupOperator(myprefix, myFEprefix, myVarf)}}, the matrix-vector product is performed by calling the function \sphinxcode{\sphinxupquote{pr\#A(Ui)}} where \sphinxcode{\sphinxupquote{pr}} is a user defined prefix that refers to the problem at hand which itself implicitly refers to the triplet (domain decomposition, finite element, variational formulation).
See more on problem defintion in this {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}} and more on distributed linear algebra in chapter 8 of \sphinxhref{http://bookstore.siam.org/ot144/}{“An Introduction to Domain Decomposition Methods: algorithms, theory and parallel implementation” SIAM 2015}.


\subsubsection{Distributed Linear Solvers}
\label{\detokenize{documentation/ffddm/introddm:distributed-linear-solvers}}
In many cases, we are interested in the solution of the problem in terms of the vector of d.o.f.’s \(\mathbf{X}\) that satisfies:
\begin{equation*}
\begin{split}A\, \mathbf{X} = \mathbf{RHS}\,.\end{split}
\end{equation*}
\sphinxcode{\sphinxupquote{ffddm}} offers two parallel solvers: {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductiondisitributeddirectsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{direct factorization}}}} and {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductionschwarzmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Schwarz}}}} domain decomposition methods.


\paragraph{Distributed Direct Solvers}
\label{\detokenize{documentation/ffddm/introddm:distributed-direct-solvers}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductiondisitributeddirectsolvers}}
In order to benefit from the sparsity of the matrix arising from a finite element discretization of a partial differential equation, a variant of Gauss elimination, the frontal method, that automatically avoids a large number of operations involving zero terms was developed.
A frontal solver builds a \(LU\) or Cholesky decomposition of a sparse matrix given as the assembly of element matrices by eliminating equations only on a subset of elements at a time.
This subset is called the \sphinxstyleemphasis{front} and it is essentially the transition region between the part of the system already finished and the part not touched yet.
These methods are basically sequential since the unknowns are processed the one after another or one front after another.
In order to benefit from multicore processors, a \sphinxhref{https://en.wikipedia.org/wiki/Multifrontal\_method}{multifrontal solver} is an improvement of the frontal solver that uses several independent fronts at the same time.
The fronts can be worked on by different processors, which enables parallel computing. \sphinxcode{\sphinxupquote{ffddm}} provides an interface to the parallel sparse direct solver \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}.


\paragraph{Schwarz methods}
\label{\detokenize{documentation/ffddm/introddm:schwarz-methods}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductionschwarzmethods}}
We consider the solve of the equation \(A\, \mathbf{X} = \mathbf{RHS}\) by a flexible GMRES method preconditioned by domain decomposition methods.


\subparagraph{Restricted Additive Schwarz (RAS)}
\label{\detokenize{documentation/ffddm/introddm:restricted-additive-schwarz-ras}}
The RAS preconditioner reads:
\begin{equation*}
\begin{split}M^{-1}_{RAS} := \sum_{j=1}^N R_j^T D_j (R_j\, A\,R_j^T)^{-1} R_j\,.\end{split}
\end{equation*}
Let \(A_{i}\) denote the local matrix \((R_i\, A\,R_i^T)\).
The application of the operator \(M^{-1}_{RAS}\) to a distributed right hand side \((\mathbf{RHS}_i)_{i=1}^N\) consists in computing:
\begin{equation*}
\begin{split}R_i\, \sum_{j=1}^N R_j^T\,D_j\, A_{j}^{-1}\,\, \mathbf{ RHS}_j
= D_i\, A_{i}^{-1}\, \mathbf{ RHS}_i + \sum_{j\in \mathcal{O}(i)} (R_i\,R_j^T)\,D_j\, A_{j}^{-1}\, \mathbf{ RHS}_j\,.\end{split}
\end{equation*}
This task is performed by first solving concurrently on all subdomains a linear system for \({\mathbf Y}_j\) for all \(1\le j \le N\):
\begin{equation*}
\begin{split}A_{j}\, {\mathbf Y}_j = \mathbf{RHS}_j\,.\end{split}
\end{equation*}
Each local vector \({\mathbf Y}_j\) is weighted by the partition of unity matrix \(D_j\).
Then data transfers between neighboring subdomains implement the \(R_i\,R_j^T\,D_j\,{\mathbf Y}_j\) formula.
The contribution from neighboring subdomains are summed locally. This
pattern is very similar to that of the {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmdocumentationupdate}]{\sphinxcrossref{\DUrole{std,std-ref}{update}}}} procedure.


\subparagraph{Optimized Restricted Additive Schwarz (ORAS)}
\label{\detokenize{documentation/ffddm/introddm:optimized-restricted-additive-schwarz-oras}}
The ORAS preconditioner may be seen as a variant of the RAS preconditioner.
It reads:
\begin{equation*}
\begin{split}M^{-1}_{RAS} := \sum_{j=1}^N R_j^T D_j\, B_j^{-1}\, R_j\,\end{split}
\end{equation*}
where \(B_j\) are local matrices of size \(\#{\mathcal N}_j \times \#{\mathcal N}_j\) for \(1\le j \le N\).
This variant is very useful when dealing with wave propagation phenomena such as Helmholtz problems in acoustics or Maxwell system in the frequency domain for electromagnetism.
Defining \(B_j\) as the discretization of the physical equation with impedance conditions on the boundary of the subdomain has been proved to be a good choice.


\subparagraph{Two level methods}
\label{\detokenize{documentation/ffddm/introddm:two-level-methods}}
The RAS and ORAS methods are called a one-level method in the sense that sub-domains only interact with their direct neighbors. For some problems such as Darcy problems or static elasticity problems and when the number of subdomains is large, such one-level methods may suffer from a slow convergence.
The fix is to add to the preconditioner an auxiliary coarse problem that couples all subdomains at each iteration and is inexpensive to calculate.

In mathematical terms, we first choose  a full rank rectangular matrix  \(Z\in\R^{\#{\mathcal N}\times NC}\) where \(NC \ll \#{\mathcal N}\) denotes the dimension of the coarse space spanned by the columns of \(Z\). We also pick a coarse matrix \(A_C\in \R^{N_C\times N_C}\). A generic one-level method preconditioner \(M_1^{-1}\) is enriched by a solve on the coarse space. The simplest correction formula is additive:
\begin{equation*}
\begin{split}M_2^{-1} := Z \,A_C^{-1}\,Z^T + M_1^{-1}\end{split}
\end{equation*}
Other correction formulas are given in {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}.

We consider two ways to build \(Z\) and thus the coarse space and the coarse problem \(A_C\), see below {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductioncoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Coarse Mesh}}}} and {\hyperref[\detokenize{documentation/ffddm/introddm:ffddmintroductiongeneo}]{\sphinxcrossref{\DUrole{std,std-ref}{GenEO}}}}


\subparagraph{Coarse Mesh}
\label{\detokenize{documentation/ffddm/introddm:coarse-mesh}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductioncoarsemesh}}
A first possibility is to discretize the problem on a coarse mesh, following the same principle as multi-grid methods.
For 3-D problems, a coarsening of the mesh size by a factor 2, reduces by a factor \(2^3=8\) the size of the coarse problem which is then easier to solve by a direct method. Then, \(Z\) is the interpolation matrix from the coarse finite element space to the fine one.


\subparagraph{GenEO}
\label{\detokenize{documentation/ffddm/introddm:geneo}}\label{\detokenize{documentation/ffddm/introddm:ffddmintroductiongeneo}}
For highly heterogeneous or anisotropic problems, two level methods based on coarse meshes might fail and a more sophisticated construction must be used.
A provable robust coarse space called GenEO is built by first solving the following local generalized eigenvalue problem in parallel for each subdomain \(1\le i\le N\), where \(A_i^{\text{Neu}}\) denotes the local matrix resulting from the variational formulation:
\begin{equation*}
\begin{split}D_i A_i D_i\, V_{i,k} = \lambda_{i,k}\, A_i^{\text{Neu}} \,V_{i,k}\end{split}
\end{equation*}
The eigenvectors selected to enter the coarse space correspond to eigenvalues \(\lambda_{i,k} \ge \tau\), where the threshold parameter \(\tau\) is user-defined.
The precise formulas are given in this {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}.
From a mathematical point of view, it has been proved that for a symmetric positive definite matrix \(A\), the spectrum of the preconditioned by the two-level method with a GenEO coarse space lies in the interval \([\displaystyle \frac{1}{1+k_1\,\tau} , k_0 ]\).

\sphinxstylestrong{Note} A heuristic that justifies this construction is as follows.
We first introduce the Additive Schwarz method (ASM) which can be seen as a symmetrized variant of the RAS preconditioner:
\begin{equation*}
\begin{split}M_{ASM}^{-1} := \sum_{j=1}^N R_j^T A_j^{-1} R_j\,.\end{split}
\end{equation*}
It can be proved that the lower bound for the eigenvalue of \(M_{ASM}^{-1}\,A\) is close to zero (which is bad for convergence) whereas the upper bound depends only on the number of neigbors of a subdomain (which is good for convergence).

Second, we also introduce the following preconditioner \(M^{-1}_{NN}\):
\begin{equation*}
\begin{split}M^{-1}_{NN} := \sum_{1\le j\le N} D_i\,(A_j^{\text{Neu}})^{-1} D_j\,.\end{split}
\end{equation*}
We have a very good lower bound for the preconditioned operator \(M^{-1}_{NN}\,A\) that does not depend on the number of subdomains but only on the maximum multiplicity of intersections \(k_1\) (which is good for convergence).
But the upper bound for this preconditioner is very large (which is bad for convergence).

Now, if we compare formulas for \(M^{-1}_{NN}\) and \(M^{-1}_{ASM}\), we may suspect that vectors \(\mathbf{V}_{ik}\) for which \(D_i\, (A_i^{\text{Neu}})^{-1}\,D_i\,\mathbf{V}_{ik}\) and \(A_{i}^{-1}\,\mathbf{V}_{ik}\) have very different values are responsible for the slow convergence and should contribute to the coarse space.
This is a way to interpret the above generalized eigenvalue problem which controls the lower bound of the two-level preconditioned system.


\subsection{ffddm documentation}
\label{\detokenize{documentation/ffddm/documentation:ffddm-documentation}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentation}}\label{\detokenize{documentation/ffddm/documentation::doc}}

\subsubsection{Minimal example}
\label{\detokenize{documentation/ffddm/documentation:minimal-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{3}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{LL} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label} \PYG{o}{=} \PYG{n}{LL}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// global mesh}

\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{// EOM    // three\PYGZhy{}dimensional gradient}

\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{c+c1}{// Domain decomposition}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i}\PYG{c+c1}{// EOM                         // scalar field definition}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i}\PYG{c+c1}{// EOM                        // scalar field initialization}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{Lap} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P1} \PYG{p}{)}

\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,}\PYG{n}{Lap} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{rhsi} \PYG{p}{)}

\PYG{n}{LapVhi} \PYG{n}{def}\PYG{p}{(}\PYG{n}{ui}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Direct solve}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Lapdirectsolve}\PYG{p}{(}\PYG{n}{rhsi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Lapwritesummary}

\PYG{n+nf}{ffddmplot}\PYG{p}{(}\PYG{n}{Lap}\PYG{p}{,}\PYG{n}{ui}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Overlapping mesh decomposition}
\label{\detokenize{documentation/ffddm/documentation:overlapping-mesh-decomposition}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{comm}\PYG{p}{)}
\end{sphinxVerbatim}

decomposes the mesh \sphinxstylestrong{Th} into overlapping submeshes.
The mesh will be distributed over the mpi ranks of communicator \sphinxstylestrong{comm}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below (\# is the concatenation operator).
The way the initial mesh \sphinxstylestrong{Th} is partitioned depends on the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpartitioner}}}}.

The size of the overlap between subdomains (its width in terms of number of mesh elements) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}}.

The level of refinement of the resulting submeshes with respect to the input mesh \sphinxstylestrong{Th} is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}}.

If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} \(\neq 0\), the first {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} mpi ranks of \sphinxstylestrong{comm} will be excluded from the spatial domain decomposition, in order to dedicate them later to the coarse problem (for two-level preconditioners).

The label of the new border of the submeshes (the interface between the subdomains) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminterfacelabel}}}}.

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int pr\#npart}} number of subdomains for this decomposition; should be equal to mpiSize(\sphinxstylestrong{comm}) - {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} * {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}}

\item {} 
\sphinxcode{\sphinxupquote{meshN{[}int{]} pr\#aTh}} array (size \sphinxcode{\sphinxupquote{pr\#npart}}) of local meshes of the subdomains.
In the standard parallel case, only the local mesh for this mpi rank \sphinxcode{\sphinxupquote{pr\#aTh{[}mpiRank(pr\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i.e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1, see below).
In the sequential case, all local meshes are defined.

\item {} 
\sphinxcode{\sphinxupquote{meshN pr\#Thi}} the local mesh of the subdomain for this mpi rank, i. e. \sphinxcode{\sphinxupquote{pr\#aTh{[}mpiRank(pr\#commddm){]}}} in the parallel case -  \sphinxcode{\sphinxupquote{int pr\#numberIntersection}} the number of neighbors for this mpi rank

\item {} 
\sphinxcode{\sphinxupquote{int{[}int{]} pr\#arrayIntersection}} the list of neighbor ranks in \sphinxcode{\sphinxupquote{pr\#commddm}} for this mpi rank

\item {} 
\sphinxcode{\sphinxupquote{int pr\#pCS}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}}

\item {} 
\sphinxcode{\sphinxupquote{int pr\#exclude}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}}

\item {} 
\sphinxcode{\sphinxupquote{int pr\#excluded}} \sphinxstyleemphasis{true} if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} is \sphinxstyleemphasis{true} (\(\neq 0\)) and mpiRank(\sphinxstylestrong{comm}) \textless{} \sphinxcode{\sphinxupquote{pr\#pCS}}.
In this case, this mpi rank will be excluded from the spatial domain decomposition and will only work on the coarse problem.

\item {} 
\sphinxcode{\sphinxupquote{mpiComm pr\#commddm}} mpi communicator for ranks participating in the spatial domain decomposition (ranks 0 to \sphinxcode{\sphinxupquote{pr\#npart}}-1 in \sphinxstylestrong{comm} if \sphinxcode{\sphinxupquote{pr\#exclude}} is \sphinxstyleemphasis{false}, ranks \sphinxcode{\sphinxupquote{pr\#pCS}} to \sphinxcode{\sphinxupquote{pr\#pCS}}+\sphinxcode{\sphinxupquote{pr\#npart}}-1 otherwise)

\item {} 
\sphinxcode{\sphinxupquote{mpiComm pr\#commCS}} mpi communicator for ranks participating in the assembly and resolution of the coarse problem for two-level preconditioners (ranks 0 to \sphinxcode{\sphinxupquote{pr\#pCS}} - 1 in \sphinxstylestrong{comm})

\item {} 
\sphinxcode{\sphinxupquote{mpiComm pr\#commself}} self mpi communicator (this mpi rank only), used for factorizing local matrices

\end{itemize}


\begin{description}
\item[{\sphinxstylestrong{Remark for sequential use} (see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{-seqddm}}}}):}] \leavevmode\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{meshN{[}int{]} pr\#aTh}} array (size \sphinxcode{\sphinxupquote{pr\#npart}}) of local meshes of the subdomains

\end{itemize}

\end{description}




\subsubsection{Local finite element spaces}
\label{\detokenize{documentation/ffddm/documentation:local-finite-element-spaces}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{prmesh}\PYG{p}{,}\PYG{n}{scalar}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n}{Pk}\PYG{p}{)}
\end{sphinxVerbatim}

builds the local finite element spaces and associated distributed operators on top of the mesh decomposition \sphinxstylestrong{prmesh}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} has already been called with prefix \sphinxstylestrong{prmesh} in order to build the mesh decomposition.

The local finite element spaces of type \sphinxstylestrong{Pk} (where \sphinxstylestrong{Pk} is the type of finite element: P1, {[}P2,P2,P1{]}, …) are defined on the local meshes of the subdomains based on the mesh decomposition previously created with prefix \sphinxstylestrong{prmesh}.

\sphinxstylestrong{scalar} determines the type of data for this finite element: \sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex}.

Two macros, \sphinxstylestrong{def} and \sphinxstylestrong{init}, are needed: \sphinxstylestrong{def} specifies how to define a finite element function in the finite element space \sphinxstylestrong{Pk}, and \sphinxstylestrong{init} specifies how to interpolate a scalar function onto the (possibly multiple) components of \sphinxstylestrong{Pk}. Two examples are given below:

For scalar P2 finite elements and complex-valued problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u}\PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u}\PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{mymeshprefix}\PYG{p}{,}\PYG{k+kt}{complex}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{)}
\end{sphinxVerbatim}

For vectorial {[}P2,P2,P1{]} finite elements and real-valued problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]}\PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{]}\PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{mymeshprefix}\PYG{p}{,}\PYG{k+kt}{real}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

In practice, this builds the necessary distributed operators associated to the finite element space: the local partition of unity functions \((D_i)_{i=1,...,N}\) (see \sphinxcode{\sphinxupquote{pr\#Dk}} and \sphinxcode{\sphinxupquote{pr\#Dih}} below) as well as the function \sphinxcode{\sphinxupquote{pr\#update}} (see below) which synchronizes local vectors \((u_i)_{i=1,...,N}\) between neighboring subdomains, performing the equivalent of \(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\) or \(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\) in a distributed parallel environment.

\sphinxcode{\sphinxupquote{pr\#scalprod}} (see below) performs the parallel scalar product for vectors defined on this finite element.

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pr\#prmesh}} macro, saves the parent prefix \sphinxstylestrong{prmesh} of the mesh decomposition

\item {} 
\sphinxcode{\sphinxupquote{pr\#K}} macro, saves the type of data \sphinxstylestrong{scalar} for this finite element space (\sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex})

\item {} 
\sphinxcode{\sphinxupquote{func pr\#fPk}} saves the type of finite element \sphinxstylestrong{Pk}, e.g. \sphinxstyleemphasis{P1, {[}P2,P2,P1{]}, …}

\item {} 
\sphinxcode{\sphinxupquote{fespace pr\#Vhi}} the local finite element space for this mpi rank, defined on the local mesh \sphinxcode{\sphinxupquote{prmesh\#Thi}}

\item {} 
\sphinxcode{\sphinxupquote{int pr\#Ndofglobal}} the total number of degrees of freedom \(n\) for this finite element discretization

\item {} 
\sphinxcode{\sphinxupquote{pr\#mdef}} macro, saves the macro \sphinxstylestrong{def} giving the definition of a finite element function in the finite element space \sphinxstylestrong{Pk}

\item {} 
\sphinxcode{\sphinxupquote{pr\#minit}} macro, saves the macro \sphinxstylestrong{init} specifying how to interpolate a scalar function onto the (possibly multiple) components of a finite element function of \sphinxstylestrong{Pk}.
This is used to create the local partition of unity function in \sphinxcode{\sphinxupquote{pr\#Vhi}}, by interpolating the local P1 partition of unity function onto the components of \sphinxcode{\sphinxupquote{pr\#Vhi}}.
For non Lagrange finite element spaces (e.g. \sphinxstyleemphasis{RT0}, \sphinxstyleemphasis{Edge03d}, …), see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDfespaceEdge}}}}.

\item {} 
\sphinxcode{\sphinxupquote{pr\#K{[}int{]}{[}int{]} pr\#Dk}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of local partition of unity vectors in the subdomains, equivalent to \((D_i)_{i=1,...,N}\).
In the standard parallel case, only the local partition of unity vector for this mpi rank \sphinxcode{\sphinxupquote{pr\#Dk{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all local partition of unity vectors are defined.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#K\textgreater{}{[}int{]} pr\#Dih}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) similar to \sphinxcode{\sphinxupquote{pr\#Dk}} but in \sphinxstyleemphasis{matrix} form, allowing for easier \sphinxstyleemphasis{matrix}-\sphinxstyleemphasis{matrix} multiplications.
\sphinxcode{\sphinxupquote{pr\#Dih{[}i{]}}} is a diagonal matrix, with the diagonal equal to \sphinxcode{\sphinxupquote{pr\#Dk{[}i{]}}}.

\item {} 
\sphinxcode{\sphinxupquote{fespace pr\#Vhglob}} the global finite element space defined on the global mesh \sphinxcode{\sphinxupquote{prmesh\#Thglob}}.
Defined only if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{-noGlob}}}} is not used.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#K\textgreater{}{[}int{]} pr\#Rih}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of restriction matrices from the global finite element space to the local finite element spaces on the local submeshes of the subdomains.
In the standard parallel case, only the restriction matrix for this mpi rank \sphinxcode{\sphinxupquote{pr\#Rih{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all restriction matrices are defined. The restriction matrices \sphinxcode{\sphinxupquote{pr\#Rih}} are defined only if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{-noGlob}}}} is not used.

\item {} 
\sphinxcode{\sphinxupquote{func int pr\#update(scalar{[}int{]} ui, bool scale)}} The function \sphinxcode{\sphinxupquote{pr\#update}} synchronizes the local vector \sphinxstyleemphasis{ui} between subdomains by exchanging the values of \sphinxstyleemphasis{ui} shared with neighboring subdomains (in the overlap region) using point-to-point MPI communications.
If \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{true}, \sphinxstyleemphasis{ui} is multiplied by the local partition of unity beforehand.
This is equivalent to \(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\) when \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{false} and \(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\) when \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{true}.

\item {} 
\sphinxcode{\sphinxupquote{func scalar pr\#scalprod(scalar{[}int{]} ai, scalar{[}int{]} bi)}} The function \sphinxcode{\sphinxupquote{pr\#scalprod}} computes the global scalar product of two vectors whose local restriction to the subdomain of this mpi rank are \sphinxstyleemphasis{ai} and \sphinxstyleemphasis{bi}.
The result is computed as \(\sum_{j=1}^N (D_j a_j, b_j)\).

\end{itemize}




\subsubsection{Define the problem to solve}
\label{\detokenize{documentation/ffddm/documentation:define-the-problem-to-solve}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{prfe}\PYG{p}{,}\PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}

builds the distributed operator associated to the variational problem given by \sphinxstylestrong{Varf}, on top of the distributed finite element space \sphinxstylestrong{prfe}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDfespace}}}} has already been called with prefix \sphinxstylestrong{prfe} in order to define the distributed finite element space.

In practice, this builds the so-called local ‘Dirichlet’ matrices \(A_i = R_i A R_i^T\), the restrictions of the global operator \(A\) to the subdomains (see \sphinxcode{\sphinxupquote{pr\#aRd}}below).
The matrices correspond to the discretization of the bilinear form given by the macro \sphinxstylestrong{Varf}, which represents the abstract variational form of the problem.
These matrices are then used to implement the action of the global operator \(A\) on a local vector (the parallel matrix-vector product with \(A\)), see \sphinxcode{\sphinxupquote{pr\#A}} below.

At this point, we already have the necessary data to be able to solve the problem with a parallel direct solver (\sphinxstyleemphasis{MUMPS}), which is the purpose of the function \sphinxcode{\sphinxupquote{pr\#directsolve}} (see below).
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}} for building the right-hand side.

The macro \sphinxstylestrong{Varf} is required to have three parameters: the name of the variational form, the mesh, and the finite element space.
The variational form given in this ‘abstract’ format will then be used by \sphinxstyleemphasis{ffddm} to assemble the discrete operators by setting the appropriate mesh and finite element space as parameters.
An example is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{myVarf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{myprefix}\PYG{p}{,}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{myVarf}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Remark} In this simple example, the third parameter \sphinxstyleemphasis{VhName} is not used.
However, for more complex cases such as non-linear or time dependent problems where the problem depends on a solution computed at a previous step, it is useful to know for which discrete finite element space the variational form is being used.
See for example TODO

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pr\#prfe}} macro, saves the parent prefix \sphinxstylestrong{prfe} of the finite element space

\item {} 
\sphinxcode{\sphinxupquote{int pr\#verbosity}} the level of verbosity for this problem, initialized with the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmverbosity}}}}

\item {} 
\sphinxcode{\sphinxupquote{pr\#writesummary}} macro, prints a summary of timings for this problem, such as the time spent to assemble local matrices or solve the linear system.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{} pr\#Aglobal}} the global matrix \(A\) corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{Varf} on the global finite element space \sphinxcode{\sphinxupquote{prfe\#Vhglob}}.
Defined only in the sequential case.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{}{[}int{]} pr\#aRd}} array (size \sphinxcode{\sphinxupquote{prfe\#prmesh\#npart}}) of so-called local ‘Dirichlet’ matrices in the subdomains; these are the restrictions of the global operator to the subdomains, equivalent to \(A_i = R_i A R_i^T\) with \(A\) the global matrix corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{Varf} on the global finite element space.
In the standard parallel case, only the local matrix for this mpi rank \sphinxcode{\sphinxupquote{pr\#aRd{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all local matrices are defined.

\item {} 
\sphinxcode{\sphinxupquote{func prfe\#K{[}int{]} pr\#A(prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#A}} computes the parallel matrix-vector product, i.e. the action of the global operator \(A\) on the local vector \(u_i\).
The computation is equivalent to \(R_i (\sum_{j=1}^N R_j^T D_j A_j u_j)\) and is performed in parallel using local matrices \sphinxcode{\sphinxupquote{pr\#aRd}} and the function \sphinxcode{\sphinxupquote{prfe\#update}}.
In the sequential case, the global matrix \sphinxcode{\sphinxupquote{pr\#Aglobal}} is used instead.

\item {} 
\sphinxcode{\sphinxupquote{func prfe\#K{[}int{]} pr\#directsolve(prfe\#K{[}int{]}\& rhsi)}} The function \sphinxcode{\sphinxupquote{pr\#directsolve}} allows to solve the linear system \(A x = b\) in parallel using the parallel direct solver \sphinxstyleemphasis{MUMPS}.
The matrix is given to \sphinxstyleemphasis{MUMPS} in distributed form through the local matrices \sphinxcode{\sphinxupquote{pr\#aRd}}.
The input \sphinxstyleemphasis{rhsi} is given as a distributed vector (\sphinxstyleemphasis{rhsi} is the restriction of the global right-hand side \(b\) to the subdomain of this mpi rank, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}}) and the returned vector is local as well.

\end{itemize}




\bigskip\hrule\bigskip


\def\sphinxLiteralBlockLabel{\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildrhs}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Varfrhs}\PYG{p}{,}\PYG{n}{rhs}\PYG{p}{)}
\end{sphinxVerbatim}

builds the right-hand side associated to the variational form given by \sphinxstylestrong{Varfrhs} for the problem corresponding to prefix \sphinxstylestrong{pr}.
The resulting right-hand side vector \sphinxstylestrong{rhs} corresponds to the discretization of the abstract linear form given by the macro \sphinxstylestrong{Varfrhs} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).

The input vector \sphinxstylestrong{rhs} is resized and contains the resulting local right-hand side \(R_i b\), the restriction of the global right-hand side \(b\) to the subdomain of this mpi rank.
In the sequential case, the global right-hand side vector \(b\) is assembled instead.

An example is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{myVarfrhs}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(}\PYG{n}{myprefix}\PYG{p}{,}\PYG{n}{myVarfrhs}\PYG{p}{,}\PYG{n}{rhsi}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{One level preconditioners}
\label{\detokenize{documentation/ffddm/documentation:one-level-preconditioners}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{VarfPrec}\PYG{p}{)}
\end{sphinxVerbatim}

builds the one level preconditioner for problem \sphinxstylestrong{pr}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} has already been called with prefix \sphinxstylestrong{pr} in order to define the problem to solve.

In practice, this builds and performs the factorization of the local matrices used in the one level preconditioner.
The local matrices depend on the choice of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} and \sphinxstylestrong{VarfPrec}, see \sphinxcode{\sphinxupquote{pr\#aR}}below.

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{string pr\#prec}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}}.
Sets the type of one level preconditioner \(M^{-1}_1\) to be used: “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner).

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{}{[}int{]} pr\#aR}} array (size \sphinxcode{\sphinxupquote{prfe\#prmesh\#npart}}) of local matrices used for the one level preconditioner.
Each mpi rank of the spatial domain decomposition performs the \(LU\) (or \(LDL^T\)) factorization of the local matrix corresponding to its subdomain using the direct solver \sphinxstyleemphasis{MUMPS}.
\begin{itemize}
\item {} 
If \sphinxstylestrong{VarfPrec} is not a previously defined macro (just put \sphinxstyleemphasis{null} for example), the matrices \sphinxcode{\sphinxupquote{pr\#aR}} are set to be equal to the so-called local ‘Dirichlet’ matrices \sphinxcode{\sphinxupquote{pr\#aRd}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}).
This is for the classical ASM preconditioner \(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T A_i^{-1} R_i\) or classical RAS preconditioner \(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i A_i^{-1} R_i\) (it is assumed that {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “asm” or “ras”).

\item {} 
If \sphinxstylestrong{VarfPrec} is a macro, it is assumed that \sphinxstylestrong{VarfPrec} defines an abstract bilinear form (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
\begin{itemize}
\item {} 
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “asm” or “ras”, the matrices \sphinxcode{\sphinxupquote{pr\#aR}} will be assembled as local ‘Dirichlet’ matrices in the same manner as \sphinxcode{\sphinxupquote{pr\#aRd}}, but using the bilinear form defined by \sphinxstylestrong{VarfPrec} instead.
This defines the ASM preconditioner as \(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T {(A_i^{\text{Prec}})}^{-1} R_i\) and the RAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i {(A_i^{\text{Prec}})}^{-1} R_i\), where \(A_i^{\text{Prec}} = R_i A^{\text{Prec}} R_i^T\).

\item {} 
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “oras” or “soras”, the matrices \sphinxcode{\sphinxupquote{pr\#aR}} will correspond to the discretization of the variational form \sphinxstylestrong{VarfPrec} in the subdomains \(\Omega_i\).
In particular, various boundary conditions can be imposed at the interface between subdomains (corresponding to mesh boundary of label {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminterfacelabel}}}} set by the parent call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}}), such as Optimized Robin boundary conditions.
We note the ORAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{ORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} R_i\) and the SORAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{SORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} D_i R_i\).

\end{itemize}

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC1(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC1}} computes the parallel application of the one level preconditioner \(M^{-1}_1\), i.e. the action of \(M^{-1}_1\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(M^{-1}_1\) on a global vector.
The action of the inverse of local matrices \sphinxcode{\sphinxupquote{pr\#aRd}} is computed by forward-backward substitution using their \(LU\) (or \(LDL^T\)) decomposition.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC}} corresponds to the action of the preconditioner \(M^{-1}\) for problem \sphinxstylestrong{pr}.
It coincides with the one level preconditioner \sphinxcode{\sphinxupquote{pr\#PREC1}} after the call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}}.
If a second level is subsequently added (see the next section about {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{Two level preconditioners}}}}), it will then coincide with the two level preconditioner \(M^{-1}_2\) (see \sphinxcode{\sphinxupquote{pr\#PREC2level}}).

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#fGMRES(pr\#prfe\#K{[}int{]}\& x0i, pr\#prfe\#K{[}int{]}\& bi, real eps, int nbiter, string sprec)}} The function \sphinxcode{\sphinxupquote{pr\#fGMRES}} allows to solve the linear system \(A x = b\) in parallel using the flexible GMRES method preconditioned by \(M^{-1}\).
The action of the global operator \(A\) is given by \sphinxcode{\sphinxupquote{pr\#A}}, the action of the preconditioner \(M^{-1}\) is given by \sphinxcode{\sphinxupquote{pr\#PREC}} and the scalar products are computed by \sphinxcode{\sphinxupquote{pr\#scalprod}}.
More details are given in the section {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}]{\sphinxcrossref{\DUrole{std,std-ref}{Solving the linear system}}}}.

\end{itemize}




\subsubsection{Two level preconditioners}
\label{\detokenize{documentation/ffddm/documentation:two-level-preconditioners}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}}
The main ingredient of a two level preconditioner is the so-called ‘coarse space’ matrix \(Z\).

\(Z\) is a rectangular matrix of size \(n \times n_c\), where usually \(n_c \ll n\).

\(Z\) is used to build the ‘coarse space operator’ \(E = Z^T A Z\), a square matrix of size \(n_c \times n_c\).
We can then define the ‘coarse space correction operator’ \(Q = Z E^{-1} Z^T = Z (Z^T A Z)^{-1} Z^T\), which can then be used to enrich the one level preconditioner through a correction formula.
The simplest one is the \sphinxstyleemphasis{additive} coarse correction: \(M^{-1}_2 = M^{-1}_1 + Q\).
See \sphinxcode{\sphinxupquote{pr\#corr}} below for all other available correction formulas.

There are multiple ways to define a relevant coarse space \(Z\) for different classes of problems.
{\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} defines a coarse space correction operator by building the GenEO coarse space, while {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcoarsemeshsetup}}}} builds the coarse space using a coarse mesh.

After a call to either {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} or {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcoarsemeshsetup}}}}, the following variables and functions are set up:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int pr\#ncoarsespace}} the size of the coarse space \(n_c\).

\item {} 
\sphinxcode{\sphinxupquote{string pr\#corr}} initialized with the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcorrection}}}}.
Specifies the type of coarse correction formula to use for the two level preconditioner.
The possible values are:

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{llllll}
\nonumber
    &&\text{"AD"}:&&\textit{Additive}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &&\text{"BNN"}:&&\textit{Balancing Neumann-Neumann}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q) + Q\\
    &&\text{"ADEF1"}:&&\textit{Adapted Deflation Variant 1}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1 (I - A Q) + Q\\
    &&\text{"ADEF2"}:&&\textit{Adapted Deflation Variant 2}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &&\text{"RBNN1"}:&&\textit{Reduced Balancing Variant 1}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q)\\
    &&\text{"RBNN2"}:&&\textit{Reduced Balancing Variant 2}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)}\\
    &&\text{"none"}:&&\textit{no coarse correction}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)}\\
\end{array}\end{split}
\end{equation*}\begin{itemize}
\item {} 
Note that \sphinxstyleemphasis{AD}, \sphinxstyleemphasis{ADEF1} and \sphinxstyleemphasis{RBNN2} only require one application of \(Q\), while \sphinxstyleemphasis{BNN}, \sphinxstyleemphasis{ADEF2} and \sphinxstyleemphasis{RBNN1} require two.
The default coarse correction is \sphinxstyleemphasis{ADEF1}, which is cheaper and generally as robust as \sphinxstyleemphasis{BNN} or \sphinxstyleemphasis{ADEF2}.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#Q(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#Q}} computes the parallel application of the coarse correction operator \(Q\), i.e. the action of \(Q = Z E^{-1} Z^T\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(Q\) on a global vector.
The implementation differs depending on the method used to build the coarse space (with GenEO or using a coarse mesh), but the idea is the same: the action of the transpose of the distributed operator \(Z\) on the distributed vector \(u_i\) is computed in parallel, with the contribution of all subdomains being gathered in a vector of size \(n_c\) in the mpi process of rank 0.
The action of the inverse of the coarse space operator \(E\) is then computed by forward-backward substitution using its \(LU\) (or \(LDL^T\)) decomposition previously computed by the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator.
The result is then sent back to all subdomains to perform the last application of \(Z\) and obtain the resulting local vector in each subdomain.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC2level(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC2level}} computes the parallel application of the two level preconditioner \(M^{-1}_2\), i.e. the action of \(M^{-1}_2\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(M^{-1}_2\) on a global vector.
The two level preconditioner depends on the choice of the coarse correction formula which is determined by \sphinxcode{\sphinxupquote{pr\#corr}}, see above.

\end{itemize}




\paragraph{Building the GenEO coarse space}
\label{\detokenize{documentation/ffddm/documentation:building-the-geneo-coarse-space}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmgeneosetup}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}

This builds the GenEO coarse space for problem \sphinxstylestrong{pr}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} has already been called for prefix \sphinxstylestrong{pr} in order to define the one level preconditioner for problem \sphinxstylestrong{pr}.
The GenEO coarse space is \(Z = (R_i^T D_i V_{i,k})^{i=1,...,N}_{\lambda_{i,k} \ge \tau}\), where \(V_{i,k}\) are eigenvectors corresponding to eigenvalues \(\lambda_{i,k}\) of the following local generalized eigenvalue problem in subdomain \(i\):

\(D_i A_i D_i V_{i,k} = \lambda_{i,k} A_i^{\text{Neu}} V_{i,k}\),

where \(A_i^{\text{Neu}}\) is the local Neumann matrix of subdomain \(i\) (with Neumann boundary conditions at the subdomain interface).

In practice, this builds and factorizes the local Neumann matrices \(A_i^{\text{Neu}}\) corresponding to the abstract bilinear form given by the macro \sphinxstylestrong{Varf} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
In the GenEO method, the abstract bilinear form \sphinxstylestrong{Varf} is assumed to be the same as the one used to define the problem \sphinxstylestrong{pr} through the previous call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}.
The local generalized eigenvalue problem is then solved in each subdomain to find the eigenvectors \(V_{i,k}\) corresponding to the largest eigenvalues \(\lambda_{i,k}\) (see \sphinxcode{\sphinxupquote{pr\#Z}} below).
The number of computed eigenvectors \(\nu\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}}.
The eigenvectors selected to enter \(Z\) correspond to eigenvalues \(\lambda_{i,k}\) larger than \(\tau\), where the threshold parameter \(\tau\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}}.
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} \(= 0\), all {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} eigenvectors are selected.
Finally, the coarse space operator \(E = Z^T A Z\) is assembled and factorized (see \sphinxcode{\sphinxupquote{pr\#E}} below).

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{pr\#prfe\#K{[}int{]}{[}int{]} pr\#Z}} array of local eigenvectors \(Z_{i,k} = D_i V_{i,k}\) obtained by solving the local generalized eigenvalue problem above in the subdomain of this mpi rank using \sphinxstyleemphasis{Arpack}.
The number of computed eigenvectors \(\nu\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}}.
The eigenvectors selected to enter \(Z\) correspond to eigenvalues \(\lambda_{i,k}\) larger than \(\tau\), where the threshold parameter \(\tau\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}}.
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} \(= 0\), all {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} eigenvectors are selected.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#E}} the coarse space operator \(E = Z^T A Z\).
The matrix \sphinxcode{\sphinxupquote{pr\#E}} is assembled in parallel and is factorized by the parallel direct solver \sphinxstyleemphasis{MUMPS} using the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem \sphinxstylestrong{pr}, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} and {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} for more details).

\end{itemize}




\paragraph{Building the coarse space from a coarse mesh}
\label{\detokenize{documentation/ffddm/documentation:building-the-coarse-space-from-a-coarse-mesh}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Thc}\PYG{p}{,}\PYG{n}{VarfEprec}\PYG{p}{,}\PYG{n}{VarfAprec}\PYG{p}{)}
\end{sphinxVerbatim}

builds the coarse space for problem \sphinxstylestrong{pr} from a coarse problem which corresponds to the discretization of a variational form on a coarser mesh \sphinxstylestrong{Thc} of \(\Omega\).
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} has already been called for prefix \sphinxstylestrong{pr} in order to define the one level preconditioner for problem \sphinxstylestrong{pr}.
The abstract variational form for the coarse problem can differ from the original problem \sphinxstylestrong{pr} and is given by macro \sphinxstylestrong{VarfEprec} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
For example, absorption can be added in the preconditioner for wave propagation problems, see examples for Helmholtz and Maxwell equations in the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section.

The coarse space \(Z\) corresponds to the interpolation operator from the coarse finite element space to the original finite element space of the problem.
Thus, the coarse space operator \(E = Z^T A^{\text{Eprec}} Z\) corresponds to the matrix of the problem given by \sphinxstylestrong{VarfEprec} discretized on the coarse mesh \sphinxstylestrong{Thc} and is assembled as such.

Similarly, \sphinxstylestrong{VarfAprec} specifies the global operator involved in multiplicative coarse correction formulas.
For example, \(M^{-1}_{2,\text{ADEF1}} = M^{-1}_1 (I - A^{\text{Aprec}} Q) + Q\) (where \(Q = Z E^{-1} Z^T\)).
\(A^{\text{Aprec}}\) defaults to \(A\) if \sphinxstylestrong{VarfAprec} is not a valid macro (you can put \sphinxstyleemphasis{null} for example).

\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{meshN pr\#ThCoarse}} the coarse mesh \sphinxstylestrong{Thc}

\item {} 
\sphinxcode{\sphinxupquote{fespace pr\#VhCoarse}} the coarse finite element space of type \sphinxcode{\sphinxupquote{pr\#prfe\#fPk}} defined on the coarse mesh \sphinxcode{\sphinxupquote{pr\#ThCoarse}}

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#AglobEprec}} the global matrix \(A^{\text{Aprec}}\) corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{VarfAprec} on the global finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhglob}}.
Defined only in the sequential case.
\sphinxcode{\sphinxupquote{pr\#AglobEprec}} is equal to \sphinxcode{\sphinxupquote{pr\#Aglobal}} if \sphinxstylestrong{VarfAprec} is not a valid macro.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#aRdEprec}} the local ‘Dirichlet’ matrix corresponding to \sphinxstylestrong{VarfAprec}; it is the local restriction of the global operator \(A^{\text{Aprec}}\) to the subdomain, equivalent to \(A^{\text{Aprec}}_i = R_i A^{\text{Aprec}} R_i^T\) with \(A^{\text{Aprec}}\) the global matrix corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{VarfAprec} on the global finite element space.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 0.
\sphinxcode{\sphinxupquote{pr\#aRdEprec}} is equal to \sphinxcode{\sphinxupquote{pr\#aRd{[}mpiRank(prmesh\#commddm){]}}} if \sphinxstylestrong{VarfAprec} is not a valid macro.

\item {} 
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#AEprec(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#AEprec}} computes the parallel matrix-vector product, i.e. the action of the global operator \(A^{\text{Aprec}}\) on the local vector \(u_i\).
The computation is equivalent to \(R_i (\sum_{j=1}^N R_j^T D_j A^{\text{Aprec}}_j u_j)\) and is performed in parallel using local matrices \sphinxcode{\sphinxupquote{pr\#aRdEprec}} and the function \sphinxcode{\sphinxupquote{pr\#prfe\#update}}.
In the sequential case, the global matrix \sphinxcode{\sphinxupquote{pr\#AglobEprec}} is used instead.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ZCM}} the interpolation operator \(Z\) from the coarse finite element space \sphinxcode{\sphinxupquote{pr\#VhCoarse}} to the global finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhglob}}.
Defined only in the sequential case.

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ZCMi}} the local interpolation operator \(Z_i\) from the coarse finite element space \sphinxcode{\sphinxupquote{pr\#VhCoarse}} to the local finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhi}}.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 0.
\sphinxcode{\sphinxupquote{pr\#ZCMi}} is used for the parallel application of \(Z\) and \(Z^T\).

\item {} 
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ECM}} the coarse space operator \(E = Z^T A^{\text{Eprec}} Z\).
The matrix \sphinxcode{\sphinxupquote{pr\#ECM}} is assembled by discretizing the variational form given by \sphinxstylestrong{VarfEprec} on the coarse mesh and factorized by the parallel direct solver \sphinxstyleemphasis{MUMPS} using the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem \sphinxstylestrong{pr}, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} and {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} for more details).

\end{itemize}


\subsubsection{Solving the linear system}
\label{\detokenize{documentation/ffddm/documentation:solving-the-linear-system}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{fGMRES}\PYG{p}{(}\PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{x0i}\PYG{p}{,} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{itmax}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{sp}\PYG{p}{)}
\end{sphinxVerbatim}

solves the linear system for problem \sphinxstylestrong{pr} using the flexible GMRES algorithm with preconditioner \(M^{-1}\) (corresponding to \sphinxcode{\sphinxupquote{pr\#PREC}}).
Returns the local vector corresponding to the restriction of the solution to \sphinxcode{\sphinxupquote{pr\#prfe\#Vhi}}.
\sphinxstylestrong{x0i} and \sphinxstylestrong{bi} are local distributed vectors corresponding respectively to the initial guess and the right-hand side (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}}).
\sphinxstylestrong{eps} is the stopping criterion in terms of the relative decrease in residual norm.
If \sphinxstylestrong{eps} \(< 0\), the residual norm itself is used instead.
\sphinxstylestrong{itmax} sets the maximum number of iterations.
\sphinxstylestrong{sp} selects between the \sphinxcode{\sphinxupquote{"left"}} or \sphinxcode{\sphinxupquote{"right"}} preconditioning variants: \sphinxstyleemphasis{left} preconditioned GMRES solves \(M^{-1} A x = M^{-1} b\), while \sphinxstyleemphasis{right} preconditioned GMRES solves \(A M^{-1} y = b\) for \(y\), with \(x = M^{-1} y\).


\subsubsection{Using \sphinxstyleemphasis{HPDDM} within \sphinxstyleemphasis{ffddm}}
\label{\detokenize{documentation/ffddm/documentation:using-hpddm-within-ffddm}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}}
\sphinxstylestrong{ffddm} allows you to use \sphinxstylestrong{HPDDM} to solve your problem, effectively replacing the \sphinxstylestrong{ffddm} implementation of all parallel linear algebra computations.
\sphinxstylestrong{ffddm} can then be viewed as a finite element interface for \sphinxstylestrong{HPDDM}.

You can use \sphinxstylestrong{HPDDM} features unavailable in \sphinxstylestrong{ffddm} such as advanced Krylov subspace methods implementing block and recycling techniques.

To switch to \sphinxstylestrong{HPDDM}, simply define the macro \sphinxcode{\sphinxupquote{pr\#withhpddm}} before using {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}. You can then pass \sphinxstylestrong{HPDDM} options
with command-line arguments or directly to the underlying \sphinxstylestrong{HPDDM} operator \sphinxcode{\sphinxupquote{pr\#hpddmOP}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{PBwithhpddm}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{1} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{PBhpddmOP}\PYG{p}{,}\PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}krylov\PYGZus{}method gcrodr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

You can also choose to replace only the Krylov solver, by defining the macro \sphinxcode{\sphinxupquote{pr\#withhpddmkrylov}} before using {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}.
Doing so, a call to \sphinxcode{\sphinxupquote{pr\#fGMRES}} will call the \sphinxstylestrong{HPDDM} Krylov solver, with \sphinxstylestrong{ffddm} providing the operator and preconditioner through \sphinxcode{\sphinxupquote{pr\#A}} and \sphinxcode{\sphinxupquote{pr\#PREC}}.

An example can be found in \sphinxstylestrong{Helmholtz-2d-HPDDM-BGMRES.edp}, see the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section.


\subsection{Parameters}
\label{\detokenize{documentation/ffddm/parameters:parameters}}\label{\detokenize{documentation/ffddm/parameters::doc}}

\subsubsection{Command-line arguments}
\label{\detokenize{documentation/ffddm/parameters:command-line-arguments}}\label{\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_verbosity N}}, the level of verbosity of \sphinxstylestrong{ffddm}, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmverbosity}}}} (default 3).

\item {} 
\sphinxcode{\sphinxupquote{-seqddm N}} use \sphinxstylestrong{ffddm} in sequential mode, with N the number of subdomains.

\item {} 
\sphinxcode{\sphinxupquote{-noGlob}} if present, do not define any global quantity (such as saving the global mesh for plotting or building the global restriction matrices).
Cannot be used in sequential mode or with plotting.

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_partitioner N}} specifies how to partition the initial domain, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpartitioner}}}} (default 1, \sphinxstyleemphasis{metis}).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_overlap N}} specifies the width of the overlap region between subdomains, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}} (default 1).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_master\_p N}}, number of master processes for the coarse problem (for two level preconditioners), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} (default 1).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_master\_exclude 0\textbar{}1}} exclude master processes from the domain decomposition, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} (default 0).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_split N}}, level of refinement of the local submeshes with respect to the initial global mesh, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}} (default 1).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_schwarz\_method S}}, specifies the type of one level preconditioner \(M^{-1}_1\): “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} (default “ras”).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_geneo\_nu N}}, number of local eigenvectors to compute in each subdomain when solving the local generalized eigenvalue problem for the GenEO method, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} (default 20).

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_geneo\_threshold R}}, threshold parameter for selecting local eigenvectors when solving the local generalized eigenvalue problems for the GenEO method, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} (default 0.5).
If the command-line parameter \sphinxstylestrong{-ffddm\_geneo\_nu N} is used, then {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} is initialized to 0.

\item {} 
\sphinxcode{\sphinxupquote{-ffddm\_schwarz\_coarse\_correction S}}, specifies the coarse correction formula to use for the two level preconditioner: “AD” (\sphinxstyleemphasis{Additive}), “BNN” (\sphinxstyleemphasis{Balancing Neumann-Neumann}), “ADEF1” (\sphinxstyleemphasis{Adapted Deflation Variant 1}), “ADEF2” (\sphinxstyleemphasis{Adapted Deflation Variant 2}), “RBNN1” (\sphinxstyleemphasis{Reduced Balancing Variant 1}), “RBNN2” (\sphinxstyleemphasis{Reduced Balancing Variant 2}) or “none” (no coarse correction), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcorrection}}}} (default “ADEF1”).

\end{itemize}


\subsubsection{Global parameters}
\label{\detokenize{documentation/ffddm/parameters:global-parameters}}\label{\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{ffddmverbosity}} initialized by command-line argument \sphinxstylestrong{-ffddm\_verbosity N}, specifies the level of verbosity of \sphinxstylestrong{ffddm} (default 3).

\item {} 
\sphinxcode{\sphinxupquote{ffddmpartitioner}} initialized by command-line argument \sphinxstylestrong{-ffddm\_partitioner N}, specifies how to partition the initial domain:
\begin{itemize}
\item {} 
N=0: user-defined partition through the definition of a macro, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}}

\item {} 
N=1: use the automatic graph partitioner \sphinxstyleemphasis{metis} (default)

\item {} 
N=2: use the automatic graph partitioner \sphinxstyleemphasis{scotch}

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{ffddmoverlap}} initialized by command-line argument \sphinxstylestrong{-ffddm\_overlap N}, specifies the number of layers of mesh elements in the overlap region between subdomains N \textgreater{}= 1 (default 1).
\sphinxstylestrong{Remark} The actual width of the overlap region between subdomains is 2N, since each subdomain is extended by N layers of elements in a symmetric way.

\item {} 
\sphinxcode{\sphinxupquote{ffddminterfacelabel}} the label of the new border of the subdomain meshes (the interface between the subdomains) (default 10).
Used for imposing problem-dependent boundary conditions at the interface between subdomains for the preconditioner, for example optimized Robin boundary conditions (see ORAS).

\item {} 
\sphinxcode{\sphinxupquote{ffddmpCS}} initialized by command-line argument \sphinxstylestrong{-ffddm\_master\_p N}, number of mpi processes used for the assembly and resolution of the coarse problem for two level preconditioners (default 1).

\item {} 
\sphinxcode{\sphinxupquote{ffddmexclude}} initialized by command-line argument \sphinxstylestrong{-ffddm\_master\_exclude}, 0 or 1 (default 0).
If true, mpi ranks participating in the assembly and resolution of the coarse problem for two level preconditioners will be excluded from the spatial domain decomposition and will only work on the coarse problem.

\item {} 
\sphinxcode{\sphinxupquote{ffddmsplit}} initialized by command-line argument \sphinxstylestrong{ffddm\_split N}, level of refinement of the local submeshes with respect to the initial global mesh (default 1).
This is useful for large problems, where we want to avoid working with a very large global mesh.
The idea is to start from a coarser global mesh, and generate finer local meshes in parallel during the mesh decomposition step in order to reach the desired level of refinement for the subdomains.
For example, calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} with {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}} = 3 will generate local submeshes where each mesh element of the initial mesh is split into \(3^d\) elements.

\item {} 
\sphinxcode{\sphinxupquote{ffddmprecond}} initialized by command-line argument \sphinxstylestrong{-ffddm\_schwarz\_method S}, specifies the type of one level preconditioner \(M^{-1}_1\) to build when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}}: “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner).
Default is “ras”.
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} for more details.

\item {} 
\sphinxcode{\sphinxupquote{ffddmnu}} initialized by command-line argument \sphinxstylestrong{-ffddm\_geneo\_nu N}, number of local eigenvectors to compute in each subdomain when solving the local generalized eigenvalue problem for the GenEO method (default 20).
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} for more details.

\item {} 
\sphinxcode{\sphinxupquote{ffddmtau}} initialized by command-line argument \sphinxstylestrong{-ffddm\_geneo\_threshold R}, threshold parameter for selecting local eigenvectors when solving the local generalized eigenvalue problems for the GenEO method (default 0.5).
If the command-line parameter \sphinxstylestrong{-ffddm\_geneo\_nu N} is used, then {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} is initialized to 0.
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} for more details.

\item {} 
\sphinxcode{\sphinxupquote{ffddmcorrection}} initialized by command-line argument \sphinxstylestrong{-ffddm\_schwarz\_coarse\_correction S}, specifies the coarse correction formula to use for the two level preconditioner: “AD” (\sphinxstyleemphasis{Additive}), “BNN” (\sphinxstyleemphasis{Balancing Neumann-Neumann}), “ADEF1” (\sphinxstyleemphasis{Adapted Deflation Variant 1}), “ADEF2” (\sphinxstyleemphasis{Adapted Deflation Variant 2}), “RBNN1” (\sphinxstyleemphasis{Reduced Balancing Variant 1}), “RBNN2” (\sphinxstyleemphasis{Reduced Balancing Variant 2}) or “none” (no coarse correction).
Default is “ADEF1”.
See the section about {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{Two level preconditioners}}}} for more details.

\end{itemize}


\subsection{Tutorial}
\label{\detokenize{documentation/ffddm/tutorial:tutorial}}\label{\detokenize{documentation/ffddm/tutorial:ffddmtutorial}}\label{\detokenize{documentation/ffddm/tutorial::doc}}
Authors: Pierre-Henri Tournier - Frédéric Nataf - Pierre Jolivet


\subsubsection{What is \sphinxstylestrong{ffddm} ?}
\label{\detokenize{documentation/ffddm/tutorial:what-is-ffddm}}\begin{itemize}
\item {} 
\sphinxstylestrong{ffddm} implements a class of parallel solvers in \sphinxstyleemphasis{FreeFEM}: \sphinxstyleemphasis{overlapping Schwarz domain decomposition methods}

\item {} \begin{description}
\item[{The entire \sphinxstylestrong{ffddm} framework is written in the \sphinxstyleemphasis{FreeFEM} language \sphinxstylestrong{ffddm} aims at simplifying the use of parallel solvers in \sphinxstyleemphasis{FreeFEM}}] \leavevmode
You can find the \sphinxstylestrong{ffddm} scripts \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/idp}{here} (‘ffddm*.idp’ files) and examples \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/ffddm}{here}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{ffddm} provides a set of high-level macros and functions to}] \leavevmode\begin{itemize}
\item {} 
handle data distribution: distributed meshes and linear algebra

\item {} 
build DD preconditioners for your variational problems

\item {} 
solve your problem using preconditioned Krylov methods

\end{itemize}

\end{description}

\item {} 
\sphinxstylestrong{ffddm} implements scalable two level Schwarz methods, with a coarse space correction built either from a coarse mesh or a \sphinxhref{https://link.springer.com/article/10.1007\%2Fs00211-013-0576-y}{GenEO} coarse space \sphinxstyleemphasis{Ongoing research}: approximate coarse solves and three level methods

\item {} \begin{description}
\item[{\sphinxstylestrong{ffddm} can also act as a wrapper for the \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} library.}] \leavevmode
\sphinxstylestrong{HPDDM} is an efficient C++11 implementation of various domain decomposition methods and Krylov subspace algorithms with advanced block and recycling techniques More details on how to use \sphinxstylestrong{HPDDM} within \sphinxstylestrong{ffddm} {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}

\end{description}

\end{itemize}


\subsubsection{Why Domain Decomposition Methods ?}
\label{\detokenize{documentation/ffddm/tutorial:why-domain-decomposition-methods}}
How can we solve a large sparse linear system \(A u = b \in \mathbb{R}^n\) ?

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Methods_Solves_1}.png}


\paragraph{Step 1: Decompose the mesh}
\label{\detokenize{documentation/ffddm/tutorial:step-1-decompose-the-mesh}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

Build a collection of \(N\) overlapping sub-meshes \((Th_{i})_{i=1}^N\) from the global mesh \(Th\)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxincludegraphics[width=1.000\linewidth]{{domain1}.png}
&
\sphinxincludegraphics[width=1.000\linewidth]{{domain2}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{prmesh} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{n}{comm} \PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
mesh distributed over the MPI processes of communicator \sphinxstylestrong{comm}

\item {} 
initial mesh \sphinxstylestrong{ThGlobal} partitioned with \sphinxstyleemphasis{metis} by default

\item {} 
size of the overlap given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}} (default 1)

\end{itemize}

\sphinxtitleref{prmesh\#Thi} is the local mesh of the subdomain for each mpi process

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Copy and paste this to a file ‘test.edp’ and run it:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{2} test.edp \PYGZhy{}glut ffglut
\end{sphinxVerbatim}


\paragraph{Step 2: Define your finite element}
\label{\detokenize{documentation/ffddm/tutorial:step-2-define-your-finite-element}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{prfe} \PYG{p}{,} \PYG{n}{prmesh} \PYG{p}{,} \PYG{n}{scalar} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n}{Pk} \PYG{p}{)}
\end{sphinxVerbatim}

builds the local finite element spaces and associated distributed operators on top of the mesh decomposition \sphinxstylestrong{prmesh}
\begin{itemize}
\item {} 
\sphinxstylestrong{scalar}: type of data for this finite element: \sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex}

\item {} 
\sphinxstylestrong{Pk}: your type of finite element: P1, {[}P2,P2,P1{]}, …

\item {} 
\sphinxstylestrong{def}, \sphinxstylestrong{init}: macros specifying how to define and initialize a \sphinxstylestrong{Pk} FE function

\end{itemize}

\sphinxtitleref{prfe\#Vhi} is the local FE space defined on \sphinxtitleref{prmesh\#Thi} for each mpi process

Example for P2 \sphinxstyleemphasis{complex}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{complex}\PYG{p}{,}
                    \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\end{sphinxVerbatim}

Example for {[}P2,P2,P1{]} \sphinxstyleemphasis{real}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{]}     \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,}
                    \PYG{k+kp}{init}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]} \PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{Distributed vectors and restriction operators}
\label{\detokenize{documentation/ffddm/tutorial:distributed-vectors-and-restriction-operators}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{domain2}.png}\hspace*{\fill}}

Natural decomposition of the set of d.o.f.’s \({\mathcal N}\) of \(Vh\) into the \(N\) subsets of d.o.f.’s \(({\mathcal N}_i)_{i=1}^N\) each associated with the local FE space \(Vh_i\)
\begin{equation*}
\begin{split}{\mathcal N} = \cup_{i=1}^N {\mathcal N}_i\,,\end{split}
\end{equation*}
but with duplications of the d.o.f.’s in the overlap

\sphinxstylestrong{\_Definition\_} a \sphinxstyleemphasis{distributed vector} is a collection of local vectors \(({\mathbf V_i})_{1\le i\le N}\) so that the values on the duplicated d.o.f.’s are the same:
\begin{equation*}
\begin{split}{\mathbf V}_i = R_i\,{\mathbf V}, \quad i = 1, ..., N\end{split}
\end{equation*}
where \({\mathbf V}\) is the corresponding global vector
and \(R_i\) is the \sphinxstyleemphasis{restriction operator} from \({\mathcal N}\) into \({\mathcal N}_i\)

\sphinxstylestrong{Remark} \(R_i^T\) is the \sphinxstyleemphasis{extension operator}: extension by \(0\) from \({\mathcal N}_i\) into \({\mathcal N}\)


\subparagraph{Partition of unity}
\label{\detokenize{documentation/ffddm/tutorial:partition-of-unity}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.750\linewidth]{{domain3}.png}\hspace*{\fill}}

Duplicated unknowns coupled via a \sphinxstyleemphasis{partition of unity}:
\begin{equation*}
\begin{split}I = \sum_{i = 1}^N R_i^T D_i R_i\end{split}
\end{equation*}
\((D_i)_{1\le i \le N}\) are square diagonal matrices of size \(\#{\mathcal N}_i\)
\begin{equation*}
\begin{split}{\mathbf V} = \sum_{i = 1}^N R_i^T D_i R_i {\mathbf V} = \sum_{i = 1}^N R_i^T D_i {\mathbf V_i}\end{split}
\end{equation*}

\subparagraph{Data exchange between neighbors}
\label{\detokenize{documentation/ffddm/tutorial:data-exchange-between-neighbors}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{update}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vi}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{scale}\PYG{p}{)}
\end{sphinxVerbatim}

synchronizes local vectors \({\mathbf V}_i\) between subdomains \(\Rightarrow\) exchange the values of \(mathbf{V}_i\) shared with neighbors in the overlap region
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T D_j {\mathbf V}_j \right) = D_i {\mathbf V}_i + \sum_{j\in \mathcal{O}(i)} R_i\,R_j^T\,D_j {\mathbf V}_j\end{split}
\end{equation*}
where \(\mathcal{O}(i)\) is the set of neighbors of subdomain \$i\$. Exchange operators \(R_i\,R_j^T\) correspond to neighbor-to-neighbor MPI communications

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T {\mathbf V}_j \right)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T D_j {\mathbf V}_j  \right)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{vi} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{FEDk}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vi} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,}\PYG{n}{vi}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,}\PYG{n}{vi}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{multiplicity}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Step 3: Define your problem}
\label{\detokenize{documentation/ffddm/tutorial:step-3-define-your-problem}}\label{\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{prfe} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\end{sphinxVerbatim}

builds the distributed operator associated to your variational form on top of the distributed FE \sphinxstylestrong{prfe}

\sphinxstylestrong{Varf} is a macro defining your abstract variational form

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\end{sphinxVerbatim}

\(\Rightarrow\) assemble local ‘Dirichlet’ matrices \(A_i = R_i A R_i^T\)
\begin{equation*}
\begin{split}A = \sum_{i=1}^N R_i^T D_i A_i R_i\end{split}
\end{equation*}
\begin{sphinxadmonition}{warning}{Warning:}
only true because \(D_i R_i A = D_i A_i R_i\) due to the fact that \(D_i\) vanishes at the interface \sphinxstylestrong{!!}
\end{sphinxadmonition}

\sphinxtitleref{pr\#A} applies \(A\) to a distributed vector: \({\mathbf U}_i \leftarrow R_i \sum_{j=1}^N R_j^T D_j A_j {\mathbf V}_j\)

\(\Rightarrow\) multiply by \(A_i\) + \sphinxtitleref{prfe\#update}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}

\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBA}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A*b}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Summary so far: translating your sequential \sphinxstyleemphasis{FreeFEM} script}
\label{\detokenize{documentation/ffddm/tutorial:summary-so-far-translating-your-sequential-freefem-script}}

\paragraph{Step 1: Decompose the mesh}
\label{\detokenize{documentation/ffddm/tutorial:id1}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{mpiCommWorld}\PYG{p}{)}
\end{sphinxVerbatim}

Step 2: Define your finite element

See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}
\end{sphinxVerbatim}

Step 3: Define your problem

See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{Pb}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{Pb}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Solve the linear system}
\label{\detokenize{documentation/ffddm/tutorial:solve-the-linear-system}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBdirectsolve}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Solve the linear system with the parallel direct solver \sphinxstyleemphasis{MUMPS}}
\label{\detokenize{documentation/ffddm/tutorial:solve-the-linear-system-with-the-parallel-direct-solver-mumps}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{directsolve}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{)}
\end{sphinxVerbatim}

We have \(A\) and \(b\) in distributed form, we can solve the linear system \(A u = b\) using the parallel direct solver \sphinxstyleemphasis{MUMPS}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve the problem using the direct parallel solver MUMPS}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBdirectsolve}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Step 4: Define the one level DD preconditioner}
\label{\detokenize{documentation/ffddm/tutorial:step-4-define-the-one-level-dd-preconditioner}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{VarfPrec} \PYG{p}{)}
\end{sphinxVerbatim}

builds the one level preconditioner for problem \sphinxstylestrong{pr}.

By default it is the \sphinxstyleemphasis{Restricted Additive Schwarz (RAS)} preconditioner:
\begin{equation*}
\begin{split}M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i A_i^{-1} R_i \quad \text{with}\; A_i = R_i A R_i^T\end{split}
\end{equation*}
\sphinxstylestrong{\_Setup step\_}: compute the \(LU\) (or \(L D L^T\)) factorization of local matrices \(A_i\)

\sphinxtitleref{pr\#PREC1} applies \(M^{-1}_1\) to a distributed vector: \({\mathbf U}_i \leftarrow R_i \sum_{j=1}^N R_j^T D_j A_j^{-1} {\mathbf V}_i\)

\(\Rightarrow\) apply \(A_i^{-1}\) (forward/backward substitutions) + \sphinxtitleref{prfe\#update}


\paragraph{Step 5: Solve the linear system with preconditioned GMRES}
\label{\detokenize{documentation/ffddm/tutorial:step-5-solve-the-linear-system-with-preconditioned-gmres}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{fGMRES}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{x0i}\PYG{p}{,} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{itmax}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{sp}\PYG{p}{)}
\end{sphinxVerbatim}

solves the linear system with flexible GMRES with DD preconditioner \(M^{-1}\)
\begin{itemize}
\item {} 
\sphinxstylestrong{x0i}: initial guess

\item {} 
\sphinxstylestrong{bi}: right-hand side

\item {} 
\sphinxstylestrong{eps}: relative tolerance

\item {} 
\sphinxstylestrong{itmax}: maximum number of iterations

\item {} 
\sphinxstylestrong{sp}: \sphinxtitleref{“left”} or \sphinxtitleref{“right”} preconditioning

\end{itemize}

\sphinxstyleemphasis{left preconditioning}

solve \(M^{-1} A x = M^{-1} b\)

\sphinxstyleemphasis{right preconditioning}

solve \(A M^{-1} y = b\)

\(\Rightarrow x = M^{-1} y\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{PBwritesummary}
\end{sphinxVerbatim}


\subsubsection{Define a two level DD preconditioner}
\label{\detokenize{documentation/ffddm/tutorial:define-a-two-level-dd-preconditioner}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\sphinxstylestrong{Goal} improve scalability of the one level method

\(\Rightarrow\) enrich the one level preconditioner with a \sphinxstyleemphasis{coarse problem} coupling all subdomains

Main ingredient is a rectangular matrix \(\color{red}{Z}\) of size \(n \times n_c,\,\) where \(n_c \ll n\)
\(\color{red}{Z}\) is the \sphinxstyleemphasis{coarse space} matrix

The \sphinxstyleemphasis{coarse space operator} \(E = \color{red}{Z}^T A \color{red}{Z}\) is a square matrix of size \(n_c \times n_c\)

The simplest way to enrich the one level preconditioner is through the \sphinxstyleemphasis{additive coarse correction} formula:
\begin{equation*}
\begin{split}M^{-1}_2 = M^{-1}_1 + \color{red}{Z} E^{-1} \color{red}{Z}^T\end{split}
\end{equation*}
\sphinxstyleemphasis{How to choose \$color\{red\}\{Z\}\$ ?}


\subsubsection{Build the GenEO coarse space}
\label{\detokenize{documentation/ffddm/tutorial:build-the-geneo-coarse-space}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\end{sphinxVerbatim}

The \sphinxstyleemphasis{GenEO} method builds a robust coarse space for highly heterogeneous or anisotropic \sphinxstylestrong{SPD} problems

\(\Rightarrow\) solve a local generalized eigenvalue problem in each subdomain
\begin{equation*}
\begin{split}D_i A_i D_i\, V_{i,k} = \lambda_{i,k}\, A_i^{\text{Neu}} \,V_{i,k}\end{split}
\end{equation*}
with \(A_i^{\text{Neu}}\) the local Neumann matrices built from \sphinxstylestrong{Varf} (same \sphinxstylestrong{Varf} as {\hyperref[\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 3}}}}

The GenEO coarse space is \(\color{red}{Z} = (R_i^T D_i V_{i,k})^{i=1,...,N}_{\lambda_{i,k} \ge \color{blue}{\tau}}\)
The eigenvectors \(V_{i,k}\) selected to enter the coarse space correspond to eigenvalues \(\lambda_{i,k} \ge \color{blue}{\tau}\), where \(\color{blue}{\tau}\) is a threshold parameter
\begin{quote}

\sphinxstylestrong{Theorem}
the spectrum of the preconditioned operator lies in the interval \([\displaystyle \frac{1}{1+k_1 \color{blue}{\tau}} , k_0 ]\)
where \(k_0 - 1\) is the \# of neighbors and \(k_1\) is the multiplicity of intersections
\(\Rightarrow\) \(k_0\) and \(k_1\) do not depend on \(N\) nor on the PDE
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Build the GenEO coarse space}
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Build the coarse space from a coarse mesh}
\label{\detokenize{documentation/ffddm/tutorial:build-the-coarse-space-from-a-coarse-mesh}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{Thc} \PYG{p}{,} \PYG{n}{VarfEprec} \PYG{p}{,} \PYG{n}{VarfAprec} \PYG{p}{)}
\end{sphinxVerbatim}

For \sphinxstylestrong{non SPD} problems, an alternative is to build the coarse space by discretizing the PDE on a coarser mesh \sphinxstylestrong{Thc}

\(Z\) will be the \sphinxstyleemphasis{interpolation matrix} from the coarse FE space \({Vh}_c\) to the original FE space \(Vh\)

\(\Rightarrow E=\color{red}{Z}^{T} A \color{red}{Z}\) is the matrix of the problem discretized on the coarse mesh

The variational problem to be discretized on \sphinxstylestrong{Thc} is given by macro \sphinxstylestrong{VarfEprec}

\sphinxstylestrong{VarfEprec} can differ from the original \sphinxstylestrong{Varf} of the problem

\sphinxstyleemphasis{Example}: added absorption for wave propagation problems

Similarly, \sphinxstylestrong{VarfAprec} specifies the global operator involved in multiplicative coarse correction formulas. It defaults to \(A\) if \sphinxstylestrong{VarfAprec} is not defined

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Build the coarse space from a coarse mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thc} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Thc} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{null} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Use \sphinxstylestrong{HPDDM} within \sphinxstylestrong{ffddm}}
\label{\detokenize{documentation/ffddm/tutorial:use-hpddm-within-ffddm}}
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\sphinxstylestrong{ffddm} allows you to use \sphinxstylestrong{HPDDM} to solve your problem, effectively replacing the \sphinxstylestrong{ffddm} implementation of all parallel linear algebra computations

\(\Rightarrow\) define your problem with \sphinxstylestrong{ffddm}, solve it with \sphinxstylestrong{HPDDM}

\(\Rightarrow\) \sphinxstylestrong{ffddm} acts as a finite element interface for \sphinxstylestrong{HPDDM}
\begin{itemize}
\item {} 
you can use \sphinxstylestrong{HPDDM} features unavailable in \sphinxstylestrong{ffddm} such as advanced Krylov subspace methods implementing block and recycling techniques

\item {} 
conversely, some features of \sphinxstylestrong{ffddm} such as two level methods built from a coarse mesh are not implemented in \sphinxstylestrong{HPDDM}

\end{itemize}

To switch to \sphinxstylestrong{HPDDM}, simply define the macro \sphinxtitleref{pr\#withhpddm} before using \sphinxtitleref{ffddmsetupOperator} ({\hyperref[\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 3}}}}). You can then pass \sphinxstylestrong{HPDDM} options
with command-line arguments or directly to the underlying \sphinxstylestrong{HPDDM} operator:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{PBwithhpddm}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{1} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{PBhpddmOP}\PYG{p}{,}\PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}krylov\PYGZus{}method gcrodr}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Or, define \sphinxtitleref{pr\#withhpddmkrylov} to use \sphinxstylestrong{HPDDM} only for the Krylov method

Example \sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-HPDDM-BGMRES.edp}{here}: Helmholtz problem with multiple rhs solved with Block GMRES


\subsubsection{Some results: Heterogeneous 3D elasticity with GenEO}
\label{\detokenize{documentation/ffddm/tutorial:some-results-heterogeneous-3d-elasticity-with-geneo}}
Heterogeneous 3D linear elasticity equation discretized with P2 FE solved on 4096 MPI processes \(n\approx\) 262 million

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{comparisonAMG}.png}


\subsubsection{Some results: 2-level DD for Maxwell equations, scattering from the COBRA cavity}
\label{\detokenize{documentation/ffddm/tutorial:some-results-2-level-dd-for-maxwell-equations-scattering-from-the-cobra-cavity}}
f = 10 GHz


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxincludegraphics[width=0.750\linewidth]{{10GHz_borders_new_v2}.png}
&
\sphinxincludegraphics[width=1.000\linewidth]{{10GHz_new}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

f = 16 GHz

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{16GHz_new}.png}\hspace*{\fill}}


\subsubsection{Some results: 2-level DD for Maxwell equations, scattering from the COBRA cavity}
\label{\detokenize{documentation/ffddm/tutorial:id2}}\begin{itemize}
\item {} 
order 2 Nedelec edge FE

\item {} 
fine mesh: 10 points per wavelength

\item {} 
coarse mesh: 3.33 points per wavelength

\item {} 
two level ORAS preconditioner with added absorption

\item {} 
f = 10 GHz: \(n\approx\) 107 million, \(n_c \approx\) 4 million
\begin{quote}

f = 16 GHz: \(n\approx\) 198 million, \(n_c \approx\) 7.4 million
\end{quote}

\end{itemize}

\(\rightarrow\) coarse problem too large for a direct solver
\(\Rightarrow\) inexact coarse solve: GMRES + one level ORAS preconditioner

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.750\linewidth]{{table}.png}\hspace*{\fill}}

speedup of 1.81 from 1536 to 3072 cores at 10GHz

1.51 from 3072 to 6144 cores at 16GHz

You can find the script \sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell\_Cobracavity.edp}{here}


\subsection{Examples}
\label{\detokenize{documentation/ffddm/examples:examples}}\label{\detokenize{documentation/ffddm/examples:ffddmexamples}}\label{\detokenize{documentation/ffddm/examples::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
File name
&\sphinxstyletheadfamily 
\(M^{-1}_1\)
&\sphinxstyletheadfamily 
\(M^{-1}_2\)
&\sphinxstyletheadfamily 
inexact CS
&\sphinxstyletheadfamily 
comments
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-minimal-direct.edp}{diffusion-3d-minimal-direct.edp}
&&&&
direct solver MUMPS
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-minimal-ddm.edp}{diffusion-3d-minimal-ddm.edp}
&
RAS
&
GenEO
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-simple.edp}{diffusion-3d-simple.edp}
&
RAS
&
GenEO
&&
comparison with direct solver
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-2d-thirdlevelgeneo.edp}{diffusion-2d-thirdlevelgeneo.edp}
&
RAS
&
GenEO
&
RAS + GenEO
&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/elasticity-3d-simple.edp}{elasticity-3d-simple.edp}
&
RAS
&
GenEO
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/elasticity-3d-thirdlevelgeneo.edp}{elasticity-3d-thirdlevelgeneo.edp}
&
RAS
&
GenEO
&
RAS + GenEO
&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-simple.edp}{Helmholtz-2d-simple.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-marmousi.edp}{Helmholtz-2d-marmousi.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-3d-simple.edp}{Helmholtz-3d-simple.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-3d-overthrust.edp}{Helmholtz-3d-overthrust.edp}
&
ORAS
&&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-HPDDM-BGMRES.edp}{Helmholtz-2d-HPDDM-BGMRES.edp}
&
ORAS
&&&
multi-rhs Block GMRES with HPDDM
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Navier-2d-marmousi2.edp}{Navier-2d-marmousi2.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell-3d-simple.edp}{Maxwell-3d-simple.edp}
&
ORAS
&
Coarse Mesh
&&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell\_Cobracavity.edp}{Maxwell\_Cobracavity.edp}
&
ORAS
&
Coarse Mesh
&
ORAS
&\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/natural\_convection.edp}{natural\_convection.edp}
&
ORAS
&
Coarse Mesh
&&
nonlinear
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/natural\_convection\_3D\_obstacle.edp}{natural\_convection\_3D\_obstacle.edp}
&
ORAS
&
Coarse Mesh
&&
nonlinear
\\
\hline
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Richards-2d.edp}{Richards-2d.edp}
&
RAS
&&&
nonlinear time dependent mesh adaptation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Examples}
\label{\detokenize{example/index:examples}}\label{\detokenize{example/index:id1}}\label{\detokenize{example/index::doc}}

\section{Misc}
\label{\detokenize{example/misc:misc}}\label{\detokenize{example/misc::doc}}

\subsection{Poisson’s Equation}
\label{\detokenize{example/misc:poisson-s-equation}}\label{\detokenize{example/misc:examplepoissonequation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{NAdapt} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{h}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{h}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{l}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{l}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{H}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{H}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{L}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b5}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{l}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b6}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{H}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change P1 to P2 to test P2 finite element}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f} \PYG{o}{*} \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{,} \PYG{n}{b4}\PYG{p}{,} \PYG{n}{b5}\PYG{p}{,} \PYG{n}{b6}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation iterations}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NAdapt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Solve}
   \PYG{n}{Poisson}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Adaptmesh}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error} \PYG{o}{=} \PYG{n}{error} \PYG{o}{*} \PYG{k+kp}{coef}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{poisson_associated_mesh}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/misc:id1}}\label{\detokenize{example/misc:figexamplepoisson}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{poisson_adapted_mesh}.jpg}
\caption{Solution on adapted mesh}\label{\detokenize{example/misc:id2}}\label{\detokenize{example/misc:figexamplepoissonadapt}}\end{subfigure}
\caption{Poisson}

\end{figure}



\subsection{Poisson’s equation 3D}
\label{\detokenize{example/misc:poisson-s-equation-3d}}\label{\detokenize{example/misc:examplepoissonequation3d}}\label{\detokenize{example/misc:Poisson}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0,2pi[}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{n}{f3}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P23d}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uhe} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uhe min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u2e}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap3d} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Lap3d}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n+nf}{d} \PYG{o}{=} \PYG{n}{ue} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} diff l\PYGZca{}intfy = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{u2} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{n}{u2e} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{u2e}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{poisson_3d}.jpg}
\caption{Iso-surfaces of the solution}\label{\detokenize{example/misc:id3}}\end{figure}


\subsection{Stokes Equation on a cube}
\label{\detokenize{example/misc:stokes-equation-on-a-cube}}\label{\detokenize{example/misc:examplestokesequationonacube}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{// Dynamically loaded tools for 3D}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rdown} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c8x8x8}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 3D mesh visualization with medit}

\PYG{c+c1}{// Fespaces}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VVh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{VVh} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem (directly solved)}
\PYG{k+kt}{solve} \PYG{n}{vStokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
        \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{)} \PYG{o}{*} \PYG{n}{p}
        \PYG{o}{+} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{*} \PYG{n}{q} \PYG{o}{*} \PYG{n}{p}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 3D visualization of pressure isolines}

\PYG{c+c1}{// See 10 plan of the velocity in 2D}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Cut plane}
    \PYG{k+kt}{real} \PYG{n}{yy} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
    \PYG{c+c1}{// 3D to 2D interpolation}
    \PYG{n}{ux} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{uz} \PYG{o}{=} \PYG{n}{u3}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{p}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cut y = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{yy}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Stokes3d}.jpg}
\caption{Solution}\label{\detokenize{example/misc:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Stokes3d-Th}.jpg}
\caption{Associated mesh}\label{\detokenize{example/misc:id5}}\end{subfigure}
\caption{Stokes}

\end{figure}



\subsection{Cavity}
\label{\detokenize{example/misc:cavity}}\label{\detokenize{example/misc:examplecavity}}\label{\detokenize{example/misc:Stokes3d}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{300}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rho} \PYG{o}{=} \PYG{l+m+mf}{500.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{uin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{noslip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{inflow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{;}

\PYG{c+c1}{//Macros}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{//}

\PYG{c+c1}{//Time}
\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{tabcpu}\PYG{p}{;}

\PYG{c+c1}{//mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{UPh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{,} \PYG{n}{ph}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Solve}
\PYG{k+kt}{varf} \PYG{n+nf}{navierstokes}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{,} \PYG{n}{ph}\PYG{p}{]}\PYG{p}{)}
  \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{rho}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{o}{+} \PYG{n}{mu}\PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{:}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{ph}\PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{ph}
    \PYG{p}{)}

  \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)} \PYG{p}{(}
      \PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{o}{+} \PYG{n}{rho}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*} \PYG{p}{[}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{upx}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{)}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{p}{)}

  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{noslip}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{inflow}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{n}{uin}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{;}

\PYG{c+c1}{//Initialization}
\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{NS} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{n}{UPh}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NSrhs} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Time loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{NSrhs} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ux}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{NS}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{NSrhs}\PYG{p}{;}

  \PYG{n+nf}{plot}\PYG{p}{(} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,}\PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//CPU}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ CPU = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
\PYG{n}{tabcpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Mesh Generation}
\label{\detokenize{example/meshGeneration:mesh-generation}}\label{\detokenize{example/meshGeneration:examplemeshgeneration}}\label{\detokenize{example/meshGeneration::doc}}

\subsection{Square mesh}
\label{\detokenize{example/meshGeneration:square-mesh}}\label{\detokenize{example/meshGeneration:examplemeshsquare}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{1.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{labs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{labs}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square flags = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Mesh adaptation}
\label{\detokenize{example/meshGeneration:mesh-adaptation}}\label{\detokenize{example/meshGeneration:examplemeshadaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{hmin} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{h}\PYG{o}{*}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//old mesh is deleted}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptation1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptation2}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/meshGeneration:id2}}\end{subfigure}
\caption{Mesh adaptation}

\end{figure}



\subsection{Mesh adaptation for the Poisson’s problem}
\label{\detokenize{example/meshGeneration:mesh-adaptation-for-the-poisson-s-problem}}\label{\detokenize{example/meshGeneration:examplemeshadaptationforthepoissonproblem}}\label{\detokenize{example/meshGeneration:MeshAdaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Poisson}\PYG{p}{;}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoisson1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoisson2}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/meshGeneration:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoissonU}.jpg}
\caption{Solution on adapted mesh}\label{\detokenize{example/meshGeneration:id5}}\end{subfigure}
\caption{Mesh adaptation (Poisson)}

\end{figure}



\subsection{Uniform mesh adaptation}
\label{\detokenize{example/meshGeneration:uniform-mesh-adaptation}}\label{\detokenize{example/meshGeneration:exampleuniformmeshadaptation}}\label{\detokenize{example/meshGeneration:MeshAdaptationPoisson}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// The initial mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// More than one time due to the}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// adaptation bound {}`maxsubdiv={}`}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{UniformMeshAdaptation1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id6}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{UniformMeshAdaptation2}.jpg}
\caption{Adapted mesh}\label{\detokenize{example/meshGeneration:id7}}\end{subfigure}
\caption{Uniform mesh adaptation}

\end{figure}



\subsection{Borders}
\label{\detokenize{example/meshGeneration:borders}}\label{\detokenize{example/meshGeneration:exampleborders}}\label{\detokenize{example/meshGeneration:UniformMeshAdaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{others} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{inner} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}

   \PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C05}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C06}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 1 has region number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 2 has redion number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see a plot of the border mesh}
   \PYG{k+kt}{mesh} \PYG{n}{Thwithouthole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithouthole}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithhole}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{;}
   \PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{c+c1}{//  mesh Thwithhole = buildmesh(a(50) + b(\PYGZhy{}30)); // do not do this because the two}
   \PYG{c+c1}{// circles have the same radius = \PYGZdl{}0.3\PYGZdl{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders1}.jpg}
\caption{Mesh with two regions}\label{\detokenize{example/meshGeneration:id8}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders2}.jpg}
\caption{Mesh without a hole}\label{\detokenize{example/meshGeneration:id9}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders3}.jpg}
\caption{Mesh with a hole}\label{\detokenize{example/meshGeneration:id10}}\end{subfigure}
\caption{Borders}

\end{figure}



\subsection{Change}
\label{\detokenize{example/meshGeneration:change}}\label{\detokenize{example/meshGeneration:examplechange}}\label{\detokenize{example/meshGeneration:Borders}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change edges\PYGZsq{} label from 2 to 0}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change edges\PYGZsq{} label from 4 to 0}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Th1} \PYG{o}{+} \PYG{n}{Th2}\PYG{p}{;} \PYG{c+c1}{// \PYGZsq{}gluing together\PYGZsq{} Th1 and Th2 meshes}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nb lab = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}
   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// Definition of a macro}

\PYG{k+kt}{solve} \PYG{k+kr}{P}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Change}.jpg}
\caption{Result}\label{\detokenize{example/meshGeneration:id11}}\end{figure}


\subsection{Cube}
\label{\detokenize{example/meshGeneration:cube}}\label{\detokenize{example/meshGeneration:examplecube}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l6} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{57}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{r11} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l6}\PYG{p}{,} \PYG{k+kp}{flags} \PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, border area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sx} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sy} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sz} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sx}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sy}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sz}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ix} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iy}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{16}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
      \PYG{c+c1}{//value of ix,iy,iz =\PYGZgt{} face min 0, face max 2, no face 1}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, s = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ix} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(} \PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ii} \PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{real} \PYG{n}{volr11} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume region = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{volr11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{volr11} \PYG{o}{\PYGZhy{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nb err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Cube}.jpg}
\caption{Cube}\label{\detokenize{example/meshGeneration:id12}}\end{figure}


\subsection{Empty mesh}
\label{\detokenize{example/meshGeneration:empty-mesh}}\label{\detokenize{example/meshGeneration:exampleemptymesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ssd}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
   \PYG{c+c1}{// Builds the pseudo region numbering}
   \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ssd}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{iq} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// Because we have 2 triangles per quad}
      \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{ssd}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ix}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{iy}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{c+c1}{// Builds an emtpy mesh with all edges that satisfy e=T1 cap T2 and ssd[T1] != ssd[T2]}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EmptyMesh1}.jpg}
\caption{Empty square}\label{\detokenize{example/meshGeneration:id13}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EmptyMesh2}.jpg}
\caption{Empty diamond}\label{\detokenize{example/meshGeneration:id14}}\end{subfigure}
\caption{Empty mesh}

\end{figure}



\subsection{3 points}
\label{\detokenize{example/meshGeneration:points}}\label{\detokenize{example/meshGeneration:example3points}}\label{\detokenize{example/meshGeneration:EmptyMesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Square for Three\PYGZhy{}Point Bend Specimens fixed on Fix1, Fix2}
\PYG{c+c1}{// It will be loaded on Load}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{m} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Load}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Fix1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{Fix2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Load}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{3Points}.jpg}
\caption{3 Points}\label{\detokenize{example/meshGeneration:id15}}\end{figure}


\subsection{Bezier}
\label{\detokenize{example/meshGeneration:bezier}}\label{\detokenize{example/meshGeneration:examplebezier}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// A cubic Bezier curve connecting two points with two control points}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{bzi}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{p0}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{p1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q2}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{p0}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{q1}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{q2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p1}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p00} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.95}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{q30} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G3}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Bezier}.jpg}
\caption{Bezier}\label{\detokenize{example/meshGeneration:id16}}\end{figure}


\subsection{Build layer mesh}
\label{\detokenize{example/meshGeneration:build-layer-mesh}}\label{\detokenize{example/meshGeneration:examplebuildlayermesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2} \PYG{o}{=} \PYG{l+m+mi}{98}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a box with one hole and two regions}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r3} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// Change upper surface mesh\PYGZsq{}s triangles labels}
\PYG{c+c1}{// generated by the 2D mesh\PYGZsq{}s triangles Th}
\PYG{c+c1}{// from label 4 to label 12}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r4} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// Change lower surface mesh\PYGZsq{}s triangles labels}
\PYG{c+c1}{// generated by the 2D mesh\PYGZsq{}s triangles Th}
\PYG{c+c1}{// from label 4 to label 45}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{,}
   \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{r3}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{box 2 regions 1 hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a sphere with TetGen}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{test} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paACQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{test} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1}\PYG{p}{]}\PYG{p}{,}
   \PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{test}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere 2 regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{BuildLayerMesh1}.jpg}
\caption{Box with a hole}\label{\detokenize{example/meshGeneration:id17}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{BuildLayerMesh2}.jpg}
\caption{Sphere}\label{\detokenize{example/meshGeneration:id18}}\end{subfigure}
\caption{Build layer mesh}

\end{figure}



\subsection{Sphere}
\label{\detokenize{example/meshGeneration:sphere}}\label{\detokenize{example/meshGeneration:examplesphere}}\label{\detokenize{example/meshGeneration:BuildLayerMesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameter}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0, 2pi[}
\PYG{c+c1}{// A parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Partial derivative of the parametrization DF}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{c+c1}{// Periodic condition}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Sphere}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{n}{f3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Sphere1}.jpg}
\caption{Initial mesh}\label{\detokenize{example/meshGeneration:id19}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Sphere2}.jpg}
\caption{Sphere}\label{\detokenize{example/meshGeneration:id20}}\end{subfigure}
\caption{Sphere}\phantomsection\label{\detokenize{example/meshGeneration:Sphere}}

\end{figure}



\section{Finite Element}
\label{\detokenize{example/finiteElement:finite-element}}\label{\detokenize{example/finiteElement:examplefinteelement}}\label{\detokenize{example/finiteElement::doc}}

\subsection{Periodic 3D}
\label{\detokenize{example/finiteElement:periodic-3d}}\label{\detokenize{example/finiteElement:exampleperiodic3d}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kr}{searchMethod}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// More safe seach algo}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nnb} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{nni} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nz} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{n}{h}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{i1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i1}\PYG{p}{(}\PYG{n}{nni}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// Cleaning the memory correctly}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{old2new}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{sorder} \PYG{o}{=} \PYG{k+kr}{x} \PYG{o}{+} \PYG{k+kr}{y}\PYG{p}{;}
    \PYG{n+nf}{sort}\PYG{p}{(}\PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{old2new}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{new2old} \PYG{o}{=} \PYG{n}{old2new}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// Inverse permutation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{renumv}\PYG{o}{=}\PYG{n}{new2old}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{nu}\PYG{p}{;}
    \PYG{n}{nu}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nu=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Mesh 3D}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rtet} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{rtet}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rlow}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ int }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{area}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Periodic}.jpg}
\caption{Periodic mesh}\label{\detokenize{example/finiteElement:id1}}\end{figure}


\subsection{Lagrange multipliers}
\label{\detokenize{example/finiteElement:lagrange-multipliers}}\label{\detokenize{example/finiteElement:examplelagrangemultipliers}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{n1} \PYG{o}{=} \PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{va} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vL} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vb} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vL}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{vb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Block matrix}
\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{B} \PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{]} \PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xx}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{b1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// Builds the right hand side block}
\PYG{k+kp}{bb} \PYG{o}{=} \PYG{p}{[}\PYG{n}{b}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{xx} \PYG{o}{=} \PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{k+kp}{bb}\PYG{p}{;}

\PYG{c+c1}{// Set values}
\PYG{p}{[}\PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{l}\PYG{p}{]} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ l = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , b(u, 1) =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{uh}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{LagrangeMultipliers}.jpg}
\caption{Result}\label{\detokenize{example/finiteElement:id2}}\end{figure}


\section{Visualization}
\label{\detokenize{example/visualization:visualization}}\label{\detokenize{example/visualization:examplevisualization}}\label{\detokenize{example/visualization::doc}}

\subsection{Plot}
\label{\detokenize{example/visualization:plot}}\label{\detokenize{example/visualization:exampleplot}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot scalar and vectorial FE function}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{vh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{grey}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Compute a cut}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{// Value of uh at point (i/10., i/10.)}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// File for gnuplot}
    \PYG{k+kt}{ofstream} \PYG{n}{gnu}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{gnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Calls the gnuplot command, waits 5 seconds and generates a postscript plot (UNIX ONLY)}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{echo \PYGZsq{}plot }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ w l }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ pause 5 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set term postscript }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set output }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{gnuplot.eps}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ replot }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ quit\PYGZsq{} \textbar{} gnuplot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot1}.jpg}
\caption{First plot}\label{\detokenize{example/visualization:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot2}.jpg}
\caption{Second plot}\label{\detokenize{example/visualization:id2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot3}.png}
\caption{Gnuplot}\label{\detokenize{example/visualization:id3}}\end{subfigure}
\caption{Plot}

\end{figure}



\subsection{HSV}
\label{\detokenize{example/visualization:hsv}}\label{\detokenize{example/visualization:examplehsv}}\label{\detokenize{example/visualization:Plot}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// From: http://en.wikipedia.org/wiki/HSV\PYGZus{}color\PYGZus{}space}
\PYG{c+c1}{// The HSV (Hue, Saturation, Value) model defines a color space}
\PYG{c+c1}{// in terms of three constituent components:}
\PYG{c+c1}{// HSV color space as a color wheel}
\PYG{c+c1}{// Hue, the color type (such as red, blue, or yellow):}
\PYG{c+c1}{// Ranges from 0\PYGZhy{}360 (but normalized to 0\PYGZhy{}100\PYGZpc{} in some applications like here)}
\PYG{c+c1}{// Saturation, the \PYGZdq{}vibrancy\PYGZdq{} of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}
\PYG{c+c1}{// The lower the saturation of a color, the more \PYGZdq{}grayness\PYGZdq{} is present}
\PYG{c+c1}{// and the more faded the color will appear.}
\PYG{c+c1}{// Value, the brightness of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{colorhsv}\PYG{o}{=}\PYG{p}{[} \PYG{c+c1}{// Color hsv model}
    \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{c+c1}{// Dark blue}
    \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Blue}
    \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Magenta}
    \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Red}
    \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.5} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{c+c1}{// Light red}
    \PYG{p}{]}\PYG{p}{;}
 \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}\PYG{p}{;}

 \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}

 \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{colorhsv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{HSV}.jpg}
\caption{Result}\label{\detokenize{example/visualization:id4}}\end{figure}


\subsection{Medit}
\label{\detokenize{example/visualization:medit}}\label{\detokenize{example/visualization:examplemedit}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Old way}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u}\PYG{o}{*}\PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Saves u.points and u.faces file}
\PYG{c+c1}{// build a u.bb file for medit}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.bb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 1 1 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// Calls medit command}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmedit u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Cleans files on unix\PYGZhy{}like OS}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rm u.bb u.faces u.points}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Medit1}.jpg}
\caption{2D plot}\label{\detokenize{example/visualization:id5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Medit2}.jpg}
\caption{Plot with elevation}\label{\detokenize{example/visualization:id6}}\end{subfigure}
\caption{Medit}

\end{figure}



\subsection{Paraview}
\label{\detokenize{example/visualization:paraview}}\label{\detokenize{example/visualization:exampleparaview}}\label{\detokenize{example/visualization:Medit}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Order} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{DataName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.vtu}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Paraview}.jpg}
\caption{Result}\label{\detokenize{example/visualization:id7}}\end{figure}


\section{Algorithms \& Optimizations}
\label{\detokenize{example/algoOptimizations:algorithms-optimizations}}\label{\detokenize{example/algoOptimizations:examplealgorithmsoptimization}}\label{\detokenize{example/algoOptimizations::doc}}

\subsection{Algorithms}
\label{\detokenize{example/algoOptimizations:algorithms}}\label{\detokenize{example/algoOptimizations:examplealgorithms}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nerr} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{debugJ} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{debugdJ} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Algorithms tests}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{k+kp}{stop} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ stop = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{g}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{g}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{iter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{15}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// minimization of J(u) = 1./2 * sum (i+1) u\PYGZus{}i\PYGZca{}2 \PYGZhy{} b\PYGZus{}i}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{//J}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//the gradiant of J (this is a affine version (the RHS is in)}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ\PYGZhy{}b: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//the gradiant of the bilinear part of J (the RHS is remove)}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ0: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//erro calculation}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n}{error} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{matId} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{verb}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//verbosity}
    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//set right hand side}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//set initial gest}

    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Affine) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}15}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{k+kp}{stop}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Affine with stop) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Linear) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AffineGMRES (Affine) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGMRES (Linear) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NLCG: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{c+c1}{//warning: BFGS use a full matrix of size nxn (where n=u.n)}
    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{nerr}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// A real non linear test}
    \PYG{c+c1}{// Parameters}
    \PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.001}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
    \PYG{c+c1}{//f(u) = a*u + u\PYGZhy{}ln(1+u), f\PYGZsq{}(u) = a+ u/(1+u), f\PYGZsq{}\PYGZsq{}(u) = 1/(1+u)\PYGZca{}2}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{u}\PYG{o}{*}\PYG{n}{a}\PYG{o}{+}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{log}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{df}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{a}\PYG{o}{+}\PYG{n}{u}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{ddf}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Fespace}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//store df(\textbar{}nabla u\textbar{}\PYGZca{}2)}

    \PYG{c+c1}{// The functionnal J}
    \PYG{c+c1}{//J(u) = 1/2 int\PYGZus{}Omega f(\textbar{}nabla u\textbar{}\PYGZca{}2) \PYGZhy{} int\PYGZus{}Omega u b}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
        \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// The gradiant of J}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
        \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{au} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{;}

        \PYG{n}{u} \PYG{o}{=} \PYG{n}{au}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Problem}
    \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{alap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{amass}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{matrix} \PYG{n}{Amass} \PYG{o}{=} \PYG{n}{amass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{Alap}\PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Preconditionner}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{w} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{Alap}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array variable}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{int} \PYG{n}{conv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{conv} \PYG{o}{=} \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{C}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{conv}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

        \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Alap} \PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Restart with new preconditionner }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{conv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, eps =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution with NLCG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{sss}\PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{sss}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{nerr}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Algorithms1}.png}
\caption{Result \sphinxcode{\sphinxupquote{u}}}\label{\detokenize{example/algoOptimizations:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Algorithms2}.png}
\caption{\sphinxcode{\sphinxupquote{df(dx(u)*dx(u) + dy(u)*dy(u))}}}\label{\detokenize{example/algoOptimizations:id2}}\end{subfigure}
\caption{Algorithms}

\end{figure}



\subsection{CMAES variational inequality}
\label{\detokenize{example/algoOptimizations:cmaes-variational-inequality}}\label{\detokenize{example/algoOptimizations:examplecmaesvariationalinequality}}\label{\detokenize{example/algoOptimizations:Algorithms}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mf}{1000.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ou1}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loops}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}  \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
    \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

    \PYG{c+c1}{// Function which creates a vector of the search space type from}
    \PYG{c+c1}{// two finite element functions}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{FEFToSSP} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Splits a vector from the search space and fills}
    \PYG{c+c1}{// two finite element functions with it}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{SSPToFEF} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{.}\PYG{k+kr}{l2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
        \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
        \PYG{n}{val} \PYG{o}{+}\PYG{o}{=}  \PYG{n}{pena} \PYG{o}{*} \PYG{n}{IneqC}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{200} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{199}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{val} \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{al} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
        \PYG{n}{start}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
        \PYG{n}{FEFToSSP}\PYG{p}{(}\PYG{n}{ou1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{n+nf}{cmaes}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{stopMaxFunEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopTolX}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}3}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{initialStdDev}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.025}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{n}{al}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
    \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{best1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ou1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
    \PYG{n}{ou2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{CMAESVariationalInequality}.png}
\caption{Results}\label{\detokenize{example/algoOptimizations:id3}}\end{figure}


\subsection{IPOPT minimal surface \& volume}
\label{\detokenize{example/algoOptimizations:ipopt-minimal-surface-volume}}\label{\detokenize{example/algoOptimizations:exampleipoptminimalsurfacevolume}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{regtest}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{shapeswitch} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{40.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{treshold} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r0} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{r0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{e}\PYG{o}{*}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{rr}\PYG{o}{*}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Initial shape definition}
\PYG{c+c1}{//outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations}
\PYG{n}{Vh} \PYG{n}{startshape} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{lz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loop}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{lm} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{kkk} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{sin2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// A function which transform Th in 3d mesh (r=rho)}
    \PYG{c+c1}{//a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )}
    \PYG{c+c1}{//then displays the resulting mesh with medit}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{Plot3D} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kt}{string} \PYG{k+kp}{cmm}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{ffplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rhoo}\PYG{p}{;}
        \PYG{n}{rhoo}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
        \PYG{c+c1}{//mesh sTh = square(np, np/2, [2*pi*x, pi*y]);}
        \PYG{c+c1}{//fespace sVh(sTh, P1);}
        \PYG{c+c1}{//Vh rhoplot = rhoo;}
        \PYG{k}{try}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{mesh3} \PYG{n}{Sphere} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{ffplot}\PYG{p}{)}
                \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else}
                \PYG{n+nf}{medit}\PYG{p}{(}\PYG{k+kp}{cmm}\PYG{p}{,} \PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PLOT ERROR}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Surface computation}
    \PYG{c+c1}{//Maybe is it possible to use movemesh23 to have the surface function less complicated}
    \PYG{c+c1}{//However, it would not simplify the gradient and the hessian}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Area} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho4}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho(theta,phi) on [0,2pi]x[0,pi] \PYGZhy{} S=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{res}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else}
            \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shape\PYGZus{}evolution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{rho2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{varf} \PYG{n}{dArea} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{alpha}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{p}{;}

        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dArea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{matrix} \PYG{n}{hessianA}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{sqrtPsi3}\PYG{p}{,} \PYG{n}{C00}\PYG{p}{,} \PYG{n}{C01}\PYG{p}{,} \PYG{n}{C02}\PYG{p}{,} \PYG{n}{C11}\PYG{p}{,} \PYG{n}{C12}\PYG{p}{,} \PYG{n}{C22}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Vh} \PYG{n}{C0}\PYG{p}{,} \PYG{n}{C1}\PYG{p}{,} \PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sqrtPsi}\PYG{p}{;}
            \PYG{n}{C0} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
            \PYG{n}{C1} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C2} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C00} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C01} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C1}\PYG{p}{;}
            \PYG{n}{C02} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{C11} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C12} \PYG{o}{=} \PYG{n}{C1}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{C22} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{varf} \PYG{n}{d2Area} \PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}
                      \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{p}{)}
                \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi3} \PYG{o}{*} \PYG{p}{(}
                      \PYG{n}{C00}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C11}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C22}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{p}{)}
            \PYG{p}{)}
            \PYG{p}{;}
        \PYG{n}{hessianA} \PYG{o}{=} \PYG{n}{d2Area}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{hessianA}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Volume computation}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Volume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho3} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{dVolume}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dVolume}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{hessianV}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianVolume}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{hessianV} \PYG{o}{=} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{hessianV}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//if we want to use the volume as a constraint function}
    \PYG{c+c1}{//we must wrap it in some freefem functions returning the appropriate type}
    \PYG{c+c1}{//The lagrangian hessian also have to be wrapped since the Volume is not linear with}
    \PYG{c+c1}{//respect to rho, it will constribbute to the hessian.}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ipVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vol} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Volume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{k}{return} \PYG{n}{vol}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{mdV}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipGradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{GradVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mdV} \PYG{o}{=} \PYG{n}{dvol}\PYG{p}{;} \PYG{k}{return} \PYG{n}{mdV}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{HLagrangian}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipHessianLag} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{objfact}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{HLagrangian} \PYG{o}{=} \PYG{n}{objfact}\PYG{o}{*}\PYG{n}{HessianArea}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{HessianVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{HLagrangian}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//building struct for GradVolume}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gvi}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{gvj}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{gvi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{startshape}\PYG{p}{;} \PYG{c+c1}{//the starting value}
    \PYG{n}{Vh} \PYG{n}{ub} \PYG{o}{=} \PYG{l+m+mf}{1.e19}\PYG{p}{;} \PYG{c+c1}{//bounds definition}
    \PYG{n}{Vh} \PYG{n}{lb} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Gaussian} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{Y}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{theta}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{deltax2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{n}{X}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{deltay2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{Y}\PYG{o}{\PYGZhy{}}\PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{deltax2} \PYG{o}{+} \PYG{n}{deltay2}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{k+kp}{sigma}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{n}{disc1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{disc2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{lb} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{q} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{disc1}\PYG{p}{,} \PYG{n}{disc2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{Vobj} \PYG{o}{=} \PYG{n}{Volume}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{Vnvc} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object\PYGZus{}inside}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{clb} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{cub} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{alpha}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vobj} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{Vnvc}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Call IPOPT}
    \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{Area}\PYG{p}{,} \PYG{n}{GradArea}\PYG{p}{,} \PYG{n}{ipHessianLag}\PYG{p}{,} \PYG{n}{ipVolume}\PYG{p}{,} \PYG{n}{ipGradVolume}\PYG{p}{,}
            \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{n}{checkindex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{kkk}\PYG{o}{\PYGZlt{}}\PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{?} \PYG{l+m+mi}{40}\PYG{o}{:}\PYG{l+m+mi}{150}\PYG{p}{,}
            \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{kkk}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lm}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{,} \PYG{n}{structjacc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{gvi}\PYG{p}{,}\PYG{n}{gvj}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IPOPT: res =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shape\PYGZus{}at\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{GradArea}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ShapeGradient}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}
            \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{startshape} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{;}
        \PYG{n}{uz} \PYG{o}{=} \PYG{n}{uz}\PYG{p}{;}
        \PYG{n}{lz} \PYG{o}{=} \PYG{n}{lz}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{regtest} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{IPOPTMinimalSurfaceVolume}.png}
\caption{Mesh}\label{\detokenize{example/algoOptimizations:id4}}\end{figure}


\subsection{CMAES MPI variational inequality}
\label{\detokenize{example/algoOptimizations:cmaes-mpi-variational-inequality}}\label{\detokenize{example/algoOptimizations:examplecmaesmpivariationalinequality}}
Command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{4} CMAESMPIVariationalInequality.edp \PYGZhy{}glut ffglut
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mpi\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ou1}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{;}

\PYG{c+c1}{// Mehs adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
    \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

    \PYG{c+c1}{//Function which create a vector of the search space type from}
    \PYG{c+c1}{//two finite element functions}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{FEFToSSP} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//Function spliting a vector from the search space and fills}
    \PYG{c+c1}{//two finite element functions with it}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{SSPToFEF} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{.}\PYG{k+kr}{l2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
        \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
        \PYG{n}{val} \PYG{o}{+}\PYG{o}{=}  \PYG{n}{pena} \PYG{o}{*} \PYG{n}{IneqC}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{val} \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{al}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
        \PYG{n}{start}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
        \PYG{n}{FEFToSSP}\PYG{p}{(}\PYG{n}{ou1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{n}{cmaesMPI}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{stopMaxFunEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopTolX}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}4}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{initialStdDev}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.025}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{n}{al}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
    \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{best1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ou1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
    \PYG{n}{ou2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{CMAESMPIVariationalInequality}.png}
\caption{Result}\label{\detokenize{example/algoOptimizations:id5}}\end{figure}


\section{Parallelization}
\label{\detokenize{example/parallelization:parallelization}}\label{\detokenize{example/parallelization:exampleparallelization}}\label{\detokenize{example/parallelization::doc}}

\subsection{MPI-GMRES 2D}
\label{\detokenize{example/parallelization:mpi-gmres-2d}}\label{\detokenize{example/parallelization:examplempigmres2d}}
To launch this script, use for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{12} MPIGMRES2D.edp \PYGZhy{}d \PYG{l+m}{1} \PYGZhy{}k \PYG{l+m}{1} \PYGZhy{}gmres \PYG{l+m}{2} \PYGZhy{}n \PYG{l+m}{50}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//usage :}
\PYG{c+c1}{//ff\PYGZhy{}mpirun [mpi parameter] MPIGMRES2d.edp [\PYGZhy{}glut ffglut] [\PYGZhy{}n N] [\PYGZhy{}k K] [\PYGZhy{}d D] [\PYGZhy{}ns] [\PYGZhy{}gmres [0\textbar{}1]}
\PYG{c+c1}{//arguments:}
\PYG{c+c1}{//\PYGZhy{}glut ffglut : to see graphicaly the process}
\PYG{c+c1}{//\PYGZhy{}n N: set the mesh cube split NxNxN}
\PYG{c+c1}{//\PYGZhy{}d D: set debug flag D must be one for mpiplot}
\PYG{c+c1}{//\PYGZhy{}k K: to refined by K all element}
\PYG{c+c1}{//\PYGZhy{}ns: remove script dump}
\PYG{c+c1}{//\PYGZhy{}gmres}
\PYG{c+c1}{//0: use iterative schwarz algo.}
\PYG{c+c1}{//1: Algo GMRES on residu of schwarz algo}
\PYG{c+c1}{//2: DDM GMRES}
\PYG{c+c1}{//3: DDM GMRES with coarse grid preconditionner (Good one)}

\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPICG}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{metis}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIplot.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIGMRESmacro.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//more safe seach algo (warning can be very expensive in case of lot of ouside point)}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kr}{version} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{3.11}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//need at least v3.11}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ttt}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ittt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{settt} \PYG{p}{\PYGZob{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{mpiWtime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}

\PYG{c+c1}{// Arguments}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{vdebug} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ksplit} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}k}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nloc} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sff} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{gmres} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}gmres}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{dplot} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nC} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}N}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nloc}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{verbosity}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ARGV: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{p}{(}\PYG{k+kr}{mpirank}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{verbosity}\PYG{p}{)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ vdebug: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vdebug} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, kspilt }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nloc }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, sff }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{withplot} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{withmetis} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{RAS} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sPk} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{P2\PYGZhy{}2gd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{n+nc}{P2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{sizeoverlaps} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//size of overlap}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l111} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//mesh labels}

\PYG{c+c1}{// MPI function}
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{plotMPIall}\PYG{p}{(}\PYG{k+kt}{mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{cm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
        \PYG{n}{PLOTMPIALL}\PYG{p}{(}\PYG{k+kt}{mesh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{cm}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// MPI}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//trick : make a no split mpiWorld}

\PYG{k+kt}{int} \PYG{n}{npart} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//total number of partion}
\PYG{k+kt}{int} \PYG{n}{ipart} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//current partition number}

\PYG{k+kt}{int} \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Number of part with intersection (a jpart) with ipart without ipart}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{jpart}\PYG{p}{(}\PYG{n}{npart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//list of jpart}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{ipart}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Final N = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit}\PYG{o}{*}\PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nloc = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, split = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{settt}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thg} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nloc}\PYG{p}{,} \PYG{n}{nloc}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l111}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{ThC} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nC}\PYG{p}{,} \PYG{n}{nC}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l111}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// Coarse mesh}

\PYG{k+kt}{mesh} \PYG{n}{Thi}\PYG{p}{,} \PYG{n}{Thin}\PYG{p}{;} \PYG{c+c1}{//with overlap, without olverlap}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Phg}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Phg} \PYG{n}{part}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vhg}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhg} \PYG{n}{unssd}\PYG{p}{;} \PYG{c+c1}{//boolean function: 1 in the subdomain, 0 elswhere}

\PYG{k+kt}{fespace} \PYG{n+nf}{VhC}\PYG{p}{(}\PYG{n}{ThC}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// of the coarse problem}

\PYG{c+c1}{// Partitioning}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nupart}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nupart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{npart} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{metisdual}\PYG{p}{(}\PYG{n}{nupart}\PYG{p}{,} \PYG{n}{Thg}\PYG{p}{,} \PYG{n}{npart}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nupart}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nupart}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{part}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{nupart}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{withplot} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{part}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dual}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Overlapping partition}
\PYG{n}{Phg} \PYG{n}{suppi} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{part}\PYG{o}{\PYGZhy{}}\PYG{n}{ipart}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{n}{Thin} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{suppi}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// non\PYGZhy{}overlapping mesh, interfaces have label 10}
\PYG{k+kt}{int} \PYG{n}{nnn} \PYG{o}{=} \PYG{n}{sizeoverlaps}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{c+c1}{// to be sure}
\PYG{n}{AddLayers}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{suppi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nnn}\PYG{p}{,} \PYG{n}{unssd}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//see above! suppi and unssd are modified}
\PYG{n}{unssd}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{n}{nnn}\PYG{p}{;} \PYG{c+c1}{//to put value nnn a 0}
\PYG{k+kt}{real} \PYG{n}{nnn0} \PYG{o}{=} \PYG{n}{nnn} \PYG{o}{\PYGZhy{}} \PYG{n}{sizeoverlaps} \PYG{o}{+} \PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{n}{Thi} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{unssd}\PYG{o}{\PYGZgt{}}\PYG{n}{nnn0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//overlapping mesh, interfaces have label 10}

\PYG{n}{settt}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n}{Vhi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{npij} \PYG{o}{=} \PYG{n}{npart}\PYG{p}{;}
\PYG{n}{Vhi}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pij}\PYG{p}{(}\PYG{n}{npij}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local partition of unit + pii}
\PYG{n}{Vhi} \PYG{n}{pii}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{nnn1} \PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    construction of the partition of the unit,}
\PYG{c+cm}{    let phi\PYGZus{}i P1 FE function 1 on Thin and zero ouside of Thi and positive}
\PYG{c+cm}{    the partition is build with}
\PYG{c+cm}{    p\PYGZus{}i = phi\PYGZus{}i/ \PYGZbs{}sum phi\PYGZus{}i}

\PYG{c+cm}{    to build the partition of one domain i}
\PYG{c+cm}{    we nned to find all j such that supp(phi\PYGZus{}j) \PYGZbs{}cap supp(phi\PYGZus{}j) is not empty}
\PYG{c+cm}{    \PYGZlt{}=\PYGZgt{} int phi\PYGZus{}j}
\PYG{c+cm}{    */}
    \PYG{c+c1}{//build a local mesh of thii such that all computation of the unit partition are}
    \PYG{c+c1}{//exact in thii}
    \PYG{k+kt}{mesh} \PYG{n}{Thii} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{unssd}\PYG{o}{\PYGZgt{}}\PYG{n}{nnn1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//overlapping mesh, interfaces have label 10}

    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//find all j mes (supp(p\PYGZus{}j) cap supp(p\PYGZus{}i)) \PYGZgt{}0}
        \PYG{c+c1}{//compute all phi\PYGZus{}j on Thii}
        \PYG{c+c1}{//remark: supp p\PYGZus{}i include in Thi}

        \PYG{c+c1}{// Fespace}
        \PYG{k+kt}{fespace} \PYG{n}{Phii}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{fespace} \PYG{n+nf}{Vhii}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vhi} \PYG{n}{sumphi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{Vhii} \PYG{n}{phii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{n}{jpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{nlayer} \PYG{o}{=} \PYG{n}{RAS} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{n}{sizeoverlaps}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nlayer = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nlayer} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n}{pii} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{unssd}\PYG{o}{\PYGZhy{}}\PYG{n}{nnn}\PYG{o}{+}\PYG{n}{nlayer}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nlayer}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pii}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 0000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ summ 0000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{n}{epsmes} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{Thii}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{npart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ipart}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{Phii} \PYG{n}{suppii} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{part}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{suppii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{AddLayers}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n}{suppii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nlayer}\PYG{p}{,} \PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{real} \PYG{n}{interij} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{interij} \PYG{o}{\PYGZgt{}} \PYG{n}{epsmes}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                    \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
                        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ***** }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
                    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
                        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ j = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
                        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sum j = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{njpart}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{jpart}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ number of jpart }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{njpart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
                \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Thii is remove here}
\PYG{c+c1}{// end of the construction of the local partition of the unity ...}
\PYG{c+c1}{// on Thi}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build partition}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Computation of number of intersection}
\PYG{c+c1}{//here pii and the pij is the local partition of the unit on}
\PYG{c+c1}{//Thi (mesh with overlap)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{dplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ j=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{j}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Partition of the unity on Thi}
\PYG{c+c1}{//computation of message}
\PYG{c+c1}{//all j \PYGZgt{} we have to receive}
\PYG{c+c1}{//data on intersection of the support of pij[0] and pij[j]}
\PYG{n}{settt}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
    \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pi\PYGZus{}i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aThij}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Pii}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M of send to j}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M to recv from j}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{Thi}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whij}\PYG{p}{(}\PYG{n}{Thij}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//}

\PYG{c+c1}{//construction of the mesh intersect i,j part}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//mesh of the supp of pij}

\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{ksplit}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Thi} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{ksplit}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{settt}

\PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build mesh intersection}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Construction of transfert matrix}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Whi} \PYG{n}{wpii} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{;}
    \PYG{n}{Pii} \PYG{o}{=} \PYG{n}{wpii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whji \PYGZlt{}\PYGZhy{} Whi}
        \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n}{I}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//Whi \PYGZhy{}\PYGZgt{} s Whij}
        \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whji \PYGZhy{}\PYGZgt{} Whi}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{p}{\PYGZob{}}\PYG{n}{Whi} \PYG{n}{uuu}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{Whij} \PYG{n}{vvv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{I}\PYG{o}{*}\PYG{n}{uuu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZpc{}\PYGZpc{}\PYGZpc{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZob{}}\PYG{n}{Whi} \PYG{n}{uuu}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{Whij} \PYG{n}{vvv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{uuu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZsh{}\PYGZsh{}\PYGZsh{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build transfert matrix}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Allocate array of send and recv data}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{)} \PYG{c+c1}{//initU(n, Vh, Th, aTh, U)}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End init data for send/revc}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{Whi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{Update}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ui}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{vi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n}{Usend}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{n}{SendRecvUV}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{jpart}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n}{Pii}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n}{vi} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Vrecv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{return} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Definition of the Problem}
\PYG{k+kt}{func} \PYG{n}{G} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{F} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{varf} \PYG{n}{vBC} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{F}\PYG{o}{*}\PYG{n}{V}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbC} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{ThC}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbon} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbon10only} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//remark the order is important we want 0 part on 10 and 1}

\PYG{k+kt}{matrix} \PYG{n}{Ai} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{AC}\PYG{p}{,} \PYG{n}{Rci}\PYG{p}{,} \PYG{n}{Pci}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{AC} \PYG{o}{=} \PYG{n}{vPbC}\PYG{p}{(}\PYG{n}{VhC}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Pci} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Rci} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG10} \PYG{o}{=} \PYG{n}{vPbon10only}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG} \PYG{o}{=} \PYG{n}{vPbon}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bi}\PYG{o}{=}\PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{kiter} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{CoarseSolve}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{V}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{,} \PYG{k+kt}{mpiComm} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//solving the coarse probleme}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uc}\PYG{p}{(}\PYG{n}{Rci}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{Rci}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiSUM}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{AC}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{Bc}\PYG{p}{;}
    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Uc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{*}\PYG{n}{Uc}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.}\PYG{o}{:} \PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//remove internal boundary}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CoarseSolve}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}C2*Uo}
    \PYG{n}{U} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//U = (I\PYGZhy{}A C2) Uo}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{U} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{// (C1( I \PYGZhy{}A C2) Uo}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{U} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{U}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Whi} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//verification}
    \PYG{n}{Whi} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{settt}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vBC}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set u with tgv BC value}

\PYG{k+kt}{real} \PYG{n}{epss} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rgmres} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPIAffineGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi}\PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJC}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{c+c1}{//algo Shwarz for demo}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

        \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
            \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aa} \PYG{o}{=} \PYG{p}{[}\PYG{k+kp}{err}\PYG{p}{,} \PYG{n}{umax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{k+kp}{errg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{umaxg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{errg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ u. max }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{umaxg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{errg} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
    \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u\PYGZhy{}final}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{settt}

\PYG{k+kt}{real} \PYG{k+kp}{errg} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{umaxg}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{,} \PYG{n}{umaxg}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aa} \PYG{o}{=} \PYG{p}{[}\PYG{n}{umax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{errg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{umax global = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Wtime = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{sff} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{ff}\PYG{p}{(}\PYG{n}{sff}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ++++ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ k=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ n= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sizeoverlaps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ it= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ittt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{epss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{    1 mpirank}
\PYG{c+cm}{    2 mpisize}
\PYG{c+cm}{    3 ksplit}
\PYG{c+cm}{    4 nloc}
\PYG{c+cm}{    5 sizeoverlaps}
\PYG{c+cm}{    6 kiter}
\PYG{c+cm}{    7 mesh \PYGZam{} part build}
\PYG{c+cm}{    8 build the partion}
\PYG{c+cm}{    9 build mesh, transfere , and the fine mesh ..}
\PYG{c+cm}{    10 build the matrix, the trans matrix, factorizatioon}
\PYG{c+cm}{    11 GMRES}
\PYG{c+cm}{    */}

    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sPk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sizeoverlaps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ittt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{epss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{gmres} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MPIGMRES2D}.png}
\caption{Results}\label{\detokenize{example/parallelization:id1}}\end{figure}


\subsection{MPI-GMRES 3D}
\label{\detokenize{example/parallelization:mpi-gmres-3d}}\label{\detokenize{example/parallelization:examplempigmres3d}}
\begin{sphinxadmonition}{note}{\label{example/parallelization:index-0}Todo:}
todo
\end{sphinxadmonition}


\subsection{Direct solvers}
\label{\detokenize{example/parallelization:direct-solvers}}\label{\detokenize{example/parallelization:exampledirectsolvers}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}SuperLU\PYGZus{}DIST\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kr}{default} \PYG{k+kp}{solver}\PYG{o}{:} \PYG{k+kt}{real}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{SuperLU\PYGZus{}DIST}\PYG{p}{,} \PYG{k+kt}{complex} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}pastix\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} pastix, complex \PYGZhy{}\PYGZgt{} MUMPS}

\PYG{c+c1}{// Solving with pastix}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffpastix\PYGZus{}iparm\PYGZus{}dparm.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with SuperLU\PYGZus{}DIST}
\PYG{n}{realdefaulttoSuperLUdist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffsuperlu\PYGZus{}dist\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with MUMPS}
\PYG{n}{defaulttoMUMPS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solving solution}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Solver MUMPS}
\label{\detokenize{example/parallelization:solver-mumps}}\label{\detokenize{example/parallelization:examplesolvermumps}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ICNTL}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//declaration of ICNTL parameter for MUMPS}

\PYG{c+c1}{//get value of ICNTL from file}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{n}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{string} \PYG{n}{line}\PYG{p}{;}
    \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{ff} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ICNTL}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]}\PYG{p}{;}
        \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ICNTL}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Given data of MUMPS solver in array lparams(SYM, PAR, ICNTL)}
\PYG{c+c1}{// There is no symmetric storage for a matrix associated with a sparse solver.}
\PYG{c+c1}{// Therefore, the matrix will be considered unsymmetric for parallel sparse solver even if symmetric.}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{int} \PYG{n}{SYM} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{PAR} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}
            \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}
        \PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Construction of integer parameter for MUMPS}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{MumpsLParams}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{SYM}\PYG{p}{;}
    \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PAR}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{n}{ii}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ICNTL}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//ICNTL begin with index 0 here}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{MumpsLParams}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//we take the default value for CNTL MUMPS parameter}

    \PYG{c+c1}{// Solve}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Read parameter of MUMPS solver in file ffmumps\PYGZus{}fileparam.txt}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}
            \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}
        \PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7000}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Solver superLU\_DIST}
\label{\detokenize{example/parallelization:solver-superlu-dist}}\label{\detokenize{example/parallelization:examplesolversuperludist}}
\begin{sphinxadmonition}{note}{\label{example/parallelization:index-1}Todo:}
write code (SuperLU\_DIST seems to have a bug)
\end{sphinxadmonition}


\subsection{Solver PaStiX}
\label{\detokenize{example/parallelization:solver-pastix}}\label{\detokenize{example/parallelization:examplesolverpastix}}
\begin{sphinxadmonition}{note}{\label{example/parallelization:index-2}Todo:}
write code (PaStiX seems to have a bug)
\end{sphinxadmonition}


\section{Developers}
\label{\detokenize{example/developers:developers}}\label{\detokenize{example/developers:exampledevelopers}}\label{\detokenize{example/developers::doc}}

\subsection{FFT}
\label{\detokenize{example/developers:fft}}\label{\detokenize{example/developers:examplefft}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{dfft}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{l+m+mi}{32}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ny} \PYG{o}{=} \PYG{l+m+mi}{16}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{N} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{*}\PYG{n}{ny}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{c+c1}{//warning: the fourier space is not exactly the unit square due to periodic condition}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{nx}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{/}\PYG{n}{ny}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//warning: the numbering of the vertices (x,y) is}
\PYG{c+c1}{//given by i = x/nx + nx*y/ny}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{u} \PYG{o}{=} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w} \PYG{o}{=} \PYG{n}{f1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ur}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{;}

\PYG{c+c1}{// FFT}
\PYG{c+c1}{//in dfft the matrix n, m is in row\PYGZhy{}major order and array n, m is}
\PYG{c+c1}{//store j + m*i (the transpose of the square numbering)}
\PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}u\textbar{}\textbar{}\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{infty }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{N}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}u\textbar{}\textbar{}\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{infty }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{ur} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ur}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{w} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{diff = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Other example}
\PYG{c+c1}{//FFT Lapacian}
\PYG{c+c1}{//\PYGZhy{}\PYGZbs{}Delta u = f with biperiodic condition}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{13.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the exact solution}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{ff} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{fhat}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{wij}\PYG{p}{;}

\PYG{c+c1}{// FFT}
\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//warning in fact we take mode between \PYGZhy{}nx/2, nx/2 and \PYGZhy{}ny/2, ny/2}
\PYG{c+c1}{//thanks to the operator ?:}
\PYG{n}{wij} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(} \PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{o}{?}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nl}{nx}\PYG{o}{:}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{nx}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{o}{?}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nl}{ny}\PYG{o}{:}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{ny}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;} \PYG{c+c1}{//to remove div / 0}
\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{/}\PYG{o}{=} \PYG{k+kt}{complex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ur} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the solution}
\PYG{n}{w} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the exact solution}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{ur}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{ur}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{fftwplan} \PYG{n}{p1} \PYG{o}{=} \PYG{n}{plandfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fftwplan} \PYG{n}{p2} \PYG{o}{=} \PYG{n}{plandfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ccc} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ny = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ny} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{map}\PYG{p}{(}\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{n}{ccc}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{wij}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wij}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Complex}
\label{\detokenize{example/developers:complex}}\label{\detokenize{example/developers:examplecomplex}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.45}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{5.33}\PYG{p}{;}
\PYG{k+kt}{complex} \PYG{n}{z1} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{,} \PYG{n}{z2} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{string} \PYG{n+nf}{pc}\PYG{p}{(}\PYG{k+kt}{complex} \PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{string} \PYG{n}{r} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{imag}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{r} \PYG{o}{=} \PYG{n}{r} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{r} \PYG{o}{+} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{i)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{string} \PYG{n+nf}{toPolar}\PYG{p}{(}\PYG{k+kt}{complex} \PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{c+c1}{//abs(z) + \PYGZdq{}*(cos(\PYGZdq{} + arg(z) + \PYGZdq{})+i*sin(\PYGZdq{} + arg(z) + \PYGZdq{}))\PYGZdq{};}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Standard output of the complex }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ is the pair: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{z1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{+}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ * }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{*}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ / }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{/}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Real part of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Imaginary part of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abs(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Polar coordinates of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{toPolar}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{de Moivre formula: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZca{}3 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{toPolar}\PYG{p}{(}\PYG{n}{z2}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ and polar(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n+nf}{polar}\PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Conjugate of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n+nf}{conj}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZca{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZca{}}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

Output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Standard output of the complex \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} is the pair: \PYG{o}{(}\PYG{l+m}{2}.45,5.33\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} + \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{4}.9+6.74421i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYGZhy{} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{0}+3.91579i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} * \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYGZhy{}1.53526+16.5233i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} / \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{1}.692+1.19883i\PYG{o}{)}
Real part of \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{2}.45
Imaginary part of \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}.33
abs\PYG{o}{(}\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}.86612
Polar coordinates of \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=}
de Moivre formula: \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)}\PYGZca{}3 \PYG{o}{=}
 and polar\PYG{o}{(}\PYG{l+m}{2}.82887, \PYG{l+m}{0}.523509\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)}
Conjugate of \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2}.45\PYGZhy{}1.41421i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYGZca{} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{8}.37072\PYGZhy{}12.7078i\PYG{o}{)}
\end{sphinxVerbatim}


\subsection{String}
\label{\detokenize{example/developers:string}}\label{\detokenize{example/developers:examplestring}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Concatenation}
\PYG{k+kt}{string} \PYG{n}{tt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto1}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} 77}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Append}
\PYG{k+kt}{string} \PYG{n}{t1} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0123456789}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{t1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdefghijk\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Sub string}
\PYG{k+kt}{string} \PYG{n}{t55} \PYG{o}{=} \PYG{n}{t1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{14}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.find(abc) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.rfind(abc) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{rfind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.find(abc, 10) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.ffind(abc, 10) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{rfind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.length = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{length} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t55 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t55} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{tt} \PYG{o}{=} toto11 \PYGZhy{}\PYGZhy{} \PYG{l+m}{77}
\PYG{n+nv}{t1} \PYG{o}{=} 0123abcdefghijk\PYGZhy{}456789
t1.find\PYG{o}{(}abc\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.rfind\PYG{o}{(}abc\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.find\PYG{o}{(}abc, \PYG{l+m}{10}\PYG{o}{)} \PYG{o}{=} \PYGZhy{}1
t1.ffind\PYG{o}{(}abc, \PYG{l+m}{10}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.length \PYG{o}{=} \PYG{l+m}{22}
\PYG{n+nv}{t55} \PYG{o}{=} abcdefghijk
\end{sphinxVerbatim}


\subsection{Elementary function}
\label{\detokenize{example/developers:elementary-function}}\label{\detokenize{example/developers:exampleelementaryfunction}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{phix}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{phiy}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{phix}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{phiy}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{ElementaryFunction}.png}
\caption{Mesh}\label{\detokenize{example/developers:id1}}\end{figure}


\subsection{Array}
\label{\detokenize{example/developers:array}}\label{\detokenize{example/developers:examplearray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{tab}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tab1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2 array of 10 real}
\PYG{c+c1}{//real[int] tab2; //bug: array with no size}

\PYG{n}{tab} \PYG{o}{=} \PYG{l+m+mf}{1.03}\PYG{p}{;} \PYG{c+c1}{//set all the array to 1.03}
\PYG{n}{tab}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.15}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tab: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{tab}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the size of array tab to 12 with preserving first value}
\PYG{n}{tab}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{:}\PYG{l+m+mi}{11}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{3.14}\PYG{p}{;} \PYG{c+c1}{//set values 10 \PYGZam{} 11}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resized tab: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{tab}\PYG{p}{.}\PYG{n+nf}{sort} \PYG{p}{;} \PYG{c+c1}{//sort the array tab}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sorted tab:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{tt}\PYG{p}{;} \PYG{c+c1}{//array with string index}
\PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{o}{+}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{c} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1 : d[i] = a[i] ? b[i] : c[i]}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ d = ( a ? b : c ) is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{n}{c} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? 1 : c[i]}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? b[i] : 0}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? 0 : 1}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ii}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n+nf}{d}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set array ii to 0, 1, ..., d.n\PYGZhy{}1}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//set d to \PYGZhy{}1, \PYGZhy{}2, ..., \PYGZhy{}5}

\PYG{n+nf}{sort}\PYG{p}{(}\PYG{n+nf}{d}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sort array d and ii in parallel}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{d: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ii: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A1(2:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A2(2:3:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{A1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1:2:5 =\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A1(2:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A2(2:3:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{A1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{:}\PYG{l+m+mf}{0.5}\PYG{o}{:}\PYG{l+m+mf}{3.999}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.:0.5:3.999 =\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n+nl}{i}\PYG{o}{:}\PYG{l+m+mf}{10.}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{:}\PYG{l+m+mf}{3.}\PYG{o}{:}\PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1(2.+0i:10.+0i): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A2(2.:3.:10.)= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{A2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1.re real part array: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1}\PYG{p}{.}\PYG{k+kr}{re} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
    \PYG{c+c1}{// he real part array of the complex array}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1.im imag part array: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1}\PYG{p}{.}\PYG{k+kr}{im} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
    \PYG{c+c1}{//the imaginary part array of the complex array}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Integer array operators}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a + a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b += a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b += 2*a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b /= 2: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{p}{.}\PYG{o}{*}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{// same as b = b .* a}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b .*= a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{p}{.}\PYG{o}{/}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//same as b = b ./ a}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b ./= a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a + b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = 2*a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a \PYGZhy{} 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a \PYGZhy{}b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{p}{.}\PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a .* b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{p}{.}\PYG{o}{/} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a ./ b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = 2 * b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{b} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = b * 2: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//this operator do not exist}
    \PYG{c+c1}{//c = b/2;}
    \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}c = b / 2: \PYGZdq{} \PYGZlt{}\PYGZlt{} c \PYGZlt{}\PYGZlt{} endl;}

    \PYG{c+c1}{//Array methods}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}a\textbar{}\textbar{}\PYGZus{}1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{l1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}a\textbar{}\textbar{}\PYGZus{}2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\textbar{}\textbar{}a\textbar{}\textbar{}\PYGZus{}infty = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a[ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a[ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a\PYGZsq{} * a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a quantile 0.2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{quantile}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//Array mapping}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} b.n; i++) if (I[i] \PYGZgt{}= 0) b[i] = a[I[i]];}
    \PYG{n}{c}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} I.n; i++) if (I[i] \PYGZgt{}= 0) C(I[i]) = a[i];}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a(I) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c(I) = a }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} I.n; i++) if (I[i] \PYGZgt{}= 0) C(I[i]) += a[i];}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a(I) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c(I) = a }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Array versus matrix}
    \PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{cb} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{J} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//set all the matrix}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{c+c1}{//the full line 2}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{o}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//the full column 1}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kr}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//set the column 2}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//set the line 1 from 0 to 2}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//outer product}
    \PYG{n}{C} \PYG{o}{=} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{n}{C} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{n}{C} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{n}{i} \PYG{o}{*} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{C} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//this transforms an array into a sparse matrix}
    \PYG{k+kt}{matrix} \PYG{k+kp}{B}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B(i, j) = A(I(i), J(j))}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B(I(i), J(j)) = A(i,j)}

    \PYG{c+c1}{//outer product}
    \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{b} \PYG{o}{*} \PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(i)*c(j)}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(i)*c(j)}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(I(i))*c(J(j))}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//outer product B(I(i), J(j)) = b(i)*c(j)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{B = (3.*b*c\PYGZsq{})(I\PYGZca{}\PYGZhy{}1,J\PYGZca{}\PYGZhy{}1) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//row and column of the maximal coefficient of A}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{,} \PYG{n}{jj}\PYG{p}{;}
    \PYG{n}{ijmax}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{,} \PYG{n}{jj}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{i} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{;}
    \PYG{n}{j} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{jmax}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Max }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//row and column of the minimal coefficient of A}
    \PYG{n}{ijmin}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ii} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{;}
    \PYG{n}{jj} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{jmin}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jj} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output os this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
tab: \PYG{l+m}{10}
    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03

min: \PYG{l+m}{1}.03
max: \PYG{l+m}{2}.15
sum: \PYG{l+m}{11}.42
resized tab: \PYG{l+m}{12}
    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{3}.14    \PYG{l+m}{3}.14
sorted tab:12
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15
    \PYG{l+m}{3}.14    \PYG{l+m}{3}.14
tt\PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}a\PYGZdq{}}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}
tt\PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}+\PYGZdq{}}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}.5
 \PYG{n+nv}{d} \PYG{o}{=} \PYG{o}{(} a ? b : c \PYG{o}{)} is \PYG{l+m}{5}
      \PYG{l+m}{2}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{2}   \PYG{l+m}{2}

d: \PYG{l+m}{5}
     \PYGZhy{}5  \PYGZhy{}4  \PYGZhy{}3  \PYGZhy{}2  \PYGZhy{}1

ii: \PYG{l+m}{5}
      \PYG{l+m}{4}   \PYG{l+m}{3}   \PYG{l+m}{2}   \PYG{l+m}{1}   \PYG{l+m}{0}

A1\PYG{o}{(}\PYG{l+m}{2}:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
A2\PYG{o}{(}\PYG{l+m}{2}:3:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
\PYG{l+m}{1}:2:5 \PYG{o}{=}\PYGZgt{} \PYG{l+m}{3}
      \PYG{l+m}{1}   \PYG{l+m}{3}   \PYG{l+m}{5}
A1\PYG{o}{(}\PYG{l+m}{2}:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
A2\PYG{o}{(}\PYG{l+m}{2}:3:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
\PYG{l+m}{1}.:0.5:3.999 \PYG{o}{=}\PYGZgt{} \PYG{l+m}{6}
      \PYG{l+m}{1} \PYG{l+m}{1}.5   \PYG{l+m}{2} \PYG{l+m}{2}.5   \PYG{l+m}{3}
    \PYG{l+m}{3}.5
 A1\PYG{o}{(}\PYG{l+m}{2}.+0i:10.+0i\PYG{o}{)}: \PYG{l+m}{9}
    \PYG{o}{(}\PYG{l+m}{2},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{3},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{4},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{5},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{6},0\PYG{o}{)}
    \PYG{o}{(}\PYG{l+m}{7},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{8},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{9},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{10},0\PYG{o}{)}
 A2\PYG{o}{(}\PYG{l+m}{2}.:3.:10.\PYG{o}{)}\PYG{o}{=} \PYG{l+m}{3}
    \PYG{o}{(}\PYG{l+m}{2},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{5},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{8},0\PYG{o}{)}
 A1.re real part array: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
 A1.im imag part array: \PYG{l+m}{9}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
a: \PYG{l+m}{5}
      \PYG{l+m}{2}   \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{4}

\PYG{n+nv}{b} \PYG{o}{=} a + a: \PYG{l+m}{5}
      \PYG{l+m}{4}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{8}   \PYG{l+m}{8}

\PYG{n+nv}{b} \PYG{o}{+=} a: \PYG{l+m}{5}
      \PYG{l+m}{6}   \PYG{l+m}{3}   \PYG{l+m}{6}  \PYG{l+m}{12}  \PYG{l+m}{12}

\PYG{n+nv}{b} \PYG{o}{+=} \PYG{l+m}{2}*a: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

 b /\PYG{o}{=} \PYG{l+m}{2}: \PYG{l+m}{5}
      \PYG{l+m}{5} \PYG{l+m}{2}.5   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{10}

b .*\PYG{o}{=} a: \PYG{l+m}{5}
     \PYG{l+m}{10} \PYG{l+m}{2}.5  \PYG{l+m}{10}  \PYG{l+m}{40}  \PYG{l+m}{40}

b ./\PYG{o}{=} a: \PYG{l+m}{5}
      \PYG{l+m}{5} \PYG{l+m}{2}.5   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{10}

\PYG{n+nv}{c} \PYG{o}{=} a + b: \PYG{l+m}{5}
      \PYG{l+m}{7} \PYG{l+m}{3}.5   \PYG{l+m}{7}  \PYG{l+m}{14}  \PYG{l+m}{14}

\PYG{n+nv}{c} \PYG{o}{=} \PYG{l+m}{2}*a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{24}  \PYG{l+m}{12}  \PYG{l+m}{24}  \PYG{l+m}{48}  \PYG{l+m}{48}

\PYG{n+nv}{c} \PYG{o}{=} a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{22}  \PYG{l+m}{11}  \PYG{l+m}{22}  \PYG{l+m}{44}  \PYG{l+m}{44}

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{18}   \PYG{l+m}{9}  \PYG{l+m}{18}  \PYG{l+m}{36}  \PYG{l+m}{36}

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a \PYGZhy{} 4b: \PYG{l+m}{5}
    \PYGZhy{}22 \PYGZhy{}11 \PYGZhy{}22 \PYGZhy{}44 \PYGZhy{}44

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a \PYGZhy{}b: \PYG{l+m}{5}
     \PYGZhy{}7 \PYGZhy{}3.5     \PYGZhy{}7 \PYGZhy{}14 \PYGZhy{}14

\PYG{n+nv}{c} \PYG{o}{=} a .* b: \PYG{l+m}{5}
     \PYG{l+m}{10} \PYG{l+m}{2}.5  \PYG{l+m}{10}  \PYG{l+m}{40}  \PYG{l+m}{40}

\PYG{n+nv}{c} \PYG{o}{=} a ./ b: \PYG{l+m}{5}
    \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4

\PYG{n+nv}{c} \PYG{o}{=} \PYG{l+m}{2} * b: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

\PYG{n+nv}{c} \PYG{o}{=} b * \PYG{l+m}{2}: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

\PYG{o}{\textbar{}\textbar{}}a\PYG{o}{\textbar{}\textbar{}}\PYG{n+nv}{\PYGZus{}1} \PYG{o}{=} \PYG{l+m}{13}
\PYG{o}{\textbar{}\textbar{}}a\PYG{o}{\textbar{}\textbar{}}\PYG{n+nv}{\PYGZus{}2} \PYG{o}{=} \PYG{l+m}{6}.40312
\PYG{o}{\textbar{}\textbar{}}a\PYG{o}{\textbar{}\textbar{}}\PYG{n+nv}{\PYGZus{}infty} \PYG{o}{=} \PYG{l+m}{4}
sum \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{13}
max \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{4} a\PYG{o}{[} \PYG{l+m}{3} \PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}
min \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{1} a\PYG{o}{[} \PYG{l+m}{1} \PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}
a\PYG{l+s+s1}{\PYGZsq{} * a = 41}
\PYG{l+s+s1}{a quantile 0.2 = 2}
\PYG{l+s+s1}{b = a(I) : 5}
\PYG{l+s+s1}{      2   4   4  \PYGZhy{}3   4}

\PYG{l+s+s1}{c(I) = a 5}
\PYG{l+s+s1}{     \PYGZhy{}3  \PYGZhy{}3   2   4   2}

\PYG{l+s+s1}{b = a(I) : 5}
\PYG{l+s+s1}{      2   4   4  \PYGZhy{}3   4}

\PYG{l+s+s1}{c(I) = a 5}
\PYG{l+s+s1}{     \PYGZhy{}3  \PYGZhy{}3   4   9   4}

\PYG{l+s+s1}{A = 3 4}
\PYG{l+s+s1}{       1   5   2   1}
\PYG{l+s+s1}{       3   3   3   1}
\PYG{l+s+s1}{       4   5   2   4}

\PYG{l+s+s1}{C = 3 4}
\PYG{l+s+s1}{     (\PYGZhy{}50,\PYGZhy{}40) (\PYGZhy{}100,\PYGZhy{}80) (\PYGZhy{}150,\PYGZhy{}120) (\PYGZhy{}200,\PYGZhy{}160)}
\PYG{l+s+s1}{     (\PYGZhy{}100,\PYGZhy{}80) (\PYGZhy{}200,\PYGZhy{}160) (\PYGZhy{}300,\PYGZhy{}240) (\PYGZhy{}400,\PYGZhy{}320)}
\PYG{l+s+s1}{     (\PYGZhy{}150,\PYGZhy{}120) (\PYGZhy{}300,\PYGZhy{}240) (\PYGZhy{}450,\PYGZhy{}360) (\PYGZhy{}600,\PYGZhy{}480)}

\PYG{l+s+s1}{A = 3 4}
\PYG{l+s+s1}{       8  10  12  14}
\PYG{l+s+s1}{      16  20  24  28}
\PYG{l+s+s1}{      24  30  36  42}

\PYG{l+s+s1}{B = (3.*b*c\PYGZsq{}}\PYG{o}{)}\PYG{o}{(}I\PYGZca{}\PYGZhy{}1,J\PYGZca{}\PYGZhy{}1\PYG{o}{)} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{0}  \PYG{l+m}{12}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{10}
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYG{l+m}{12}
        \PYG{l+m}{1}         \PYG{l+m}{3} \PYG{l+m}{8}
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYG{l+m}{14}
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{l+m}{15}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{18}
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{l+m}{12}
        \PYG{l+m}{2}         \PYG{l+m}{4} \PYG{l+m}{21}
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYG{l+m}{5}
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{l+m}{6}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{4}
        \PYG{l+m}{3}         \PYG{l+m}{4} \PYG{l+m}{7}
\end{sphinxVerbatim}


\subsection{Block matrix}
\label{\detokenize{example/developers:block-matrix}}\label{\detokenize{example/developers:exampleblockmatrix}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{f2} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh1} \PYG{n}{u1}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Uh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh2} \PYG{n}{u2}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{vPoisson1} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f1} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vPoisson2} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f1} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Poisson1} \PYG{o}{=} \PYG{n}{vPoisson1}\PYG{p}{(}\PYG{n}{Uh1}\PYG{p}{,} \PYG{n}{Uh1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Poisson1b} \PYG{o}{=} \PYG{n}{vPoisson1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uh1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Poisson2} \PYG{o}{=} \PYG{n}{vPoisson2}\PYG{p}{(}\PYG{n}{Uh2}\PYG{p}{,} \PYG{n}{Uh2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Poisson2b} \PYG{o}{=} \PYG{n}{vPoisson2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uh2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//block matrix}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{G} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{Poisson1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Poisson2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{G}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//block right hand side}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Gb} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Poisson1b}\PYG{p}{,} \PYG{n}{Poisson2b}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol} \PYG{o}{=} \PYG{n}{G}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{Gb}\PYG{p}{;}

\PYG{c+c1}{// Dispatch}
\PYG{p}{[}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sol}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{BlockMatrix}.png}
\caption{Result}\label{\detokenize{example/developers:id2}}\end{figure}


\subsection{Matrix operations}
\label{\detokenize{example/developers:matrix-operations}}\label{\detokenize{example/developers:examplematrixoperations}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{f}\PYG{p}{,} \PYG{n}{g}\PYG{p}{;}
\PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{n}{g} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{ff}\PYG{p}{,} \PYG{n}{gg}\PYG{p}{;} \PYG{c+c1}{//a complex valued finite element function}
\PYG{n}{ff}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gg} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{mat} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{mati} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
         \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{n}{i}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{mat}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{mati}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//a complex sparse matrix}

\PYG{c+c1}{// Operations}
\PYG{n}{Vh} \PYG{n}{m0}\PYG{p}{;} \PYG{n}{m0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m01}\PYG{p}{;} \PYG{n}{m01}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m1}\PYG{p}{;} \PYG{n}{m1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m2}\PYG{p}{;} \PYG{n}{m2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{g = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m0 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m01 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m01}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m1 = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m2 = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dot Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hermitien Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{gg}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{outer Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hermitien outer Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{AA}\PYG{o}{=}\PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{o}{*}\PYG{n}{gg}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Diagonal}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diagofA}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{diagofA} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag}\PYG{p}{;} \PYG{c+c1}{//get the diagonal of the matrix}
\PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag} \PYG{o}{=} \PYG{n}{diagofA} \PYG{p}{;} \PYG{c+c1}{//set the diagonal of the matrix}

\PYG{c+c1}{// Sparse matrix set}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{J}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;} \PYG{c+c1}{//get the sparse term of the matrix A (the array are resized)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{C} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set a new matrix}
\PYG{k+kt}{matrix} \PYG{n}{D} \PYG{o}{=} \PYG{p}{[}\PYG{n}{diagofA}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set a diagonal matrix D from the array diagofA}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{D} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{f} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0} \PYG{l+m}{0}.5
      \PYG{l+m}{1}
\PYG{n+nv}{g} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{1} \PYG{l+m}{1}.224646799e\PYGZhy{}16   \PYG{l+m}{0}   \PYG{l+m}{1}
    \PYG{l+m}{1}.224646799e\PYGZhy{}16
\PYG{n+nv}{A} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{24}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYG{l+m}{0}
        \PYG{l+m}{1}         \PYG{l+m}{5} \PYGZhy{}2.5
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{l+m}{0}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{2}         \PYG{l+m}{5} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{2}         \PYG{l+m}{6} \PYGZhy{}2.5
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{l+m}{0}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{3}         \PYG{l+m}{6} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{4}         \PYG{l+m}{1} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{4}         \PYG{l+m}{4} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{4}         \PYG{l+m}{5} \PYG{l+m}{0}
        \PYG{l+m}{5}         \PYG{l+m}{1} \PYGZhy{}2.5
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{5}         \PYG{l+m}{4} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{l+m}{0}
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYGZhy{}2.5
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{l+m}{0}
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.0000000000000000199e+30

\PYG{n+nv}{m0} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}1.25   \PYGZhy{}2.25   \PYG{l+m}{0}.5   \PYG{l+m}{0} 5e+29
    1e+30
\PYG{n+nv}{m01} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}1.25   \PYGZhy{}2.25     \PYG{l+m}{0} \PYG{l+m}{0}.25    5e+29
    1e+30
\PYG{n+nv}{m1} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0} \PYG{l+m}{0}.5
    \PYG{l+m}{1}.224646799e\PYGZhy{}16
\PYG{n+nv}{m2} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}nan      \PYG{l+m}{0}   \PYG{l+m}{0} \PYGZhy{}nan    \PYG{l+m}{0}.5
    \PYG{l+m}{8}.165619677e+15
dot \PYG{n+nv}{Product} \PYG{o}{=} \PYG{l+m}{0}.5
hermitien \PYG{n+nv}{Product} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{1}.11022e\PYGZhy{}16,2.5\PYG{o}{)}
outer \PYG{n+nv}{Product} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{8}
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{l+m}{0}.5
        \PYG{l+m}{5}         \PYG{l+m}{3} \PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{0}.5
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYG{l+m}{1}
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{l+m}{1}
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16

hermitien outer \PYG{n+nv}{Product} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{24}
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0},0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{0}.5,3.0616169978683830179e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{o}{(}\PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17,\PYGZhy{}0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0},0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{0}.5,3.0616169978683830179e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{6} \PYG{o}{(}\PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17,\PYGZhy{}0.5\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0},1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{1},6.1232339957367660359e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{o}{(}\PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16,\PYGZhy{}1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0},1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{1},6.1232339957367660359e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{6} \PYG{o}{(}\PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16,\PYGZhy{}1\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0}.5,0.5\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{0}.5,\PYGZhy{}0.49999999999999994449\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{3} \PYG{o}{(}\PYGZhy{}0.49999999999999994449,\PYGZhy{}0.50000000000000011102\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0}.5,0.5\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{0}.5,\PYGZhy{}0.49999999999999994449\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{o}{(}\PYGZhy{}0.49999999999999994449,\PYGZhy{}0.50000000000000011102\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{1},1\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{1},\PYGZhy{}0.99999999999999988898\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{o}{(}\PYGZhy{}0.99999999999999988898,\PYGZhy{}1.000000000000000222\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{1},1\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{1},\PYGZhy{}0.99999999999999988898\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{o}{(}\PYGZhy{}0.99999999999999988898,\PYGZhy{}1.000000000000000222\PYG{o}{)}

\PYG{n+nv}{I} \PYG{o}{=} \PYG{l+m}{8}
      \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{5}
      \PYG{l+m}{5}   \PYG{l+m}{5}   \PYG{l+m}{5}
\PYG{n+nv}{J} \PYG{o}{=} \PYG{l+m}{8}
      \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{1}
      \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{5}
\PYG{n+nv}{C} \PYG{o}{=} \PYG{l+m}{8}
    \PYG{l+m}{0}.5 \PYG{l+m}{6}.123233996e\PYGZhy{}17 \PYG{l+m}{0}.5 \PYG{l+m}{6}.123233996e\PYGZhy{}17   \PYG{l+m}{1}
    \PYG{l+m}{1}.224646799e\PYGZhy{}16   \PYG{l+m}{1} \PYG{l+m}{1}.224646799e\PYGZhy{}16
  \PYGZhy{}\PYGZhy{} Raw Matrix    \PYG{n+nv}{nxm}  \PYG{o}{=}6x6 nb  none zero coef. \PYG{l+m}{8}
  \PYGZhy{}\PYGZhy{} Raw Matrix    \PYG{n+nv}{nxm}  \PYG{o}{=}6x6 nb  none zero coef. \PYG{l+m}{6}
\PYG{n+nv}{D} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{1}  \PYG{l+m}{6}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{0}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{0}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{0}
        \PYG{l+m}{4}         \PYG{l+m}{4} \PYG{l+m}{0}
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{0}.5
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
Due to \sphinxcode{\sphinxupquote{Fortran}} indices starting at one, the output of a diagonal matrix \sphinxcode{\sphinxupquote{D}} is indexed from 1. but in \sphinxstylestrong{FreeFEM}, the indices start from 0.
\end{sphinxadmonition}


\subsection{Matrix inversion}
\label{\detokenize{example/developers:matrix-inversion}}\label{\detokenize{example/developers:examplematrixinversion}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lapack}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fflapack}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Matrix}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{n}{j}\PYG{p}{)} \PYG{o}{?} \PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Inversion (lapack)}
\PYG{k+kp}{A1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//def in \PYGZdq{}lapack\PYGZdq{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kp}{B} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
            \PYG{k+kp}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{A1}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Inversion (fflapack)}
\PYG{n}{inv}\PYG{p}{(}\PYG{k+kp}{A1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def in \PYGZdq{}fflapack\PYGZdq{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}

\PYG{l+m}{5} \PYG{l+m}{5}
     \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18

\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{1} \PYG{l+m}{1}.040834086e\PYGZhy{}17 \PYG{l+m}{1}.040834086e\PYGZhy{}17 \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{3}.469446952e\PYGZhy{}18   \PYG{l+m}{1} \PYGZhy{}1.734723476e\PYGZhy{}17 \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{2}.428612866e\PYGZhy{}17 \PYGZhy{}3.122502257e\PYGZhy{}17   \PYG{l+m}{1} \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{2}.081668171e\PYGZhy{}17 \PYGZhy{}6.938893904e\PYGZhy{}17 \PYGZhy{}3.469446952e\PYGZhy{}17   \PYG{l+m}{1}   \PYG{l+m}{0}
     \PYG{l+m}{2}.775557562e\PYGZhy{}17 \PYGZhy{}4.163336342e\PYGZhy{}17 \PYGZhy{}2.775557562e\PYGZhy{}17   \PYG{l+m}{0}   \PYG{l+m}{1}

\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
To compile \sphinxcode{\sphinxupquote{lapack.cpp}} and \sphinxcode{\sphinxupquote{fflapack.cpp}}, you must have the \sphinxcode{\sphinxupquote{lapack}} library on your system and compile the plugin with the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}c++ lapack.cpp \PYGZhy{}llapack     ff\PYGZhy{}c++ fflapack.cpp \PYGZhy{}llapack
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{FE array}
\label{\detokenize{example/developers:fe-array}}\label{\detokenize{example/developers:examplefearray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{f}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{uu}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//an array of FE function}
\PYG{c+c1}{// Solve problem 1}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 2}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 3}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray1}.png}
\caption{First result}\label{\detokenize{example/developers:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray2}.png}
\caption{Second result}\label{\detokenize{example/developers:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray3}.png}
\caption{Third result}\label{\detokenize{example/developers:id5}}\end{subfigure}
\caption{Finite element array}

\end{figure}



\subsection{Loop}
\label{\detokenize{example/developers:loop}}\label{\detokenize{example/developers:exampleloop}}\label{\detokenize{example/developers:FEArray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{=}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{k+kp}{eps} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{eps} \PYG{o}{=} \PYG{k+kp}{eps}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{)}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{k}{continue}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{j = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Implicit loop}
\label{\detokenize{example/developers:implicit-loop}}\label{\detokenize{example/developers:exampleimplicitloop}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{bi} \PYG{o}{:} \PYG{n}{b}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{n}{bi} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{n}{a}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{n}{aij} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{aij}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2}\PYG{p}{)} \PYG{n}{aij} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{ss}\PYG{p}{;} \PYG{c+c1}{//a map}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{bi} \PYG{o}{:} \PYG{n}{ss}\PYG{p}{]}
    \PYG{n}{bi} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{6} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dddd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ss = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{si}\PYG{p}{;}
\PYG{n}{si}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{si}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{vi} \PYG{o}{:} \PYG{n}{si}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ i }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{setw}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{setw}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n+nf}{atoi}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{si = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{si} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{k+kp}{A}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{aij} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{aij} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{aij}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{0} \PYG{l+m}{1}
\PYG{l+m}{1} \PYG{l+m}{2}
\PYG{l+m}{2} \PYG{l+m}{3}
\PYG{l+m}{3} \PYG{l+m}{4}
\PYG{l+m}{4} \PYG{l+m}{5}
\PYG{l+m}{5} \PYG{l+m}{6}
\PYG{l+m}{6} \PYG{l+m}{7}
\PYG{l+m}{7} \PYG{l+m}{8}
\PYG{l+m}{8} \PYG{l+m}{9}
\PYG{l+m}{9} \PYG{l+m}{10}
\PYG{n+nv}{b} \PYG{o}{=} \PYG{l+m}{10}
      \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}
      \PYG{l+m}{6}   \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}

\PYG{n+nv}{a} \PYG{o}{=} \PYG{l+m}{10} \PYG{l+m}{10}
     \PYG{l+m}{0}.5 \PYG{l+m}{0}.3333333333 \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.3333333333 \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}

\PYG{n+nv}{ss} \PYG{o}{=} \PYG{l+m}{1} \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{5}

 i   \PYG{l+m}{1}          \PYG{l+m}{2}
 i  \PYG{l+m}{50}          \PYG{l+m}{1}
\PYG{n+nv}{si} \PYG{o}{=} \PYG{l+m}{1} \PYG{l+m}{2}
\PYG{l+m}{50} \PYG{l+m}{100}

\PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0}.5
\PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{0}.333333
\PYG{l+m}{0} \PYG{l+m}{2} \PYG{l+m}{0}.25
\PYG{l+m}{0} \PYG{l+m}{3} \PYG{l+m}{0}.2
\PYG{l+m}{1} \PYG{l+m}{0} \PYG{l+m}{0}.333333
\PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{0}.25
\PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{0}.2
\PYG{l+m}{2} \PYG{l+m}{0} \PYG{l+m}{0}.25
\PYG{l+m}{2} \PYG{l+m}{1} \PYG{l+m}{0}.2
\PYG{l+m}{3} \PYG{l+m}{0} \PYG{l+m}{0}.2
\PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{10} \PYG{l+m}{10} \PYG{l+m}{0}  \PYG{l+m}{10}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYGZhy{}0.5
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYGZhy{}0.33333333333333331483
        \PYG{l+m}{1}         \PYG{l+m}{3} \PYGZhy{}0.25
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYGZhy{}0.33333333333333331483
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYGZhy{}0.25
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYGZhy{}0.25
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{4}         \PYG{l+m}{1} \PYGZhy{}0.2000000000000000111
\end{sphinxVerbatim}


\subsection{I/O}
\label{\detokenize{example/developers:i-o}}\label{\detokenize{example/developers:exampleio}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{std\PYGZhy{}out}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ enter i = ?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//close the file f because the variable f is delete}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//to append to the existing file \PYGZdq{}toto.txt\PYGZdq{}}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//close the file f because the variable f is delete}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{File stream}
\label{\detokenize{example/developers:file-stream}}\label{\detokenize{example/developers:examplefilestream}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{where}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{f} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{precision}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{where} \PYG{o}{=} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{tellp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.1} \PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where in file }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{where} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZsh{} comment bla bla ... 0.3 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{flush}\PYG{p}{;} \PYG{c+c1}{//to flush the buffer of file}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Function to skip comment starting with \PYGZsh{} in a file}
\PYG{k+kt}{func} \PYG{k+kt}{ifstream} \PYG{n}{skipcomment}\PYG{p}{(}\PYG{k+kt}{ifstream} \PYG{o}{\PYGZam{}}\PYG{n}{ff}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{where} \PYG{o}{=} \PYG{n}{ff}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//store file position}
        \PYG{k+kt}{string} \PYG{n}{comment}\PYG{p}{;}
        \PYG{n}{ff} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{comment}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{ff}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{comment}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZsh{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{comment}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} \PYGZsh{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comment} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}\PYG{p}{\PYGZob{}}
            \PYG{n}{ff}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{where}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//restore file position}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{ff}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{where}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ good ? }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{xx} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{skipcomment}\PYG{p}{(}\PYG{k+kp}{file}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{xx} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//rewind}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{g}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Command line arguments}
\label{\detokenize{example/developers:command-line-arguments}}\label{\detokenize{example/developers:examplecommandlinearguments}}
When using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ script.edp arg1 arg2
\end{sphinxVerbatim}

The arguments can be used in the script with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

When using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ script.edp \PYGZhy{}n \PYG{l+m}{10} \PYGZhy{}a \PYG{l+m}{1}. \PYGZhy{}d \PYG{l+m}{42}.
\end{sphinxVerbatim}

The arguments can be used in the script with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Macro}
\label{\detokenize{example/developers:macro}}\label{\detokenize{example/developers:examplemacro}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro without parameters}
\PYG{k+kt}{macro} \PYG{n+nf}{xxx}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}

\PYG{n}{xxx}

\PYG{c+c1}{// Macro with parameters}
\PYG{k+kt}{macro} \PYG{n}{toto}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{n}{i} \PYG{c+c1}{//}

\PYG{n}{toto}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{// Macro as parameter of a macro}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{VIL6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VIL3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{func} \PYG{n}{C5x5} \PYG{o}{=} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{VIL6}\PYG{p}{,} \PYG{n}{CC}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{E5x2} \PYG{o}{=} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{VIL3}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Eps} \PYG{o}{=} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{VIL3}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Macro concatenation}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{Ux}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{div}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Verify the quoting}
\PYG{k+kt}{macro} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)} \PYG{n}{i} \PYG{n}{j} \PYG{n}{k} \PYG{c+c1}{//}
\PYG{n}{foo}\PYG{p}{(}\PYG{p}{,} \PYG{p}{,} \PYG{p}{)}
\PYG{n}{foo}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{//NewMacro \PYGZhy{} EndMacro}
\PYG{k+kt}{NewMacro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{k+kt}{EndMacro}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// IFMACRO \PYGZhy{} ENDIFMACRO}
\PYG{k+kt}{macro} \PYG{n}{AA} \PYG{n}{CAS1} \PYG{c+c1}{//}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,}\PYG{n}{CAS1} \PYG{p}{)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AA = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{CASE} \PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{c+cp}{ENDIFMACRO}
\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{n}{CAS2}\PYG{p}{)}
\PYG{k+kt}{macro} \PYG{n}{CASE} \PYG{n}{file2}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{c+cp}{ENDIFMACRO}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CASE = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)}
\PYG{c+cp}{include} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)}
\PYG{c+cp}{ENDIFMACRO}

\PYG{c+c1}{// FILE \PYGZhy{} LINE}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{FILE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, line }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{LINE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output script generated with macros is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{c+c1}{// Macro without parameters}
\PYG{l+m+mi}{2} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{xxx} \PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{3} \PYG{o}{:}     \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{4} \PYG{o}{:}     \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{5} \PYG{o}{:}     \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{6} \PYG{o}{:} \PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}
\PYG{l+m+mi}{7} \PYG{o}{:}
\PYG{l+m+mi}{8} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}
\PYG{l+m+mi}{4} \PYG{o}{:}  \PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{1} \PYG{o}{:}     \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}     \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{3} \PYG{o}{:}     \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{4} \PYG{o}{:} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mi}{9} \PYG{o}{:}
\PYG{l+m+mi}{10} \PYG{o}{:} \PYG{c+c1}{// Macro with parameters}
\PYG{l+m+mi}{11} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{toto}\PYG{p}{(}\PYG{n}{i} \PYG{p}{)}   \PYG{n}{i} \PYG{c+c1}{//}
\PYG{l+m+mi}{12} \PYG{o}{:}
\PYG{l+m+mi}{13} \PYG{o}{:}                    \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{14} \PYG{o}{:}
\PYG{l+m+mi}{15} \PYG{o}{:} \PYG{c+c1}{// Macro as parameter of a macro}
\PYG{l+m+mi}{16} \PYG{o}{:} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{17} \PYG{o}{:}
\PYG{l+m+mi}{18} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VIL6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{i} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{19} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VIL3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{i} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{20} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vv} \PYG{p}{)}   \PYG{p}{[}
\PYG{l+m+mi}{21} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mi}{22} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mi}{23} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{24} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vv} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{25} \PYG{o}{:}
\PYG{l+m+mi}{26} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{C5x5} \PYG{o}{=}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}       \PYG{p}{[}
\PYG{l+m+mi}{1} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}         \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{2} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}         \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{3} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{27} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{E5x2} \PYG{o}{=}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}       \PYG{p}{[}
\PYG{l+m+mi}{1} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{2} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{3} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{28} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{Eps} \PYG{o}{=}      \PYG{p}{[}     \PYG{p}{[} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{29} \PYG{o}{:}
\PYG{l+m+mi}{30} \PYG{o}{:} \PYG{c+c1}{// Macro concatenation}
\PYG{l+m+mi}{31} \PYG{o}{:} \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{32} \PYG{o}{:} \PYG{k+kt}{fespace} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{33} \PYG{o}{:} \PYG{n}{Vh} \PYG{n}{Ux}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{l+m+mi}{34} \PYG{o}{:}
\PYG{l+m+mi}{35} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{V} \PYG{p}{)}   \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{l+m+mi}{36} \PYG{o}{:}
\PYG{l+m+mi}{37} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{38} \PYG{o}{:}
\PYG{l+m+mi}{39} \PYG{o}{:} \PYG{c+c1}{// Verify the quoting}
\PYG{l+m+mi}{40} \PYG{o}{:}    \PYG{k+kt}{macro} \PYG{n}{foo}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k} \PYG{p}{)}   \PYG{n}{i} \PYG{n}{j} \PYG{n}{k} \PYG{c+c1}{//}
\PYG{l+m+mi}{41} \PYG{o}{:}
\PYG{l+m+mi}{42} \PYG{o}{:}         \PYG{k+kt}{int}\PYG{p}{[} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{43} \PYG{o}{:}
\PYG{l+m+mi}{44} \PYG{o}{:} \PYG{c+c1}{//NewMacro \PYGZhy{} EndMacro}
\PYG{l+m+mi}{45} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u} \PYG{p}{)}   \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}
\PYG{l+m+mi}{46} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}    \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZsq{}} \PYG{o}{*}     \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{]} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{47} \PYG{o}{:}
\PYG{l+m+mi}{48} \PYG{o}{:} \PYG{c+c1}{// IFMACRO \PYGZhy{} ENDIFMACRO}
\PYG{l+m+mi}{49} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{AACAS1} \PYG{c+c1}{//}
\PYG{l+m+mi}{50} \PYG{o}{:}
\PYG{l+m+mi}{51} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AA = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(} \PYG{n}{CAS1} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{CASEfile1}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{l+m+mi}{3} \PYG{o}{:}
\PYG{l+m+mi}{52} \PYG{o}{:}
\PYG{l+m+mi}{53} \PYG{o}{:}
\PYG{l+m+mi}{54} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CASE = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{55} \PYG{o}{:}
\PYG{l+m+mi}{56} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{c+cp}{include} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{p}{)}\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is the file 1}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{57} \PYG{o}{:}
\PYG{l+m+mi}{58} \PYG{o}{:} \PYG{c+c1}{// FILE \PYGZhy{} LINE}
\PYG{l+m+mi}{59} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{FILE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, line }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{LINE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

The output os this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{AA} \PYG{o}{=} CAS1
\PYG{n+nv}{CASE} \PYG{o}{=} file1.edp
This is the file \PYG{l+m}{1}
In Macro.edp, line \PYG{l+m}{59}
\end{sphinxVerbatim}


\subsection{Basic error handling}
\label{\detokenize{example/developers:basic-error-handling}}\label{\detokenize{example/developers:examplebasicerrorhandling}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a}\PYG{p}{;}
\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch} \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{c+c1}{//all exceptions can be caught}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Catch an ExecError}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{1}/0 : d d d
  current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{3}
Exec error :  Div by \PYG{l+m}{0}
   \PYGZhy{}\PYGZhy{} number :1
Catch an ExecError
\end{sphinxVerbatim}


\subsection{Error handling}
\label{\detokenize{example/developers:error-handling}}\label{\detokenize{example/developers:exampleerrorhandling}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//right hand side function}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//boundary condition function}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{cpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{tolpivot}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Try Cholesky}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{laplace}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Display}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{laplacian Cholesky }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nn} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, x\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nn} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{o}{+}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{//catch all error}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Catch cholesky PB }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Try Cholesky
ERREUR choleskypivot \PYG{o}{(}\PYG{l+m}{35}\PYG{o}{)}\PYG{o}{=} \PYGZhy{}6.43929e\PYGZhy{}15 \PYGZlt{} 1e\PYGZhy{}06
  current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{29}
Exec error : FATAL ERREUR dans ./../femlib/MatriceCreuse\PYGZus{}tpl.hpp
cholesky line:
   \PYGZhy{}\PYGZhy{} number :688
 catch an erreur in  \PYG{n+nv}{solve}  \PYG{o}{=}\PYGZgt{}  \PYG{n+nb}{set}  \PYG{n+nv}{sol} \PYG{o}{=} \PYG{l+m}{0} !!!!!!!
 Catch cholesky PB
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}